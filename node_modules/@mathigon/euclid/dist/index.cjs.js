"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Angle: () => Angle,
  Arc: () => Arc,
  Bounds: () => Bounds,
  Circle: () => Circle,
  Ellipse: () => Ellipse,
  Line: () => Line,
  ORIGIN: () => ORIGIN,
  Point: () => Point,
  Polygon: () => Polygon,
  Polyline: () => Polyline,
  Ray: () => Ray,
  Rectangle: () => Rectangle,
  Sector: () => Sector,
  Segment: () => Segment,
  TWO_PI: () => TWO_PI,
  Triangle: () => Triangle,
  difference: () => difference,
  drawCanvas: () => drawCanvas,
  drawRoundedRect: () => drawRoundedRect,
  drawSVG: () => drawSVG,
  intersect: () => intersect,
  intersections: () => intersections,
  isAngle: () => isAngle,
  isArc: () => isArc,
  isCircle: () => isCircle,
  isEllipse: () => isEllipse,
  isLine: () => isLine,
  isLineLike: () => isLineLike,
  isPoint: () => isPoint,
  isPolygon: () => isPolygon,
  isPolygonLike: () => isPolygonLike,
  isPolyline: () => isPolyline,
  isRay: () => isRay,
  isRectangle: () => isRectangle,
  isSector: () => isSector,
  isSegment: () => isSegment,
  rad: () => rad,
  toDeg: () => toDeg,
  toRad: () => toRad,
  union: () => union,
  xor: () => xor
});
module.exports = __toCommonJS(src_exports);

// src/angle.ts
var import_fermat9 = require("@mathigon/fermat");

// src/arc.ts
var import_fermat5 = require("@mathigon/fermat");

// src/circle.ts
var import_fermat4 = require("@mathigon/fermat");

// src/line.ts
var import_fermat3 = require("@mathigon/fermat");

// src/point.ts
var import_core = require("@mathigon/core");
var import_fermat2 = require("@mathigon/fermat");

// src/utilities.ts
var import_fermat = require("@mathigon/fermat");
var TWO_PI = 2 * Math.PI;
function rad(p, c) {
  const a = Math.atan2(p.y - (c ? c.y : 0), p.x - (c ? c.x : 0));
  return (0, import_fermat.mod)(a, TWO_PI);
}
function findClosest(p, items) {
  let q = void 0;
  let d = Infinity;
  let index = -1;
  for (const [i, e] of items.entries()) {
    const q1 = e.project(p);
    const d1 = Point.distance(p, q1);
    if (d1 < d) {
      q = q1;
      d = d1;
      index = i;
    }
  }
  return q ? [q, index] : void 0;
}

// src/point.ts
var Point = class _Point {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
    this.type = "point";
  }
  get unitVector() {
    if ((0, import_fermat2.nearlyEquals)(this.length, 0))
      return new _Point(1, 0);
    return this.scale(1 / this.length);
  }
  get length() {
    return Math.sqrt(this.x ** 2 + this.y ** 2);
  }
  get inverse() {
    return new _Point(-this.x, -this.y);
  }
  get flip() {
    return new _Point(this.y, this.x);
  }
  get perpendicular() {
    return new _Point(-this.y, this.x);
  }
  get array() {
    return [this.x, this.y];
  }
  /** Finds the perpendicular distance between this point and a line. */
  distanceFromLine(l) {
    return _Point.distance(this, l.project(this));
  }
  /** Clamps this point to specific bounds. */
  clamp(bounds, padding = 0) {
    const x = (0, import_fermat2.clamp)(this.x, bounds.xMin + padding, bounds.xMax - padding);
    const y = (0, import_fermat2.clamp)(this.y, bounds.yMin + padding, bounds.yMax - padding);
    return new _Point(x, y);
  }
  changeCoordinates(originCoords, targetCoords) {
    const x = targetCoords.xMin + (this.x - originCoords.xMin) / originCoords.dx * targetCoords.dx;
    const y = targetCoords.yMin + (this.y - originCoords.yMin) / originCoords.dy * targetCoords.dy;
    return new _Point(x, y);
  }
  add(p) {
    return _Point.sum(this, p);
  }
  subtract(p) {
    return _Point.difference(this, p);
  }
  round(inc = 1) {
    return new _Point((0, import_fermat2.roundTo)(this.x, inc), (0, import_fermat2.roundTo)(this.y, inc));
  }
  floor() {
    return new _Point(Math.floor(this.x), Math.floor(this.y));
  }
  mod(x, y = x) {
    return new _Point(this.x % x, this.y % y);
  }
  angle(c = ORIGIN) {
    return rad(this, c);
  }
  // Snap to the x or y values of another point
  snap(p, tolerance = 5) {
    if ((0, import_fermat2.nearlyEquals)(this.x, p.x, tolerance))
      return new _Point(p.x, this.y);
    if ((0, import_fermat2.nearlyEquals)(this.y, p.y, tolerance))
      return new _Point(this.x, p.y);
    return this;
  }
  /** Calculates the average of multiple points. */
  static average(...points) {
    const x = (0, import_core.total)(points.map((p) => p.x)) / points.length;
    const y = (0, import_core.total)(points.map((p) => p.y)) / points.length;
    return new _Point(x, y);
  }
  /** Calculates the dot product of two points p1 and p2. */
  static dot(p1, p2) {
    return p1.x * p2.x + p1.y * p2.y;
  }
  static sum(p1, p2) {
    return new _Point(p1.x + p2.x, p1.y + p2.y);
  }
  static difference(p1, p2) {
    return new _Point(p1.x - p2.x, p1.y - p2.y);
  }
  /** Returns the Euclidean distance between two points p1 and p2. */
  static distance(p1, p2) {
    return Math.sqrt((0, import_fermat2.square)(p1.x - p2.x) + (0, import_fermat2.square)(p1.y - p2.y));
  }
  /** Returns the Manhattan distance between two points p1 and p2. */
  static manhattan(p1, p2) {
    return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
  }
  /** Interpolates two points p1 and p2 by a factor of t. */
  static interpolate(p1, p2, t = 0.5) {
    return new _Point((0, import_fermat2.lerp)(p1.x, p2.x, t), (0, import_fermat2.lerp)(p1.y, p2.y, t));
  }
  /** Interpolates a list of multiple points. */
  static interpolateList(points, t = 0.5) {
    const n = points.length - 1;
    const a = Math.floor((0, import_fermat2.clamp)(t, 0, 1) * n);
    return _Point.interpolate(points[a], points[a + 1], n * t - a);
  }
  /** Creates a point from polar coordinates. */
  static fromPolar(angle, r = 1) {
    return new _Point(r * Math.cos(angle), r * Math.sin(angle));
  }
  static random(b) {
    const x = import_fermat2.Random.uniform(b.xMin, b.xMax);
    const y = import_fermat2.Random.uniform(b.yMin, b.yMax);
    return new _Point(x, y);
  }
  static equals(p1, p2, precision) {
    return (0, import_fermat2.nearlyEquals)(p1.x, p2.x, precision) && (0, import_fermat2.nearlyEquals)(p1.y, p2.y, precision);
  }
  /** Check if p1, p2 and p3 lie on a straight line. */
  static colinear(p1, p2, p3, tolerance) {
    const dx1 = p1.x - p2.x;
    const dy1 = p1.y - p2.y;
    const dx2 = p2.x - p3.x;
    const dy2 = p2.y - p3.y;
    return (0, import_fermat2.nearlyEquals)(dx1 * dy2, dx2 * dy1, tolerance);
  }
  // ---------------------------------------------------------------------------
  /** Transforms this point using a 2x3 matrix m. */
  transform(m) {
    const x = m[0][0] * this.x + m[0][1] * this.y + m[0][2];
    const y = m[1][0] * this.x + m[1][1] * this.y + m[1][2];
    return new _Point(x, y);
  }
  /** Rotates this point by a given angle (in radians) around point `c`. */
  rotate(angle, c = ORIGIN) {
    if ((0, import_fermat2.nearlyEquals)(angle, 0))
      return this;
    const x0 = this.x - c.x;
    const y0 = this.y - c.y;
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const x = x0 * cos - y0 * sin + c.x;
    const y = x0 * sin + y0 * cos + c.y;
    return new _Point(x, y);
  }
  /** Reflects this point across a line l. */
  reflect(l) {
    const v = l.p2.x - l.p1.x;
    const w = l.p2.y - l.p1.y;
    const x0 = this.x - l.p1.x;
    const y0 = this.y - l.p1.y;
    const mu = (v * y0 - w * x0) / (v * v + w * w);
    const x = this.x + 2 * mu * w;
    const y = this.y - 2 * mu * v;
    return new _Point(x, y);
  }
  scale(sx, sy = sx) {
    return new _Point(this.x * sx, this.y * sy);
  }
  shift(x, y = x) {
    return new _Point(this.x + x, this.y + y);
  }
  translate(p) {
    return this.shift(p.x, p.y);
  }
  equals(other, precision) {
    return _Point.equals(this, other, precision);
  }
  toString() {
    return `point(${this.x},${this.y})`;
  }
};
var ORIGIN = new Point(0, 0);

// src/types.ts
function isPolygonLike(shape) {
  return ["polygon", "polyline", "rectangle", "triangle"].includes(shape.type);
}
function isPolygon(shape) {
  return ["polygon", "triangle"].includes(shape.type);
}
function isPolyline(shape) {
  return shape.type === "polyline";
}
function isRectangle(shape) {
  return shape.type === "rectangle";
}
function isLineLike(shape) {
  return ["line", "ray", "segment"].includes(shape.type);
}
function isLine(shape) {
  return shape.type === "line";
}
function isRay(shape) {
  return shape.type === "ray";
}
function isSegment(shape) {
  return shape.type === "segment";
}
function isCircle(shape) {
  return shape.type === "circle";
}
function isEllipse(shape) {
  return shape.type === "ellipse";
}
function isArc(shape) {
  return shape.type === "arc";
}
function isSector(shape) {
  return shape.type === "sector";
}
function isAngle(shape) {
  return shape.type === "angle";
}
function isPoint(shape) {
  return shape.type === "point";
}

// src/line.ts
var Line = class _Line {
  constructor(p1, p2) {
    this.p1 = p1;
    this.p2 = p2;
    this.type = "line";
  }
  /* The distance between the two points defining this line. */
  get length() {
    return Point.distance(this.p1, this.p2);
  }
  /* The squared distance between the two points defining this line. */
  get lengthSquared() {
    return (this.p1.x - this.p2.x) ** 2 + (this.p1.y - this.p2.y) ** 2;
  }
  /** The midpoint of this line. */
  get midpoint() {
    return Point.average(this.p1, this.p2);
  }
  /** The slope of this line. */
  get slope() {
    return (this.p2.y - this.p1.y) / (this.p2.x - this.p1.x);
  }
  /** The y-axis intercept of this line. */
  get intercept() {
    return this.p1.y - this.slope * this.p1.x;
  }
  /** The angle formed between this line and the x-axis. */
  get angle() {
    return rad(this.p2, this.p1);
  }
  /** The point representing a unit vector along this line. */
  get unitVector() {
    return this.p2.subtract(this.p1).unitVector;
  }
  /** The point representing the perpendicular vector of this line. */
  get perpendicularVector() {
    return new Point(this.p2.y - this.p1.y, this.p1.x - this.p2.x).unitVector;
  }
  /** Finds the line parallel to this one, going through point p. */
  parallel(p) {
    return new _Line(p, p.add(this.p2).subtract(this.p1));
  }
  /** Finds the line perpendicular to this one, going through point p. */
  perpendicular(p) {
    const q = this.line.project(p);
    if (Point.equals(p, q))
      return new _Line(q, q.add(this.perpendicularVector.scale(this.length / 2)));
    return new _Line(q, p);
  }
  /** The perpendicular bisector of this line. */
  get perpendicularBisector() {
    return this.perpendicular(this.midpoint);
  }
  /** Squared distance between a point and a line. */
  distanceSquared(p) {
    const proj = this.project(p);
    return (p.x - proj.x) ** 2 + (p.y - proj.y) ** 2;
  }
  get line() {
    return this.type === "line" ? this : new _Line(this.p1, this.p2);
  }
  get ray() {
    return isRay(this) ? this : new Ray(this.p1, this.p2);
  }
  get segment() {
    return isSegment(this) ? this : new Segment(this.p1, this.p2);
  }
  // ---------------------------------------------------------------------------
  /** Signed distance along the line (opposite of .at()). */
  offset(p) {
    const a = Point.difference(this.p2, this.p1);
    const b = Point.difference(p, this.p1);
    return Point.dot(a, b) / this.lengthSquared;
  }
  /** Projects a point `p` onto this line. */
  project(p) {
    return this.at(this.offset(p));
  }
  /** Returns which side of this line a point p is on (or 0 on the line). */
  side(p, tolerance) {
    const a = Point.difference(this.p2, this.p1);
    const b = Point.difference(p, this.p1);
    const d = b.x * a.y - b.y * a.x;
    return (0, import_fermat3.nearlyEquals)(d, 0, tolerance) ? 0 : Math.sign(d);
  }
  /** Checks if a point p lies on this line. */
  contains(p, tolerance) {
    return this.side(p, tolerance) === 0;
  }
  /** Gets the point at a specific offset along the line (opposite of .offset()). */
  at(t) {
    return Point.interpolate(this.p1, this.p2, t);
  }
  // ---------------------------------------------------------------------------
  transform(m) {
    return new this.constructor(this.p1.transform(m), this.p2.transform(m));
  }
  /** Rotates this line by a given angle (in radians), optionally around point `c`. */
  rotate(a, c = ORIGIN) {
    if ((0, import_fermat3.nearlyEquals)(a, 0))
      return this;
    return new this.constructor(this.p1.rotate(a, c), this.p2.rotate(a, c));
  }
  reflect(l) {
    return new this.constructor(this.p1.reflect(l), this.p2.reflect(l));
  }
  scale(sx, sy = sx) {
    return new this.constructor(this.p1.scale(sx, sy), this.p2.scale(sx, sy));
  }
  shift(x, y = x) {
    return new this.constructor(this.p1.shift(x, y), this.p2.shift(x, y));
  }
  translate(p) {
    return this.shift(p.x, p.y);
  }
  equals(other, tolerance) {
    return this.contains(other.p1, tolerance) && this.contains(other.p2, tolerance);
  }
  toString() {
    return `line(${this.p1},${this.p2})`;
  }
};
var Ray = class extends Line {
  constructor() {
    super(...arguments);
    this.type = "ray";
  }
  equals(other, tolerance) {
    if (other.type !== "ray")
      return false;
    if (!this.p1.equals(other.p1, tolerance))
      return false;
    if (this.p2.equals(other.p2, tolerance))
      return true;
    return other.contains(this.p2, tolerance) || this.contains(other.p2, tolerance);
  }
  contains(p, tolerance) {
    if (!super.contains(p, tolerance))
      return false;
    const offset = this.offset(p);
    return (0, import_fermat3.nearlyEquals)(offset, 0, tolerance) || offset > 0;
  }
  toString() {
    return `ray(${this.p1},${this.p2})`;
  }
};
var Segment = class _Segment extends Line {
  constructor() {
    super(...arguments);
    this.type = "segment";
  }
  contains(p, tolerance) {
    if (!super.contains(p, tolerance))
      return false;
    if (this.p1.equals(p, tolerance) || this.p2.equals(p, tolerance))
      return true;
    if ((0, import_fermat3.nearlyEquals)(this.p1.x, this.p2.x, tolerance)) {
      return (0, import_fermat3.isBetween)(p.y, this.p1.y, this.p2.y);
    } else {
      return (0, import_fermat3.isBetween)(p.x, this.p1.x, this.p2.x);
    }
  }
  project(p) {
    const a = Point.difference(this.p2, this.p1);
    const b = Point.difference(p, this.p1);
    const q = (0, import_fermat3.clamp)(Point.dot(a, b) / this.lengthSquared, 0, 1);
    return this.p1.add(a.scale(q));
  }
  /** Contracts (or expands) a line by a specific ratio. */
  contract(x) {
    return new _Segment(this.at(x), this.at(1 - x));
  }
  equals(other, tolerance, oriented = false) {
    if (other.type !== "segment")
      return false;
    return this.p1.equals(other.p1, tolerance) && this.p2.equals(other.p2, tolerance) || !oriented && this.p1.equals(other.p2, tolerance) && this.p2.equals(other.p1, tolerance);
  }
  toString() {
    return `segment(${this.p1},${this.p2})`;
  }
};

// src/circle.ts
var Circle = class _Circle {
  constructor(c = ORIGIN, r = 1) {
    this.c = c;
    this.r = r;
    this.type = "circle";
  }
  /** The length of the circumference of this circle. */
  get circumference() {
    return TWO_PI * this.r;
  }
  /** The area of this circle. */
  get area() {
    return Math.PI * this.r ** 2;
  }
  get arc() {
    const start = this.c.shift(this.r, 0);
    return new Arc(this.c, start, TWO_PI);
  }
  tangentAt(t) {
    const p1 = this.at(t);
    const p2 = this.c.rotate(Math.PI / 2, p1);
    return new Line(p1, p2);
  }
  collision(r) {
    const tX = this.c.x < r.p.x ? r.p.x : this.c.x > r.p.x + r.w ? r.p.x + r.w : this.c.x;
    const tY = this.c.y < r.p.y ? r.p.y : this.c.y > r.p.y + r.h ? r.p.y + r.h : this.c.y;
    const d = Point.distance(this.c, new Point(tX, tY));
    return d <= this.r;
  }
  // ---------------------------------------------------------------------------
  project(p) {
    const proj = p.subtract(this.c).unitVector.scale(this.r);
    return Point.sum(this.c, proj);
  }
  at(t) {
    const a = TWO_PI * t;
    return this.c.shift(this.r * Math.cos(a), this.r * Math.sin(a));
  }
  offset(p) {
    return rad(p, this.c) / TWO_PI;
  }
  contains(p) {
    return Point.distance(p, this.c) <= this.r;
  }
  // ---------------------------------------------------------------------------
  transform(m) {
    const scale = Math.abs(m[0][0]) + Math.abs(m[1][1]);
    return new _Circle(this.c.transform(m), this.r * scale / 2);
  }
  rotate(a, c = ORIGIN) {
    if ((0, import_fermat4.nearlyEquals)(a, 0))
      return this;
    return new _Circle(this.c.rotate(a, c), this.r);
  }
  reflect(l) {
    return new _Circle(this.c.reflect(l), this.r);
  }
  scale(sx, sy = sx) {
    return new _Circle(this.c.scale(sx, sy), this.r * (sx + sy) / 2);
  }
  shift(x, y = x) {
    return new _Circle(this.c.shift(x, y), this.r);
  }
  translate(p) {
    return this.shift(p.x, p.y);
  }
  equals(other, tolerance) {
    return (0, import_fermat4.nearlyEquals)(this.r, other.r, tolerance) && this.c.equals(other.c, tolerance);
  }
  toString() {
    return `circle(${this.c},${this.r})`;
  }
};

// src/arc.ts
var Arc = class {
  constructor(c, start, angle) {
    this.c = c;
    this.start = start;
    this.angle = angle;
    this.type = "arc";
  }
  get circle() {
    return new Circle(this.c, this.radius);
  }
  get radius() {
    return Point.distance(this.c, this.start);
  }
  get end() {
    return this.start.rotate(this.angle, this.c);
  }
  get startAngle() {
    return rad(this.start, this.c);
  }
  contract(p) {
    return new this.constructor(this.c, this.at(p / 2), this.angle * (1 - p));
  }
  get minor() {
    if (this.angle <= Math.PI)
      return this;
    return new this.constructor(this.c, this.end, TWO_PI - this.angle);
  }
  get major() {
    if (this.angle >= Math.PI)
      return this;
    return new this.constructor(this.c, this.end, TWO_PI - this.angle);
  }
  get center() {
    return this.at(0.5);
  }
  // ---------------------------------------------------------------------------
  project(p) {
    const start = this.startAngle;
    const end = start + this.angle;
    let angle = rad(p, this.c);
    if (end > TWO_PI && angle < end - TWO_PI)
      angle += TWO_PI;
    angle = (0, import_fermat5.clamp)(angle, start, end);
    return this.c.shift(this.radius, 0).rotate(angle, this.c);
  }
  at(t) {
    return this.start.rotate(this.angle * t, this.c);
  }
  offset(p) {
    return new Angle(this.start, this.c, p).rad / this.angle;
  }
  contains(p) {
    return p.equals(this.project(p));
  }
  // ---------------------------------------------------------------------------
  transform(m) {
    return new this.constructor(
      this.c.transform(m),
      this.start.transform(m),
      this.angle
    );
  }
  /** Rotates this arc by a given angle (in radians), optionally around point `c`. */
  rotate(a, c = ORIGIN) {
    if ((0, import_fermat5.nearlyEquals)(a, 0))
      return this;
    return new this.constructor(
      this.c.rotate(a, c),
      this.start.rotate(a, c),
      this.angle
    );
  }
  reflect(l) {
    return new this.constructor(
      this.c.reflect(l),
      this.start.reflect(l),
      this.angle
    );
  }
  scale(sx, sy = sx) {
    return new this.constructor(
      this.c.scale(sx, sy),
      this.start.scale(sx, sy),
      this.angle
    );
  }
  shift(x, y = x) {
    return new this.constructor(
      this.c.shift(x, y),
      this.start.shift(x, y),
      this.angle
    );
  }
  translate(p) {
    return this.shift(p.x, p.y);
  }
  equals() {
    return false;
  }
  toString() {
    return `arc(${this.c},${this.start},${this.angle})`;
  }
};
var Sector = class extends Arc {
  constructor() {
    super(...arguments);
    this.type = "sector";
  }
  contains(p) {
    return Point.distance(p, this.c) <= this.radius && new Angle(this.start, this.c, p).rad <= this.angle;
  }
  toString() {
    return `sector(${this.c},${this.start},${this.angle})`;
  }
};

// src/polygon.ts
var import_core4 = require("@mathigon/core");
var import_fermat8 = require("@mathigon/fermat");

// src/boolean.ts
var import_core2 = require("@mathigon/core");
var import_fermat6 = require("@mathigon/fermat");
var PRECISION = 1e-3;
function pointAboveOrOnLine(pt, left, right) {
  const d1 = (right.x - left.x) * (pt.y - left.y);
  const d2 = (right.y - left.y) * (pt.x - left.x);
  return d1 - d2 >= -PRECISION;
}
function pointBetween(p, left, right) {
  const dpyly = p.y - left.y;
  const drxlx = right.x - left.x;
  const dpxlx = p.x - left.x;
  const dryly = right.y - left.y;
  const dot = dpxlx * drxlx + dpyly * dryly;
  if (dot < PRECISION)
    return false;
  const sqlen = drxlx * drxlx + dryly * dryly;
  return dot - sqlen <= -PRECISION;
}
function pointsCompare(p1, p2) {
  if ((0, import_fermat6.nearlyEquals)(p1.x, p2.x)) {
    return (0, import_fermat6.nearlyEquals)(p1.y, p2.y) ? 0 : p1.y < p2.y ? -1 : 1;
  }
  return p1.x < p2.x ? -1 : 1;
}
function getOffset(A) {
  if (A <= -PRECISION)
    return -2;
  if (A < PRECISION)
    return -1;
  if (A - 1 <= -PRECISION)
    return 0;
  if (A - 1 < PRECISION)
    return 1;
  return 2;
}
function linesIntersect(a0, a1, b0, b1) {
  const adx = a1.x - a0.x;
  const ady = a1.y - a0.y;
  const bdx = b1.x - b0.x;
  const bdy = b1.y - b0.y;
  const axb = adx * bdy - ady * bdx;
  if ((0, import_fermat6.nearlyEquals)(axb, 0))
    return false;
  const dx = a0.x - b0.x;
  const dy = a0.y - b0.y;
  const A = (bdx * dy - bdy * dx) / axb;
  const B = (adx * dy - ady * dx) / axb;
  const pt = new Point(a0.x + A * adx, a0.y + A * ady);
  return { alongA: getOffset(A), alongB: getOffset(B), pt };
}
var LinkedList = class {
  constructor() {
    // TODO Better types without any
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    this.root = { root: true, next: void 0 };
  }
  exists(node) {
    return node !== void 0 && node !== this.root;
  }
  get head() {
    return this.root.next;
  }
  insertBefore(node, check) {
    let last3 = this.root;
    let here = this.root.next;
    while (here) {
      if (check(here)) {
        node.prev = here.prev;
        node.next = here;
        here.prev.next = node;
        here.prev = node;
        return;
      }
      last3 = here;
      here = here.next;
    }
    last3.next = node;
    node.prev = last3;
    node.next = void 0;
  }
  findTransition(check) {
    let prev = this.root;
    let here = this.root.next;
    while (here) {
      if (check(here))
        break;
      prev = here;
      here = here.next;
    }
    return {
      before: prev === this.root ? void 0 : prev,
      after: here,
      insert: (node) => {
        node.prev = prev;
        node.next = here;
        prev.next = node;
        if (here)
          here.prev = node;
        return node;
      }
    };
  }
  static node(data) {
    const d = data;
    d.remove = () => {
      if (d.prev)
        d.prev.next = d.next;
      if (d.next)
        d.next.prev = d.prev;
      d.prev = d.next = void 0;
    };
    return d;
  }
};
function copy(start, end, seg) {
  const myFill = { above: seg.myFill.above, below: seg.myFill.below };
  return { start, end, myFill };
}
function eventCompare(p1isStart, p11, p12, p2isStart, p21, p22) {
  const comp = pointsCompare(p11, p21);
  if (comp !== 0)
    return comp;
  if (Point.equals(p12, p22))
    return 0;
  if (p1isStart !== p2isStart)
    return p1isStart ? 1 : -1;
  return pointAboveOrOnLine(p12, p2isStart ? p21 : p22, p2isStart ? p22 : p21) ? 1 : -1;
}
function eventAdd(eventRoot, ev, otherPt) {
  eventRoot.insertBefore(ev, (here) => eventCompare(!!ev.isStart, ev.pt, otherPt, !!here.isStart, here.pt, here.other.pt) < 0);
}
function addSegmentStart(eventRoot, seg, primary) {
  const evStart = LinkedList.node({ isStart: true, pt: seg.start, seg, primary });
  eventAdd(eventRoot, evStart, seg.end);
  return evStart;
}
function addSegmentEnd(eventRoot, evStart, seg, primary) {
  const evEnd = LinkedList.node({ pt: seg.end, seg, primary, other: evStart });
  evStart.other = evEnd;
  eventAdd(eventRoot, evEnd, evStart.pt);
}
function addSegment(eventRoot, seg, primary) {
  const evStart = addSegmentStart(eventRoot, seg, primary);
  addSegmentEnd(eventRoot, evStart, seg, primary);
  return evStart;
}
function eventUpdateEnd(eventRoot, ev, end) {
  ev.other.remove();
  ev.seg.end = end;
  ev.other.pt = end;
  eventAdd(eventRoot, ev.other, ev.pt);
}
function eventDivide(eventRoot, ev, pt) {
  const ns = copy(pt, ev.seg.end, ev.seg);
  eventUpdateEnd(eventRoot, ev, pt);
  return addSegment(eventRoot, ns, !!ev.primary);
}
function statusCompare(ev1, ev2) {
  const a1 = ev1.seg.start;
  const a2 = ev1.seg.end;
  const b1 = ev2.seg.start;
  const b2 = ev2.seg.end;
  if (!Point.colinear(a1, b1, b2))
    return pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;
  if (!Point.colinear(a2, b1, b2))
    return pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;
  return 1;
}
function checkIntersection(eventRoot, ev1, ev2) {
  const seg1 = ev1.seg;
  const seg2 = ev2.seg;
  const a1 = seg1.start;
  const a2 = seg1.end;
  const b1 = seg2.start;
  const b2 = seg2.end;
  const i = linesIntersect(a1, a2, b1, b2);
  if (i === false) {
    if (!Point.colinear(a1, a2, b1))
      return false;
    if (Point.equals(a1, b2) || Point.equals(a2, b1))
      return false;
    const a1isb1 = Point.equals(a1, b1);
    const a2isb2 = Point.equals(a2, b2);
    if (a1isb1 && a2isb2)
      return ev2;
    const a1Between = !a1isb1 && pointBetween(a1, b1, b2);
    const a2Between = !a2isb2 && pointBetween(a2, b1, b2);
    if (a1isb1) {
      a2Between ? eventDivide(eventRoot, ev2, a2) : eventDivide(eventRoot, ev1, b2);
      return ev2;
    } else if (a1Between) {
      if (!a2isb2) {
        a2Between ? eventDivide(eventRoot, ev2, a2) : eventDivide(eventRoot, ev1, b2);
      }
      eventDivide(eventRoot, ev2, a1);
    }
  } else {
    if (i.alongA === 0) {
      if (i.alongB === -1) {
        eventDivide(eventRoot, ev1, b1);
      } else if (i.alongB === 0) {
        eventDivide(eventRoot, ev1, i.pt);
      } else if (i.alongB === 1) {
        eventDivide(eventRoot, ev1, b2);
      }
    }
    if (i.alongB === 0) {
      if (i.alongA === -1) {
        eventDivide(eventRoot, ev2, a1);
      } else if (i.alongA === 0) {
        eventDivide(eventRoot, ev2, i.pt);
      } else if (i.alongA === 1) {
        eventDivide(eventRoot, ev2, a2);
      }
    }
  }
  return false;
}
function calculate(eventRoot, selfIntersection) {
  var _a, _b;
  const statusRoot = new LinkedList();
  const segments2 = [];
  while (eventRoot.head) {
    const ev = eventRoot.head;
    if (ev.isStart) {
      let checkBothIntersections2 = function() {
        if (above) {
          const eve2 = checkIntersection(eventRoot, ev, above);
          if (eve2)
            return eve2;
        }
        if (below)
          return checkIntersection(eventRoot, ev, below);
        return false;
      };
      var checkBothIntersections = checkBothIntersections2;
      const surrounding = statusRoot.findTransition((here) => statusCompare(ev, here.ev) > 0);
      const above = (_a = surrounding.before) == null ? void 0 : _a.ev;
      const below = (_b = surrounding.after) == null ? void 0 : _b.ev;
      const eve = checkBothIntersections2();
      if (eve) {
        if (selfIntersection) {
          const toggle = !ev.seg.myFill.below ? true : ev.seg.myFill.above !== ev.seg.myFill.below;
          if (toggle)
            eve.seg.myFill.above = !eve.seg.myFill.above;
        } else {
          eve.seg.otherFill = ev.seg.myFill;
        }
        ev.other.remove();
        ev.remove();
      }
      if (eventRoot.head !== ev)
        continue;
      if (selfIntersection) {
        const toggle = !ev.seg.myFill.below ? true : ev.seg.myFill.above !== ev.seg.myFill.below;
        ev.seg.myFill.below = !below ? false : below.seg.myFill.above;
        ev.seg.myFill.above = toggle ? !ev.seg.myFill.below : ev.seg.myFill.below;
      } else if (ev.seg.otherFill === void 0) {
        const inside = !below ? false : ev.primary === below.primary ? below.seg.otherFill.above : below.seg.myFill.above;
        ev.seg.otherFill = { above: inside, below: inside };
      }
      ev.other.status = surrounding.insert(LinkedList.node({ ev }));
    } else {
      const st = ev.status;
      if (st === void 0)
        throw new Error("[Euclid.js] Zero-length segment detected!");
      if (statusRoot.exists(st.prev) && statusRoot.exists(st.next)) {
        checkIntersection(eventRoot, st.prev.ev, st.next.ev);
      }
      st.remove();
      if (!ev.primary) {
        const s = ev.seg.myFill;
        ev.seg.myFill = ev.seg.otherFill;
        ev.seg.otherFill = s;
      }
      segments2.push(ev.seg);
    }
    eventRoot.head.remove();
  }
  return segments2;
}
function segmentChainer(segments2) {
  const chains = [];
  const regions = [];
  segments2.forEach((seg) => {
    const pt1 = seg.start;
    const pt2 = seg.end;
    if (Point.equals(pt1, pt2))
      return;
    const firstMatch = { index: 0, matchesHead: false, matchesPt1: false };
    const secondMatch = { index: 0, matchesHead: false, matchesPt1: false };
    let nextMatch = firstMatch;
    function setMatch(index, matchesHead, matchesPt1) {
      nextMatch.index = index;
      nextMatch.matchesHead = matchesHead;
      nextMatch.matchesPt1 = matchesPt1;
      const match = nextMatch === firstMatch;
      nextMatch = match ? secondMatch : void 0;
      return !match;
    }
    for (let i = 0; i < chains.length; i++) {
      const chain = chains[i];
      const head = chain[0];
      const tail = (0, import_core2.last)(chain);
      if (Point.equals(head, pt1)) {
        if (setMatch(i, true, true))
          break;
      } else if (Point.equals(head, pt2)) {
        if (setMatch(i, true, false))
          break;
      } else if (Point.equals(tail, pt1)) {
        if (setMatch(i, false, true))
          break;
      } else if (Point.equals(tail, pt2)) {
        if (setMatch(i, false, false))
          break;
      }
    }
    if (nextMatch === firstMatch) {
      chains.push([pt1, pt2]);
      return;
    }
    if (nextMatch === secondMatch) {
      const index = firstMatch.index;
      const pt = firstMatch.matchesPt1 ? pt2 : pt1;
      const addToHead = firstMatch.matchesHead;
      const chain = chains[index];
      let grow = addToHead ? chain[0] : chain[chain.length - 1];
      const grow2 = addToHead ? chain[1] : chain[chain.length - 2];
      const oppo = addToHead ? chain[chain.length - 1] : chain[0];
      const oppo2 = addToHead ? chain[chain.length - 2] : chain[1];
      if (Point.colinear(grow2, grow, pt)) {
        addToHead ? chain.shift() : chain.pop();
        grow = grow2;
      }
      if (Point.equals(oppo, pt)) {
        chains.splice(index, 1);
        if (Point.colinear(oppo2, oppo, grow)) {
          addToHead ? chain.pop() : chain.shift();
        }
        regions.push(chain);
        return;
      }
      addToHead ? chain.unshift(pt) : chain.push(pt);
      return;
    }
    function reverseChain(index) {
      chains[index].reverse();
    }
    function appendChain(index1, index2) {
      const chain1 = chains[index1];
      const chain2 = chains[index2];
      let tail = chain1[chain1.length - 1];
      const tail2 = chain1[chain1.length - 2];
      const head = chain2[0];
      const head2 = chain2[1];
      if (Point.colinear(tail2, tail, head)) {
        chain1.pop();
        tail = tail2;
      }
      if (Point.colinear(tail, head, head2)) {
        chain2.shift();
      }
      chains[index1] = chain1.concat(chain2);
      chains.splice(index2, 1);
    }
    const F = firstMatch.index;
    const S = secondMatch.index;
    const reverseF = chains[F].length < chains[S].length;
    if (firstMatch.matchesHead) {
      if (secondMatch.matchesHead) {
        if (reverseF) {
          reverseChain(F);
          appendChain(F, S);
        } else {
          reverseChain(S);
          appendChain(S, F);
        }
      } else {
        appendChain(S, F);
      }
    } else {
      if (secondMatch.matchesHead) {
        appendChain(F, S);
      } else {
        if (reverseF) {
          reverseChain(F);
          appendChain(S, F);
        } else {
          reverseChain(S);
          appendChain(F, S);
        }
      }
    }
  });
  return regions;
}
function select(segments2, selection) {
  const result = [];
  for (const seg of segments2) {
    const index = (seg.myFill.above ? 8 : 0) + (seg.myFill.below ? 4 : 0) + (seg.otherFill && seg.otherFill.above ? 2 : 0) + (seg.otherFill && seg.otherFill.below ? 1 : 0);
    if (selection[index] !== 0) {
      result.push({
        start: seg.start,
        end: seg.end,
        myFill: { above: selection[index] === 1, below: selection[index] === 2 }
      });
    }
  }
  return result;
}
function segments(poly) {
  const root = new LinkedList();
  for (const region of poly) {
    for (let i = 0; i < region.length; i++) {
      const pt1 = i ? region[i - 1] : (0, import_core2.last)(region);
      const pt2 = region[i];
      const forward = pointsCompare(pt1, pt2);
      if (forward === 0)
        continue;
      const start = forward < 0 ? pt1 : pt2;
      const end = forward < 0 ? pt2 : pt1;
      addSegment(root, { start, end, myFill: {} }, true);
    }
  }
  return calculate(root, true);
}
function operate(poly1, poly2, selection) {
  const root = new LinkedList();
  for (const s of segments(poly1))
    addSegment(root, copy(s.start, s.end, s), true);
  for (const s of segments(poly2))
    addSegment(root, copy(s.start, s.end, s), false);
  const results = select(calculate(root, false), selection);
  return segmentChainer(results);
}
var UNION = [0, 2, 1, 0, 2, 2, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0];
var INTERSECT = [0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 1, 1, 0, 2, 1, 0];
var DIFFERENCE = [0, 0, 0, 0, 2, 0, 2, 0, 1, 1, 0, 0, 0, 1, 2, 0];
var XOR = [0, 2, 1, 0, 2, 0, 0, 1, 1, 0, 0, 2, 0, 1, 2, 0];
var union = (p1, p2) => operate(p1, p2, UNION);
var intersect = (p1, p2) => operate(p1, p2, INTERSECT);
var difference = (p1, p2) => operate(p1, p2, DIFFERENCE);
var xor = (p1, p2) => operate(p1, p2, XOR);

// src/intersection.ts
var import_core3 = require("@mathigon/core");
var import_fermat7 = require("@mathigon/fermat");
function liesOnSegment(s, p) {
  if ((0, import_fermat7.nearlyEquals)(s.p1.x, s.p2.x))
    return (0, import_fermat7.isBetween)(p.y, s.p1.y, s.p2.y);
  return (0, import_fermat7.isBetween)(p.x, s.p1.x, s.p2.x);
}
function liesOnRay(r, p) {
  if ((0, import_fermat7.nearlyEquals)(r.p1.x, r.p2.x))
    return (p.y - r.p1.y) / (r.p2.y - r.p1.y) > 0;
  return (p.x - r.p1.x) / (r.p2.x - r.p1.x) > 0;
}
function liesOnArc(a, p) {
  return (0, import_fermat7.isBetween)(a.offset(p), 0, 1);
}
function lineLineIntersection(l1, l2) {
  const d1x = l1.p1.x - l1.p2.x;
  const d1y = l1.p1.y - l1.p2.y;
  const d2x = l2.p1.x - l2.p2.x;
  const d2y = l2.p1.y - l2.p2.y;
  const d = d1x * d2y - d1y * d2x;
  if ((0, import_fermat7.nearlyEquals)(d, 0))
    return [];
  const q1 = l1.p1.x * l1.p2.y - l1.p1.y * l1.p2.x;
  const q2 = l2.p1.x * l2.p2.y - l2.p1.y * l2.p2.x;
  const x = q1 * d2x - d1x * q2;
  const y = q1 * d2y - d1y * q2;
  return [new Point(x / d, y / d)];
}
function circleCircleIntersection(c1, c2) {
  const d = Point.distance(c1.c, c2.c);
  if (d > c1.r + c2.r)
    return [];
  if (d < Math.abs(c1.r - c2.r))
    return [];
  if ((0, import_fermat7.nearlyEquals)(d, 0) && (0, import_fermat7.nearlyEquals)(c1.r, c2.r))
    return [];
  if ((0, import_fermat7.nearlyEquals)(d, c1.r + c2.r))
    return [new Line(c1.c, c2.c).midpoint];
  const a = ((0, import_fermat7.square)(c1.r) - (0, import_fermat7.square)(c2.r) + (0, import_fermat7.square)(d)) / (2 * d);
  const b = Math.sqrt((0, import_fermat7.square)(c1.r) - (0, import_fermat7.square)(a));
  const px = (c2.c.x - c1.c.x) * a / d + (c2.c.y - c1.c.y) * b / d + c1.c.x;
  const py = (c2.c.y - c1.c.y) * a / d - (c2.c.x - c1.c.x) * b / d + c1.c.y;
  const qx = (c2.c.x - c1.c.x) * a / d - (c2.c.y - c1.c.y) * b / d + c1.c.x;
  const qy = (c2.c.y - c1.c.y) * a / d + (c2.c.x - c1.c.x) * b / d + c1.c.y;
  return [new Point(px, py), new Point(qx, qy)];
}
function lineCircleIntersection(l, c) {
  const dx = l.p2.x - l.p1.x;
  const dy = l.p2.y - l.p1.y;
  const dr2 = (0, import_fermat7.square)(dx) + (0, import_fermat7.square)(dy);
  const cx = c.c.x;
  const cy = c.c.y;
  const D = (l.p1.x - cx) * (l.p2.y - cy) - (l.p2.x - cx) * (l.p1.y - cy);
  const disc = (0, import_fermat7.square)(c.r) * dr2 - (0, import_fermat7.square)(D);
  if (disc < 0)
    return [];
  const xa = D * dy / dr2;
  const ya = -D * dx / dr2;
  if ((0, import_fermat7.nearlyEquals)(disc, 0))
    return [c.c.shift(xa, ya)];
  const xb = dx * (dy < 0 ? -1 : 1) * Math.sqrt(disc) / dr2;
  const yb = Math.abs(dy) * Math.sqrt(disc) / dr2;
  return [c.c.shift(xa + xb, ya + yb), c.c.shift(xa - xb, ya - yb)];
}
function simpleIntersection(a, b) {
  let results = [];
  const a1 = isArc(a) ? a.circle : a;
  const b1 = isArc(b) ? b.circle : b;
  if (isLineLike(a) && isLineLike(b)) {
    results = lineLineIntersection(a, b);
  } else if (isLineLike(a1) && isCircle(b1)) {
    results = lineCircleIntersection(a1, b1);
  } else if (isCircle(a1) && isLineLike(b1)) {
    results = lineCircleIntersection(b1, a1);
  } else if (isCircle(a1) && isCircle(b1)) {
    results = circleCircleIntersection(a1, b1);
  }
  for (const x of [a, b]) {
    if (isSegment(x))
      results = results.filter((i) => liesOnSegment(x, i));
    if (isRay(x))
      results = results.filter((i) => liesOnRay(x, i));
    if (isArc(x))
      results = results.filter((i) => liesOnArc(x, i));
  }
  return results;
}
function intersections(...elements) {
  if (elements.length < 2)
    return [];
  if (elements.length > 2) {
    return (0, import_core3.flatten)((0, import_fermat7.subsets)(elements, 2).map((e) => intersections(...e)));
  }
  let [a, b] = elements;
  if (isAngle(a))
    a = a.shape(true);
  if (isAngle(b))
    b = b.shape(true);
  if (isPolygonLike(b))
    [a, b] = [b, a];
  if (isPolygonLike(a)) {
    const results = isLineLike(b) ? a.points.filter((p) => b.contains(p)) : [];
    for (const e of a.edges)
      results.push(...intersections(e, b));
    return results;
  }
  return simpleIntersection(a, b);
}

// src/polygon.ts
var Polygon = class _Polygon {
  constructor(...points) {
    this.type = "polygon";
    this.points = points;
  }
  get circumference() {
    if (this.points.length <= 1)
      return 0;
    let length = Point.distance(this.points[0], (0, import_core4.last)(this.points));
    for (let i = 1; i < this.points.length; ++i) {
      length += Point.distance(this.points[i - 1], this.points[i]);
    }
    return length;
  }
  /**
   * The (signed) area of this polygon. The result is positive if the vertices
   * are ordered clockwise, and negative otherwise.
   */
  get signedArea() {
    const p = this.points;
    const n = p.length;
    let A = p[n - 1].x * p[0].y - p[0].x * p[n - 1].y;
    for (let i = 1; i < n; ++i) {
      A += p[i - 1].x * p[i].y - p[i].x * p[i - 1].y;
    }
    return A / 2;
  }
  get area() {
    return Math.abs(this.signedArea);
  }
  get centroid() {
    const p = this.points;
    const n = p.length;
    let Cx = 0;
    for (let i = 0; i < n; ++i)
      Cx += p[i].x;
    let Cy = 0;
    for (let i = 0; i < n; ++i)
      Cy += p[i].y;
    return new Point(Cx / n, Cy / n);
  }
  get edges() {
    const n = this.points.length;
    const edges = [];
    for (let i = 0; i < n; ++i) {
      edges.push(new Segment(this.points[i], this.points[(i + 1) % n]));
    }
    return edges;
  }
  get radius() {
    const c = this.centroid;
    const radii = this.points.map((p) => Point.distance(p, c));
    return Math.max(...radii);
  }
  /** The oriented version of this polygon (vertices in clockwise order). */
  get oriented() {
    if (this.signedArea >= 0)
      return this;
    const points = [...this.points].reverse();
    return new this.constructor(...points);
  }
  /** Cut this polygon along a line, and return multiple parts. */
  cut(line) {
    const t = this.radius / line.length * 10;
    const a = line.at(-t);
    const b = line.at(t);
    const d = line.perpendicularVector.scale(line.length * t);
    const mask = [a, b, b.add(d), a.add(d)];
    const side1 = intersect([this.points], [mask]);
    const side2 = difference([this.points], [mask]);
    return [...side1, ...side2].map((p) => new _Polygon(...p));
  }
  /** Checks if two polygons p1 and p2 collide. */
  static collision(p1, p2) {
    if (p1.points.some((q) => p2.contains(q)))
      return true;
    if (p2.points.some((q) => p1.contains(q)))
      return true;
    for (const e1 of p1.edges) {
      for (const e2 of p2.edges) {
        if (intersections(e1, e2)[0])
          return true;
      }
    }
    return false;
  }
  static union(...polygons) {
    const [first, ...other] = polygons;
    if (!other.length)
      return [first];
    const p1 = [first.points];
    const p2 = other.length > 1 ? _Polygon.union(...other).map((p) => p.points) : [polygons[1].points];
    return union(p1, p2).map((p) => new _Polygon(...p));
  }
  /** Creates a regular polygon. */
  static regular(n, radius = 1) {
    const da = TWO_PI / n;
    const a0 = Math.PI / 2 - da / 2;
    const points = (0, import_core4.tabulate)((i) => Point.fromPolar(a0 + da * i, radius), n);
    return new _Polygon(...points);
  }
  /** Interpolates the points of two polygons */
  static interpolate(p1, p2, t = 0.5) {
    const points = p1.points.map(
      (p, i) => Point.interpolate(p, p2.points[i], t)
    );
    return new _Polygon(...points);
  }
  static convexHull(...points) {
    if (points.length <= 3)
      return new _Polygon(...points);
    const sorted = points.sort((a, b) => a.x !== b.x ? a.x - b.x : a.y - b.y);
    const sortedReverse = sorted.slice(0).reverse();
    const upper = [];
    const lower = [];
    for (const [source, target] of [[sorted, upper], [sortedReverse, lower]]) {
      for (const p of source) {
        while (target.length >= 2) {
          const p1 = target[target.length - 1];
          const p2 = target[target.length - 2];
          if ((p1.x - p2.x) * (p.y - p2.y) >= (p.x - p2.x) * (p1.y - p2.y)) {
            target.pop();
          } else {
            break;
          }
        }
        target.push(p);
      }
      target.pop();
    }
    return new _Polygon(...upper.concat(lower));
  }
  // ---------------------------------------------------------------------------
  /**
   * Checks if a point p lies inside this polygon, by using a ray-casting
   * algorithm and calculating the number of intersections.
   */
  contains(p) {
    let inside = false;
    for (const e of this.edges) {
      if (e.p1.equals(p) || e.contains(p))
        return false;
      if (e.p1.y > p.y === e.p2.y > p.y)
        continue;
      const det = (e.p2.x - e.p1.x) / (e.p2.y - e.p1.y);
      if (p.x < det * (p.y - e.p1.y) + e.p1.x)
        inside = !inside;
    }
    return inside;
  }
  at(t) {
    if (t < 0)
      t += Math.floor(t);
    const offset = t * this.circumference;
    let cum = 0;
    for (const e of this.edges) {
      const l = e.length;
      if (cum + l > offset)
        return e.at((offset - cum) / l);
      cum += l;
    }
    return this.points[0];
  }
  offset(p) {
    const edges = this.edges;
    const proj = findClosest(p, this.edges) || [this.points[0], 0];
    let offset = 0;
    for (let i = 0; i < proj[1]; ++i)
      offset += edges[i].length;
    offset += edges[proj[1]].offset(p) * edges[proj[1]].length;
    return offset / this.circumference;
  }
  project(p) {
    const proj = findClosest(p, this.edges);
    return proj ? proj[0] : this.points[0];
  }
  /** Center this polygon on a given point or the origin */
  centerAt(on = ORIGIN) {
    return this.translate(on.subtract(this.centroid));
  }
  // ---------------------------------------------------------------------------
  transform(m) {
    return new this.constructor(...this.points.map((p) => p.transform(m)));
  }
  /** Rotates this polygon by a given angle (in radians), optionally around point `center`. */
  rotate(a, center = ORIGIN) {
    if ((0, import_fermat8.nearlyEquals)(a, 0))
      return this;
    const points = this.points.map((p) => p.rotate(a, center));
    return new this.constructor(...points);
  }
  reflect(line) {
    const points = this.points.map((p) => p.reflect(line));
    return new this.constructor(...points);
  }
  scale(sx, sy = sx) {
    const points = this.points.map((p) => p.scale(sx, sy));
    return new this.constructor(...points);
  }
  shift(x, y = x) {
    const points = this.points.map((p) => p.shift(x, y));
    return new this.constructor(...points);
  }
  translate(p) {
    return this.shift(p.x, p.y);
  }
  equals(other, tolerance, oriented) {
    const n = this.points.length;
    if (n !== other.points.length)
      return false;
    const p1 = oriented ? this : this.oriented;
    const p2 = oriented ? other : other.oriented;
    for (let offset = 0; offset < n; ++offset) {
      if (p1.points.every((p, i) => p.equals(p2.points[(i + offset) % n], tolerance))) {
        return true;
      }
    }
    return false;
  }
  toString() {
    return `polygon(${this.points.join(",")})`;
  }
};
var Polyline = class extends Polygon {
  constructor() {
    super(...arguments);
    this.type = "polyline";
  }
  get circumference() {
    return this.length;
  }
  get length() {
    let length = 0;
    for (let i = 1; i < this.points.length; ++i) {
      length += Point.distance(this.points[i - 1], this.points[i]);
    }
    return length;
  }
  /** @returns {Segment[]} */
  get edges() {
    const edges = [];
    for (let i = 0; i < this.points.length - 1; ++i) {
      edges.push(new Segment(this.points[i], this.points[i + 1]));
    }
    return edges;
  }
  toString() {
    return `polyline(${this.points.join(",")})`;
  }
};
var Triangle = class extends Polygon {
  constructor() {
    super(...arguments);
    this.type = "triangle";
  }
  get circumcircle() {
    const [a, b, c] = this.points;
    const d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));
    const ux = (a.x ** 2 + a.y ** 2) * (b.y - c.y) + (b.x ** 2 + b.y ** 2) * (c.y - a.y) + (c.x ** 2 + c.y ** 2) * (a.y - b.y);
    const uy = (a.x ** 2 + a.y ** 2) * (c.x - b.x) + (b.x ** 2 + b.y ** 2) * (a.x - c.x) + (c.x ** 2 + c.y ** 2) * (b.x - a.x);
    const center = new Point(ux / d, uy / d);
    const radius = Point.distance(center, this.points[0]);
    if (isNaN(radius) || radius > Number.MAX_SAFE_INTEGER)
      return;
    return new Circle(center, radius);
  }
  get incircle() {
    const edges = this.edges;
    const sides = edges.map((e) => e.length);
    const total2 = sides[0] + sides[1] + sides[2];
    const [a, b, c] = this.points;
    const ux = sides[1] * a.x + sides[2] * b.x + sides[0] * c.x;
    const uy = sides[1] * a.y + sides[2] * b.y + sides[0] * c.y;
    const center = new Point(ux / total2, uy / total2);
    const radius = center.distanceFromLine(edges[0]);
    return isNaN(radius) ? void 0 : new Circle(center, radius);
  }
  get orthocenter() {
    const [a, b, c] = this.points;
    const h1 = new Line(a, b).perpendicular(c);
    const h2 = new Line(a, c).perpendicular(b);
    return intersections(h1, h2)[0];
  }
};

// src/angle.ts
var RAD_TO_DEG = 180 / Math.PI;
var DEG_TO_RAD = Math.PI / 180;
function toDeg(n) {
  return n * RAD_TO_DEG;
}
function toRad(n) {
  return n * DEG_TO_RAD;
}
var Angle = class _Angle {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.type = "angle";
  }
  static fromDegrees(val) {
    return _Angle.fromRadians(val * (Math.PI / 180));
  }
  static fromRadians(val) {
    const p1 = new Point(1, 0);
    const p2 = p1.rotate(val);
    return new _Angle(p1, ORIGIN, p2);
  }
  /** Checks if `a` and `b` are roughly equivalent (by default, within one degree of eachother) */
  static equals(a, b, precision = Math.PI / 360) {
    return (0, import_fermat9.nearlyEquals)(a.rad, b.rad, precision);
  }
  /** The size, in radians, of this angle. */
  get rad() {
    const phiA = Math.atan2(this.a.y - this.b.y, this.a.x - this.b.x);
    const phiC = Math.atan2(this.c.y - this.b.y, this.c.x - this.b.x);
    let phi = phiC - phiA;
    if (phi < 0)
      phi += TWO_PI;
    return phi;
  }
  /** The size, in degrees, of this angle. */
  get deg() {
    return this.rad * 180 / Math.PI;
  }
  /** Checks if this angle is right-angled. */
  get isRight() {
    return (0, import_fermat9.nearlyEquals)(this.rad, Math.PI / 2, Math.PI / 360);
  }
  /** The bisector of this angle. */
  get bisector() {
    if (this.b.equals(this.a))
      return void 0;
    if (this.b.equals(this.c))
      return void 0;
    const phiA = Math.atan2(this.a.y - this.b.y, this.a.x - this.b.x);
    const phiC = Math.atan2(this.c.y - this.b.y, this.c.x - this.b.x);
    let phi = (phiA + phiC) / 2;
    if (phiA > phiC)
      phi += Math.PI;
    const x = Math.cos(phi) + this.b.x;
    const y = Math.sin(phi) + this.b.y;
    return new Line(this.b, new Point(x, y));
  }
  /** Returns the smaller one of this and its supplementary angle. */
  get sup() {
    return this.rad < Math.PI ? this : new _Angle(this.c, this.b, this.a);
  }
  /** Returns the Arc element corresponding to this angle. */
  get arc() {
    return new Arc(this.b, this.a, this.rad);
  }
  // ---------------------------------------------------------------------------
  /** Radius of the arc or sector representing this angle. */
  get radius() {
    return 24 + 20 * (1 - (0, import_fermat9.clamp)(this.rad, 0, Math.PI) / Math.PI);
  }
  /** Shape object that can be used to draw this angle. */
  shape(filled = true, radius, round) {
    if (this.a.equals(this.b) || this.c.equals(this.b))
      return new Polygon(ORIGIN);
    const angled = this.isRight && !round;
    if (!radius)
      radius = angled ? 20 : this.radius;
    const ba = new Segment(this.b, this.a);
    const a = ba.at(radius / ba.length);
    if (angled) {
      const bc = Point.difference(this.c, this.b).unitVector.scale(radius);
      if (filled)
        return new Polygon(this.b, a, a.add(bc), this.b.add(bc));
      return new Polyline(a, a.add(bc), this.b.add(bc));
    }
    if (filled)
      return new Sector(this.b, a, this.rad);
    return new Arc(this.b, a, this.rad);
  }
  // ---------------------------------------------------------------------------
  // These functions are just included for compatibility with GeoPath
  project(p) {
    return this.contains(p) ? p : this.shape(true).project(p);
  }
  at() {
    return this.c;
  }
  offset() {
    return 0;
  }
  contains(p) {
    return this.shape(true).contains(p);
  }
  // ---------------------------------------------------------------------------
  transform(m) {
    return new _Angle(this.a.transform(m), this.b.transform(m), this.c.transform(m));
  }
  rotate(a, c) {
    if ((0, import_fermat9.nearlyEquals)(a, 0))
      return this;
    return new _Angle(this.a.rotate(a, c), this.b.rotate(a, c), this.c.rotate(a, c));
  }
  reflect(l) {
    return new _Angle(this.a.reflect(l), this.b.reflect(l), this.c.reflect(l));
  }
  scale(sx, sy = sx) {
    return new _Angle(this.a.scale(sx, sy), this.b.scale(sx, sy), this.c.scale(sx, sy));
  }
  shift(x, y = x) {
    return new _Angle(this.a.shift(x, y), this.b.shift(x, y), this.c.shift(x, y));
  }
  translate(p) {
    return new _Angle(this.a.translate(p), this.b.translate(p), this.c.translate(p));
  }
  equals(a, precision) {
    return _Angle.equals(a, this, precision);
  }
  toString() {
    return `angle(${this.a},${this.b},${this.c})`;
  }
};

// src/bounds.ts
var import_fermat11 = require("@mathigon/fermat");

// src/rectangle.ts
var import_fermat10 = require("@mathigon/fermat");
var Rectangle = class _Rectangle {
  constructor(p, w = 1, h = w) {
    this.p = p;
    this.w = w;
    this.h = h;
    this.type = "rectangle";
  }
  /** Creates the smallest rectangle containing all given points. */
  static aroundPoints(points) {
    let xMin = Infinity;
    let xMax = -Infinity;
    let yMin = Infinity;
    let yMax = -Infinity;
    for (const p of points) {
      xMin = xMin < p.x ? xMin : p.x;
      xMax = xMax > p.x ? xMax : p.x;
      yMin = yMin < p.y ? yMin : p.y;
      yMax = yMax > p.y ? yMax : p.y;
    }
    return new _Rectangle(new Point(xMin, yMin), xMax - xMin, yMax - yMin);
  }
  get center() {
    return new Point(this.p.x + this.w / 2, this.p.y + this.h / 2);
  }
  get centroid() {
    return this.center;
  }
  get circumference() {
    return 2 * Math.abs(this.w) + 2 * Math.abs(this.h);
  }
  get area() {
    return Math.abs(this.signedArea);
  }
  get signedArea() {
    return this.w * this.h;
  }
  /** @returns {Segment[]} */
  get edges() {
    return this.polygon.edges;
  }
  /** @returns {Point[]} */
  get points() {
    return this.polygon.points;
  }
  /** A polygon class representing this rectangle. */
  get polygon() {
    const b = new Point(this.p.x + this.w, this.p.y);
    const c = new Point(this.p.x + this.w, this.p.y + this.h);
    const d = new Point(this.p.x, this.p.y + this.h);
    return new Polygon(this.p, b, c, d);
  }
  get bounds() {
    return new Bounds(this.p.x, this.p.x + this.w, this.p.y, this.p.y + this.h);
  }
  collision(r) {
    return this.p.x < r.p.x + r.w && this.p.x + this.w > r.p.x && this.p.y < r.p.y + r.h && this.p.y + this.h > r.p.y;
  }
  padding(top, right, bottom, left) {
    return new _Rectangle(this.p.shift(-left, -top), this.w + left + right, this.h + top + bottom);
  }
  get unsigned() {
    if (this.w > 0 && this.h > 0)
      return this;
    const p = this.p.shift(this.w < 0 ? this.w : 0, this.h < 0 ? this.h : 0);
    return new _Rectangle(p, Math.abs(this.w), Math.abs(this.h));
  }
  // ---------------------------------------------------------------------------
  contains(p, tolerance) {
    return (0, import_fermat10.isBetween)(p.x, this.p.x, this.p.x + this.w, tolerance) && (0, import_fermat10.isBetween)(p.y, this.p.y, this.p.y + this.h, tolerance);
  }
  project(p) {
    let q = void 0;
    for (const e of this.edges) {
      const q1 = e.project(p);
      if (!q || Point.distance(p, q1) < Point.distance(p, q))
        q = q1;
    }
    return q;
  }
  at(t) {
    return this.polygon.at(t);
  }
  offset(p) {
    return this.polygon.offset(p);
  }
  cut(line) {
    return this.polygon.cut(line);
  }
  get oriented() {
    return this.polygon.oriented;
  }
  // ---------------------------------------------------------------------------
  transform(m) {
    return this.polygon.transform(m);
  }
  /** Rotates this rectangle by a given angle (in radians), optionally around point `c`. */
  rotate(a, c = ORIGIN) {
    if ((0, import_fermat10.nearlyEquals)(a, 0))
      return this;
    return this.polygon.rotate(a, c);
  }
  reflect(l) {
    return this.polygon.reflect(l);
  }
  scale(sx, sy = sx) {
    return new _Rectangle(this.p.scale(sx, sy), this.w * sx, this.h * sy);
  }
  shift(x, y = x) {
    return new _Rectangle(this.p.shift(x, y), this.w, this.h);
  }
  translate(p) {
    return this.shift(p.x, p.y);
  }
  equals(_other) {
    return false;
  }
  toString() {
    return `rectangle(${this.p},${this.w},${this.h})`;
  }
};

// src/bounds.ts
var Bounds = class _Bounds {
  /**
   * Use the `errorHandling` option to decide how to deal with cases where the
   * min and max values are in the wrong order.
   */
  constructor(xMin, xMax, yMin, yMax, errorHandling) {
    this.xMin = xMin;
    this.xMax = xMax;
    this.yMin = yMin;
    this.yMax = yMax;
    if (errorHandling === "swap") {
      if (this.dx < 0)
        [this.xMin, this.xMax] = [xMax, xMin];
      if (this.dy < 0)
        [this.yMin, this.yMax] = [yMax, yMin];
    } else if (errorHandling === "center") {
      if (this.dx < 0)
        this.xMin = this.xMax = (xMin + xMax) / 2;
      if (this.dy < 0)
        this.yMin = this.yMax = (yMin + yMax) / 2;
    }
  }
  contains(p) {
    return this.containsX(p) && this.containsY(p);
  }
  containsX(p) {
    return (0, import_fermat11.isBetween)(p.x, this.xMin, this.xMax);
  }
  containsY(p) {
    return (0, import_fermat11.isBetween)(p.y, this.yMin, this.yMax);
  }
  resize(dx, dy) {
    return new _Bounds(this.xMin, this.xMax + dx, this.yMin, this.yMax + dy);
  }
  get dx() {
    return this.xMax - this.xMin;
  }
  get dy() {
    return this.yMax - this.yMin;
  }
  get xRange() {
    return [this.xMin, this.xMax];
  }
  get yRange() {
    return [this.yMin, this.yMax];
  }
  extend(top, right = top, bottom = top, left = right) {
    return new _Bounds(this.xMin - left, this.xMax + right, this.yMin - top, this.yMax + bottom);
  }
  get rect() {
    return new Rectangle(new Point(this.xMin, this.yMin), this.dx, this.dy);
  }
  get center() {
    return new Point(this.xMin + this.dx / 2, this.yMin + this.dy / 2);
  }
  get flip() {
    return new _Bounds(this.yMin, this.yMax, this.xMin, this.xMax);
  }
};

// src/draw-canvas.ts
function drawCanvas(ctx, obj, options = {}) {
  if (isAngle(obj))
    return drawCanvas(ctx, obj.shape(!!options.fill), options);
  if (options.fill)
    ctx.fillStyle = options.fill;
  if (options.opacity)
    ctx.globalAlpha = options.opacity;
  if (options.stroke) {
    ctx.strokeStyle = options.stroke;
    ctx.lineWidth = options.strokeWidth || 1;
    if (options.lineCap)
      ctx.lineCap = options.lineCap;
    if (options.lineJoin)
      ctx.lineJoin = options.lineJoin;
  }
  ctx.beginPath();
  if (isSegment(obj)) {
    ctx.moveTo(obj.p1.x, obj.p1.y);
    ctx.lineTo(obj.p2.x, obj.p2.y);
  } else if (isLineLike(obj)) {
    if (!options.box)
      return;
    let [start, end] = intersections(obj, options.box);
    if (isRay(obj))
      end = obj.p1;
    if (!start || !end)
      return;
    ctx.moveTo(start.x, start.y);
    ctx.lineTo(end.x, end.y);
  } else if (isCircle(obj)) {
    ctx.arc(obj.c.x, obj.c.y, obj.r, 0, TWO_PI);
  } else if (isPolygonLike(obj)) {
    const points = obj.points;
    ctx.moveTo(points[0].x, points[0].y);
    for (const p of points.slice(1))
      ctx.lineTo(p.x, p.y);
    ctx.closePath();
  } else if (isPolyline(obj)) {
    ctx.moveTo(obj.points[0].x, obj.points[0].y);
    for (const p of obj.points.slice(1))
      ctx.lineTo(p.x, p.y);
  } else if (isEllipse(obj)) {
    ctx.ellipse(obj.c.x, obj.c.y, obj.a, obj.b, obj.angle, 0, TWO_PI);
  }
  if (options.fill)
    ctx.fill();
  if (options.stroke)
    ctx.stroke();
}

// src/draw-svg.ts
var import_core5 = require("@mathigon/core");
function drawArc(a, b, c) {
  const orient = b.x * (c.y - a.y) + a.x * (b.y - c.y) + c.x * (a.y - b.y);
  const sweep = orient > 0 ? 1 : 0;
  const size = Point.distance(b, a);
  return [a.x, `${a.y}A${size}`, size, 0, sweep, 1, c.x, c.y].join(",");
}
function drawPath(...points) {
  return `M${points.map((p) => `${p.x},${p.y}`).join("L")}`;
}
function drawLineMark(x, type) {
  const p = x.perpendicularVector.scale(6);
  const n = x.unitVector.scale(3);
  const m = x.midpoint;
  switch (type) {
    case "bar":
      return drawPath(m.add(p), m.add(p.inverse));
    case "bar2":
      return drawPath(m.add(n).add(p), m.add(n).add(p.inverse)) + drawPath(m.add(n.inverse).add(p), m.add(n.inverse).add(p.inverse));
    case "arrow":
      return drawPath(
        m.add(n.inverse).add(p),
        m.add(n),
        m.add(n.inverse).add(p.inverse)
      );
    case "arrow2":
      return drawPath(
        m.add(n.scale(-2)).add(p),
        m,
        m.add(n.scale(-2)).add(p.inverse)
      ) + drawPath(m.add(p), m.add(n.scale(2)), m.add(p.inverse));
    default:
      return "";
  }
}
function arrowPath(start, normal) {
  if (!start || !normal)
    return "";
  const perp = normal.perpendicular;
  const a = start.add(normal.scale(9)).add(perp.scale(9));
  const b = start.add(normal.scale(9)).add(perp.scale(-9));
  return drawPath(a, start, b);
}
function drawLineArrows(x, type) {
  let path = "";
  if ((0, import_core5.isOneOf)(type, "start", "both")) {
    path += arrowPath(x.p1, x.unitVector);
  }
  if ((0, import_core5.isOneOf)(type, "end", "both")) {
    path += arrowPath(x.p2, x.unitVector.inverse);
  }
  return path;
}
function drawArcArrows(x, type) {
  let path = "";
  if ((0, import_core5.isOneOf)(type, "start", "both")) {
    const normal = new Line(x.c, x.start).perpendicularVector.inverse;
    path += arrowPath(x.start, normal);
  }
  if ((0, import_core5.isOneOf)(type, "end", "both")) {
    const normal = new Line(x.c, x.end).perpendicularVector;
    path += arrowPath(x.end, normal);
  }
  return path;
}
function drawRoundedRect(rect, tl, tr = tl, br = tl, bl = tr) {
  const { p, w, h } = rect;
  return `M${p.x} ${p.y + tl}a${tl} ${tl} 0 0 1 ${tl} ${-tl}h${w - tl - tr}a${tr} ${tr} 0 0 1 ${tr} ${tr}v${h - tr - br}a${br} ${br} 0 0 1 ${-br} ${br}h${-w + bl + br}a${bl} ${bl} 0 0 1 ${-bl} ${-bl}Z`;
}
function drawSVG(obj, options = {}) {
  if (isAngle(obj)) {
    const shape = obj.shape(!!options.fill, options.size, options.round);
    return drawSVG(shape, options);
  }
  if (isSegment(obj)) {
    if (obj.p1.equals(obj.p2))
      return "";
    let line = drawPath(obj.p1, obj.p2);
    if (options.mark)
      line += drawLineMark(obj, options.mark);
    if (options.arrows)
      line += drawLineArrows(obj, options.arrows);
    return line;
  }
  if (isRay(obj)) {
    if (!options.box)
      return "";
    const end = intersections(obj, options.box)[0];
    if (!end)
      return "";
    let line = drawPath(obj.p1, end);
    if (options.mark)
      line += drawLineMark(obj, options.mark);
    return line;
  }
  if (isLine(obj)) {
    if (!options.box)
      return "";
    const points = intersections(obj, options.box);
    if (points.length < 2)
      return "";
    let line = drawPath(points[0], points[1]);
    if (options.mark)
      line += drawLineMark(obj, options.mark);
    return line;
  }
  if (isCircle(obj)) {
    return `M${obj.c.x - obj.r} ${obj.c.y}a${obj.r},${obj.r} 0 1 0 ${2 * obj.r} 0a${obj.r} ${obj.r} 0 1 0 ${-2 * obj.r} 0Z`;
  }
  if (isEllipse(obj)) {
    const [u, v] = obj.majorVertices;
    const rot = toDeg(obj.angle);
    return `M${u.x} ${u.y}A${obj.a} ${obj.b} ${rot} 0 0 ${v.x} ${v.y}A${obj.a} ${obj.b} ${rot} 0 0 ${u.x} ${u.y}Z`;
  }
  if (isArc(obj)) {
    let path = `M${drawArc(obj.start, obj.c, obj.end)}`;
    if (options.arrows)
      path += drawArcArrows(obj, options.arrows);
    return path;
  }
  if (isSector(obj)) {
    return `M${obj.c.x} ${obj.c.y} L ${drawArc(obj.start, obj.c, obj.end)}Z`;
  }
  if (isPolyline(obj)) {
    return drawPath(...obj.points);
  }
  if (isPolygon(obj)) {
    return `${drawPath(...obj.points)}Z`;
  }
  if (isRectangle(obj)) {
    if (!options.cornerRadius)
      return `${drawPath(...obj.polygon.points)}Z`;
    const rect = obj.unsigned;
    const radius = Math.min(options.cornerRadius, rect.w / 2, rect.h / 2);
    return drawRoundedRect(rect, radius);
  }
  return "";
}

// src/ellipse.ts
var import_fermat12 = require("@mathigon/fermat");
var Ellipse = class _Ellipse {
  /**
   * @param c Center of the ellipse
   * @param a Major axis
   * @param b Minor axis
   * @param angle The rotation of the major axis of the ellipse.
   */
  constructor(c, a, b, angle = 0) {
    this.c = c;
    this.type = "ellipse";
    if (a < b) {
      [a, b] = [b, a];
      angle += Math.PI / 2;
    }
    this.a = a;
    this.b = b;
    this.angle = angle;
    const f = Math.sqrt(a ** 2 - b ** 2);
    this.f1 = this.c.add(new Point(-f, 0).rotate(angle));
    this.f2 = this.c.add(new Point(f, 0).rotate(angle));
  }
  get rx() {
    return (0, import_fermat12.nearlyEquals)(this.angle, 0) ? this.a : (0, import_fermat12.nearlyEquals)(this.angle, Math.PI / 2) ? this.b : void 0;
  }
  get ry() {
    return (0, import_fermat12.nearlyEquals)(this.angle, 0) ? this.b : (0, import_fermat12.nearlyEquals)(this.angle, Math.PI / 2) ? this.a : void 0;
  }
  normalAt(p) {
    return new Angle(this.f1, p, this.f2).bisector;
  }
  /** Intersection between an ellipse and a line. */
  intersect(line) {
    line = line.rotate(-this.angle, this.c);
    const dx = line.p1.x - line.p2.x;
    const dy = line.p1.y - line.p2.y;
    const px = this.c.x - line.p1.x;
    const py = this.c.y - line.p1.y;
    const A = (dx / this.a) ** 2 + (dy / this.b) ** 2;
    const B = 2 * px * dx / this.a ** 2 + 2 * py * dy / this.b ** 2;
    const C = (px / this.a) ** 2 + (py / this.b) ** 2 - 1;
    const points = (0, import_fermat12.quadratic)(A, B, C);
    return points.map((t) => line.at(t).rotate(this.angle, this.c));
  }
  /**
   * Creates a new Ellipse. StringLength is the length of string from one foci
   * to a point on the circumference, to the other foci.
   */
  static fromFoci(f1, f2, stringLength) {
    const c = Point.distance(f1, f2) / 2;
    const a = stringLength / 2;
    const b = Math.sqrt(a ** 2 - c ** 2);
    const angle = new Line(f1, f2).angle;
    return new _Ellipse(Point.interpolate(f1, f2), a, b, angle);
  }
  // ---------------------------------------------------------------------------
  get majorVertices() {
    return [
      this.c.add(new Point(-this.a, 0).rotate(this.angle)),
      this.c.add(new Point(this.a, 0).rotate(this.angle))
    ];
  }
  get minorVertices() {
    return [
      this.c.add(new Point(0, -this.b).rotate(this.angle)),
      this.c.add(new Point(0, this.b).rotate(this.angle))
    ];
  }
  get extremes() {
    const { a, b, angle } = this;
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const sqSum = a ** 2 + b ** 2;
    const sqDiff = (a ** 2 - b ** 2) * Math.cos(2 * angle);
    const yMax = Math.sqrt((sqSum - sqDiff) / 2);
    const xAtYMax = yMax * sqSum * sin * cos / (a ** 2 * sin ** 2 + b ** 2 * cos ** 2);
    const xMax = Math.sqrt((sqSum + sqDiff) / 2);
    const yAtXMax = xMax * sqSum * sin * cos / (a ** 2 * cos ** 2 + b ** 2 * sin ** 2);
    return [
      new Point(xAtYMax, yMax).add(this.c),
      new Point(xAtYMax, yMax).inverse.add(this.c),
      new Point(xMax, yAtXMax).add(this.c),
      new Point(xMax, yAtXMax).inverse.add(this.c)
    ];
  }
  project(p) {
    p = p.rotate(-this.angle, this.c);
    const th = p.angle(this.c);
    return this.at(th / TWO_PI);
  }
  at(t) {
    const th = TWO_PI * t;
    return this.c.shift(this.a * Math.cos(th), this.b * Math.sin(th)).rotate(this.angle, this.c);
  }
  offset(_p) {
    return 0.5;
  }
  contains(p) {
    const cos = Math.cos(this.angle);
    const sin = Math.sin(this.angle);
    const A = cos ** 2 / this.a ** 2 + sin ** 2 / this.b ** 2;
    const B = 2 * cos * sin * (1 / this.a ** 2 - 1 / this.b ** 2);
    const C = sin ** 2 / this.a ** 2 + cos ** 2 / this.b ** 2;
    return A * p.x ** 2 + B * p.x * p.y + C * p.y ** 2 <= 1;
  }
  // ---------------------------------------------------------------------------
  transform(_m) {
    return this;
  }
  rotate(a, c = ORIGIN) {
    const l = new Line(this.f1, this.f2).rotate(a, c);
    return _Ellipse.fromFoci(l.p1, l.p2, this.a * 2);
  }
  reflect(l) {
    const axis = new Line(this.f1, this.f2).reflect(l);
    return _Ellipse.fromFoci(axis.p1, axis.p2, this.a * 2);
  }
  scale(sx, sy = sx) {
    return new _Ellipse(this.c.scale(sx, sy), this.a * sx, this.b * sy, this.angle);
  }
  shift(x, y = x) {
    return new _Ellipse(this.c.shift(x, y), this.a, this.b, this.angle);
  }
  translate(p) {
    return new _Ellipse(this.c.translate(p), this.a, this.b, this.angle);
  }
  equals(other, tolerance) {
    return (0, import_fermat12.nearlyEquals)(this.a, other.a, tolerance) && (0, import_fermat12.nearlyEquals)(this.b, other.b, tolerance) && (0, import_fermat12.nearlyEquals)(this.angle, other.angle, tolerance) && this.c.equals(other.c, tolerance);
  }
  toString() {
    return `ellipse(${this.c},${this.a},${this.b},${this.angle})`;
  }
};
//# sourceMappingURL=index.cjs.js.map
