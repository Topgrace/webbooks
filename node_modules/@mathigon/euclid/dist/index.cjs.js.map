{
  "version": 3,
  "sources": ["../src/index.ts", "../src/angle.ts", "../src/arc.ts", "../src/circle.ts", "../src/line.ts", "../src/point.ts", "../src/utilities.ts", "../src/types.ts", "../src/polygon.ts", "../src/boolean.ts", "../src/intersection.ts", "../src/bounds.ts", "../src/rectangle.ts", "../src/draw-canvas.ts", "../src/draw-svg.ts", "../src/ellipse.ts"],
  "sourcesContent": ["// =============================================================================\n// Euclid.ts Index\n// (c) Mathigon\n// =============================================================================\n\n\nexport * from './angle';\nexport * from './arc';\nexport * from './bounds';\nexport * from './circle';\nexport * from './draw-canvas';\nexport * from './draw-svg';\nexport * from './ellipse';\nexport * from './intersection';\nexport * from './line';\nexport * from './point';\nexport * from './polygon';\nexport * from './rectangle';\nexport * from './types';\nexport * from './boolean';\nexport {GeoElement, GeoShape, rad, SimplePoint, TransformMatrix, TWO_PI} from './utilities';\n", "// =============================================================================\n// Euclid.js | Angle Class\n// (c) Mathigon\n// =============================================================================\n\n\nimport {clamp, nearlyEquals} from '@mathigon/fermat';\nimport {Arc, Sector} from './arc';\nimport {Line, Segment} from './line';\nimport {ORIGIN, Point} from './point';\nimport {Polygon, Polyline} from './polygon';\nimport {GeoShape, SimplePoint, TransformMatrix, TWO_PI} from './utilities';\n\n\nconst RAD_TO_DEG = 180 / Math.PI;\nconst DEG_TO_RAD = Math.PI / 180;\n\n/** Convert angles in radians to degrees. */\nexport function toDeg(n: number) {\n  return n * RAD_TO_DEG;\n}\n\n/** Convert angles in degrees to radians. */\nexport function toRad(n: number) {\n  return n * DEG_TO_RAD;\n}\n\n\n/** A 2-dimensional angle class, defined by three points. */\nexport class Angle implements GeoShape {\n  readonly type = 'angle';\n\n  constructor(readonly a: Point, readonly b: Point, readonly c: Point) {}\n\n  static fromDegrees(val: number) {\n    return Angle.fromRadians(val * (Math.PI / 180));\n  }\n\n  static fromRadians(val: number): Angle {\n    const p1 = new Point(1, 0);\n    const p2 = p1.rotate(val);\n    return new Angle(p1, ORIGIN, p2);\n  }\n\n  /** Checks if `a` and `b` are roughly equivalent (by default, within one degree of eachother) */\n  static equals(a: Angle, b: Angle, precision = Math.PI / 360) {\n    return nearlyEquals(a.rad, b.rad, precision);\n  }\n\n  /** The size, in radians, of this angle. */\n  get rad() {\n    const phiA = Math.atan2(this.a.y - this.b.y, this.a.x - this.b.x);\n    const phiC = Math.atan2(this.c.y - this.b.y, this.c.x - this.b.x);\n    let phi = phiC - phiA;\n\n    if (phi < 0) phi += TWO_PI;\n    return phi;\n  }\n\n  /** The size, in degrees, of this angle. */\n  get deg() {\n    return this.rad * 180 / Math.PI;\n  }\n\n  /** Checks if this angle is right-angled. */\n  get isRight() {\n    // Within 1 deg of 90 deg.\n    return nearlyEquals(this.rad, Math.PI / 2, Math.PI / 360);\n  }\n\n  /** The bisector of this angle. */\n  get bisector() {\n    if (this.b.equals(this.a)) return undefined;\n    if (this.b.equals(this.c)) return undefined;\n\n    const phiA = Math.atan2(this.a.y - this.b.y, this.a.x - this.b.x);\n    const phiC = Math.atan2(this.c.y - this.b.y, this.c.x - this.b.x);\n    let phi = (phiA + phiC) / 2;\n\n    if (phiA > phiC) phi += Math.PI;\n\n    const x = Math.cos(phi) + this.b.x;\n    const y = Math.sin(phi) + this.b.y;\n\n    return new Line(this.b, new Point(x, y));\n  }\n\n  /** Returns the smaller one of this and its supplementary angle. */\n  get sup() {\n    return (this.rad < Math.PI) ? this : new Angle(this.c, this.b, this.a);\n  }\n\n  /** Returns the Arc element corresponding to this angle. */\n  get arc() {\n    return new Arc(this.b, this.a, this.rad);\n  }\n\n  // ---------------------------------------------------------------------------\n\n  /** Radius of the arc or sector representing this angle. */\n  get radius() {\n    return 24 + 20 * (1 - clamp(this.rad, 0, Math.PI) / Math.PI);\n  }\n\n  /** Shape object that can be used to draw this angle. */\n  shape(filled = true, radius?: number, round?: boolean) {\n    if (this.a.equals(this.b) || this.c.equals(this.b)) return new Polygon(ORIGIN);\n\n    const angled = this.isRight && !round;\n    if (!radius) radius = angled ? 20 : this.radius;\n\n    const ba = new Segment(this.b, this.a);\n    const a = ba.at(radius / ba.length);\n\n    if (angled) {\n      const bc = Point.difference(this.c, this.b).unitVector.scale(radius);\n      if (filled) return new Polygon(this.b, a, a.add(bc), this.b.add(bc));\n      return new Polyline(a, a.add(bc), this.b.add(bc));\n    }\n\n    if (filled) return new Sector(this.b, a, this.rad);\n    return new Arc(this.b, a, this.rad);\n  }\n\n\n  // ---------------------------------------------------------------------------\n  // These functions are just included for compatibility with GeoPath\n\n  project(p: Point) {\n    return this.contains(p) ? p : this.shape(true).project(p);\n  }\n\n  at() {\n    return this.c;\n  }\n\n  offset() {\n    return 0;\n  }\n\n  contains(p: Point) {\n    return this.shape(true).contains(p);\n  }\n\n  // ---------------------------------------------------------------------------\n\n  transform(m: TransformMatrix) {\n    return new Angle(this.a.transform(m), this.b.transform(m), this.c.transform(m));\n  }\n\n  rotate(a: number, c?: SimplePoint) {\n    if (nearlyEquals(a, 0)) return this;\n    return new Angle(this.a.rotate(a, c), this.b.rotate(a, c), this.c.rotate(a, c));\n  }\n\n  reflect(l: Line) {\n    return new Angle(this.a.reflect(l), this.b.reflect(l), this.c.reflect(l));\n  }\n\n  scale(sx: number, sy = sx) {\n    return new Angle(this.a.scale(sx, sy), this.b.scale(sx, sy), this.c.scale(sx, sy));\n  }\n\n  shift(x: number, y = x) {\n    return new Angle(this.a.shift(x, y), this.b.shift(x, y), this.c.shift(x, y));\n  }\n\n  translate(p: SimplePoint) {\n    return new Angle(this.a.translate(p), this.b.translate(p), this.c.translate(p));\n  }\n\n  equals(a: Angle, precision?: number) {\n    return Angle.equals(a, this, precision);\n  }\n\n  toString() {\n    return `angle(${this.a},${this.b},${this.c})`;\n  }\n}\n", "// =============================================================================\n// Euclid.js | Arc and Sector Classes\n// (c) Mathigon\n// =============================================================================\n\n\nimport {clamp, nearlyEquals} from '@mathigon/fermat';\nimport {Angle} from './angle';\nimport {Circle} from './circle';\nimport {Line} from './line';\nimport {ORIGIN, Point} from './point';\nimport {GeoShape, rad, SimplePoint, TransformMatrix, TWO_PI} from './utilities';\n\n\n/** An arc segment of a circle, with given center, start point and angle. */\nexport class Arc implements GeoShape {\n  readonly type: string = 'arc';\n  readonly ['constructor']!: new (c: Point, start: Point, angle: number) => this;\n\n  constructor(readonly c: Point, readonly start: Point, readonly angle: number) {\n  }\n\n  get circle() {\n    return new Circle(this.c, this.radius);\n  }\n\n  get radius() {\n    return Point.distance(this.c, this.start);\n  }\n\n  get end() {\n    return this.start.rotate(this.angle, this.c);\n  }\n\n  get startAngle() {\n    return rad(this.start, this.c);\n  }\n\n  contract(p: number): this {\n    return new this.constructor(this.c, this.at(p / 2), this.angle * (1 - p));\n  }\n\n  get minor(): this {\n    if (this.angle <= Math.PI) return this;\n    return new this.constructor(this.c, this.end, TWO_PI - this.angle);\n  }\n\n  get major(): this {\n    if (this.angle >= Math.PI) return this;\n    return new this.constructor(this.c, this.end, TWO_PI - this.angle);\n  }\n\n  get center() {\n    return this.at(0.5);\n  }\n\n  // ---------------------------------------------------------------------------\n\n  project(p: Point) {\n    const start = this.startAngle;\n    const end = start + this.angle;\n\n    let angle = rad(p, this.c);\n    if (end > TWO_PI && angle < end - TWO_PI) angle += TWO_PI;\n    angle = clamp(angle, start, end);\n\n    return this.c.shift(this.radius, 0).rotate(angle, this.c);\n  }\n\n  at(t: number) {\n    return this.start.rotate(this.angle * t, this.c);\n  }\n\n  offset(p: Point) {\n    return new Angle(this.start, this.c, p).rad / this.angle;\n  }\n\n  contains(p: Point) {\n    // TODO Is there a better way to do this?\n    return p.equals(this.project(p));\n  }\n\n  // ---------------------------------------------------------------------------\n\n  transform(m: TransformMatrix): this {\n    return new this.constructor(this.c.transform(m),\n      this.start.transform(m), this.angle);\n  }\n\n  /** Rotates this arc by a given angle (in radians), optionally around point `c`. */\n  rotate(a: number, c = ORIGIN): this {\n    if (nearlyEquals(a, 0)) return this;\n    return new this.constructor(this.c.rotate(a, c),\n      this.start.rotate(a, c), this.angle);\n  }\n\n  reflect(l: Line): this {\n    return new this.constructor(this.c.reflect(l),\n      this.start.reflect(l), this.angle);\n  }\n\n  scale(sx: number, sy = sx): this {\n    return new this.constructor(this.c.scale(sx, sy),\n      this.start.scale(sx, sy), this.angle);\n  }\n\n  shift(x: number, y = x): this {\n    return new this.constructor(this.c.shift(x, y),\n      this.start.shift(x, y), this.angle);\n  }\n\n  translate(p: SimplePoint) {\n    return this.shift(p.x, p.y);\n  }\n\n  equals() {\n    // TODO Implement\n    return false;\n  }\n\n  toString() {\n    return `arc(${this.c},${this.start},${this.angle})`;\n  }\n}\n\nexport class Sector extends Arc {\n  readonly type = 'sector';\n\n  contains(p: Point) {\n    return Point.distance(p, this.c) <= this.radius && new Angle(this.start, this.c, p).rad <= this.angle;\n  }\n\n  toString() {\n    return `sector(${this.c},${this.start},${this.angle})`;\n  }\n}\n", "// =============================================================================\n// Euclid.js | Circle Class\n// (c) Mathigon\n// =============================================================================\n\n\nimport {nearlyEquals} from '@mathigon/fermat';\nimport {Arc} from './arc';\nimport {Line} from './line';\nimport {ORIGIN, Point} from './point';\nimport {Rectangle} from './rectangle';\nimport {GeoShape, rad, SimplePoint, TransformMatrix, TWO_PI} from './utilities';\n\n\n/** A circle with a given center and radius. */\nexport class Circle implements GeoShape {\n  readonly type = 'circle';\n\n  constructor(readonly c = ORIGIN, readonly r = 1) {}\n\n  /** The length of the circumference of this circle. */\n  get circumference() {\n    return TWO_PI * this.r;\n  }\n\n  /** The area of this circle. */\n  get area() {\n    return Math.PI * this.r ** 2;\n  }\n\n  get arc() {\n    const start = this.c.shift(this.r, 0);\n    return new Arc(this.c, start, TWO_PI);\n  }\n\n  tangentAt(t: number) {\n    const p1 = this.at(t);\n    const p2 = this.c.rotate(Math.PI / 2, p1);\n    return new Line(p1, p2);\n  }\n\n  collision(r: Rectangle) {\n    const tX = (this.c.x < r.p.x) ? r.p.x : (this.c.x > r.p.x + r.w) ? r.p.x + r.w : this.c.x;\n    const tY = (this.c.y < r.p.y) ? r.p.y : (this.c.y > r.p.y + r.h) ? r.p.y + r.h : this.c.y;\n\n    const d = Point.distance(this.c, new Point(tX, tY));\n    return d <= this.r;\n  }\n\n  // ---------------------------------------------------------------------------\n\n  project(p: Point) {\n    const proj = p.subtract(this.c).unitVector.scale(this.r);\n    return Point.sum(this.c, proj);\n  }\n\n  at(t: number) {\n    const a = TWO_PI * t;\n    return this.c.shift(this.r * Math.cos(a), this.r * Math.sin(a));\n  }\n\n  offset(p: Point) {\n    return rad(p, this.c) / TWO_PI;\n  }\n\n  contains(p: Point) {\n    return Point.distance(p, this.c) <= this.r;\n  }\n\n  // ---------------------------------------------------------------------------\n\n  transform(m: TransformMatrix) {\n    const scale = Math.abs(m[0][0]) + Math.abs(m[1][1]);\n    return new Circle(this.c.transform(m), this.r * scale / 2);\n  }\n\n  rotate(a: number, c = ORIGIN) {\n    if (nearlyEquals(a, 0)) return this;\n    return new Circle(this.c.rotate(a, c), this.r);\n  }\n\n  reflect(l: Line) {\n    return new Circle(this.c.reflect(l), this.r);\n  }\n\n  scale(sx: number, sy = sx) {\n    return new Circle(this.c.scale(sx, sy), this.r * (sx + sy) / 2);\n  }\n\n  shift(x: number, y = x) {\n    return new Circle(this.c.shift(x, y), this.r);\n  }\n\n  translate(p: SimplePoint) {\n    return this.shift(p.x, p.y);\n  }\n\n  equals(other: Circle, tolerance?: number) {\n    return nearlyEquals(this.r, other.r, tolerance) && this.c.equals(other.c, tolerance);\n  }\n\n  toString() {\n    return `circle(${this.c},${this.r})`;\n  }\n}\n", "// =============================================================================\n// Euclid.js | Line, Ray and Segment Classes\n// (c) Mathigon\n// =============================================================================\n\n\nimport {clamp, isBetween, nearlyEquals} from '@mathigon/fermat';\nimport {ORIGIN, Point} from './point';\nimport {isRay, isSegment} from './types';\nimport {GeoShape, rad, SimplePoint, TransformMatrix} from './utilities';\n\n\n/** An infinite straight line that goes through two points. */\nexport class Line implements GeoShape {\n  readonly type: string = 'line';\n  flag?: number;\n  readonly ['constructor']!: new (p1: Point, p2: Point) => this;\n\n  constructor(readonly p1: Point, readonly p2: Point) {}\n\n  /* The distance between the two points defining this line. */\n  get length() {\n    return Point.distance(this.p1, this.p2);\n  }\n\n  /* The squared distance between the two points defining this line. */\n  get lengthSquared() {\n    return (this.p1.x - this.p2.x) ** 2 + (this.p1.y - this.p2.y) ** 2;\n  }\n\n  /** The midpoint of this line. */\n  get midpoint() {\n    return Point.average(this.p1, this.p2);\n  }\n\n  /** The slope of this line. */\n  get slope() {\n    return (this.p2.y - this.p1.y) / (this.p2.x - this.p1.x);\n  }\n\n  /** The y-axis intercept of this line. */\n  get intercept() {\n    return this.p1.y - this.slope * this.p1.x;\n  }\n\n  /** The angle formed between this line and the x-axis. */\n  get angle() {\n    return rad(this.p2, this.p1);\n  }\n\n  /** The point representing a unit vector along this line. */\n  get unitVector() {\n    return this.p2.subtract(this.p1).unitVector;\n  }\n\n  /** The point representing the perpendicular vector of this line. */\n  get perpendicularVector() {\n    return new Point(this.p2.y - this.p1.y, this.p1.x - this.p2.x).unitVector;\n  }\n\n  /** Finds the line parallel to this one, going through point p. */\n  parallel(p: Point) {\n    return new Line(p, p.add(this.p2).subtract(this.p1));\n  }\n\n  /** Finds the line perpendicular to this one, going through point p. */\n  perpendicular(p: Point) {\n    const q = this.line.project(p);\n    if (Point.equals(p, q)) return new Line(q, q.add(this.perpendicularVector.scale(this.length / 2)));\n    return new Line(q, p);\n  }\n\n  /** The perpendicular bisector of this line. */\n  get perpendicularBisector() {\n    return this.perpendicular(this.midpoint);\n  }\n\n  /** Squared distance between a point and a line. */\n  distanceSquared(p: Point) {\n    const proj = this.project(p);\n    return (p.x - proj.x) ** 2 + (p.y - proj.y) ** 2;\n  }\n\n  get line(): Line {\n    return this.type === 'line' ? this : new Line(this.p1, this.p2);\n  }\n\n  get ray(): Ray {\n    return isRay(this) ? this : new Ray(this.p1, this.p2);\n  }\n\n  get segment(): Segment {\n    return isSegment(this) ? this : new Segment(this.p1, this.p2);\n  }\n\n  // ---------------------------------------------------------------------------\n\n  /** Signed distance along the line (opposite of .at()). */\n  offset(p: SimplePoint) {\n    const a = Point.difference(this.p2, this.p1);\n    const b = Point.difference(p, this.p1);\n    return Point.dot(a, b) / this.lengthSquared;\n  }\n\n  /** Projects a point `p` onto this line. */\n  project(p: SimplePoint) {\n    return this.at(this.offset(p));\n  }\n\n  /** Returns which side of this line a point p is on (or 0 on the line). */\n  side(p: SimplePoint, tolerance?: number) {\n    const a = Point.difference(this.p2, this.p1);\n    const b = Point.difference(p, this.p1);\n    const d = b.x * a.y - b.y * a.x;\n    return nearlyEquals(d, 0, tolerance) ? 0 : Math.sign(d);\n  }\n\n  /** Checks if a point p lies on this line. */\n  contains(p: SimplePoint, tolerance?: number) {\n    return this.side(p, tolerance) === 0;\n  }\n\n  /** Gets the point at a specific offset along the line (opposite of .offset()). */\n  at(t: number) {\n    return Point.interpolate(this.p1, this.p2, t);\n  }\n\n  // ---------------------------------------------------------------------------\n\n  transform(m: TransformMatrix): this {\n    return new this.constructor(this.p1.transform(m), this.p2.transform(m));\n  }\n\n  /** Rotates this line by a given angle (in radians), optionally around point `c`. */\n  rotate(a: number, c = ORIGIN): this {\n    if (nearlyEquals(a, 0)) return this;\n    return new this.constructor(this.p1.rotate(a, c), this.p2.rotate(a, c));\n  }\n\n  reflect(l: Line): this {\n    return new this.constructor(this.p1.reflect(l), this.p2.reflect(l));\n  }\n\n  scale(sx: number, sy = sx) {\n    return new this.constructor(this.p1.scale(sx, sy), this.p2.scale(sx, sy));\n  }\n\n  shift(x: number, y = x) {\n    return new this.constructor(this.p1.shift(x, y), this.p2.shift(x, y));\n  }\n\n  translate(p: SimplePoint) {\n    return this.shift(p.x, p.y);\n  }\n\n  equals(other: Line, tolerance?: number) {\n    // Note: Checking line types breaks some applications in Mathigon textbooks.\n    // if (other.type !== 'line') return false;\n    return this.contains(other.p1, tolerance) && this.contains(other.p2, tolerance);\n  }\n\n  toString() {\n    return `line(${this.p1},${this.p2})`;\n  }\n}\n\n\n/** An infinite ray defined by an endpoint and another point on the ray. */\nexport class Ray extends Line {\n  readonly type = 'ray';\n\n  equals(other: Ray, tolerance?: number) {\n    if (other.type !== 'ray') return false;\n    if (!this.p1.equals(other.p1, tolerance)) return false;\n    if (this.p2.equals(other.p2, tolerance)) return true;\n    return other.contains(this.p2, tolerance) || this.contains(other.p2, tolerance);\n  }\n\n  contains(p: Point, tolerance?: number) {\n    if (!super.contains(p, tolerance)) return false;\n    const offset = this.offset(p);\n    return nearlyEquals(offset, 0, tolerance) || offset > 0;\n  }\n\n  toString() {\n    return `ray(${this.p1},${this.p2})`;\n  }\n}\n\n\n/** A finite line segment defined by its two endpoints. */\nexport class Segment extends Line {\n  readonly type = 'segment';\n\n  contains(p: Point, tolerance?: number) {\n    if (!super.contains(p, tolerance)) return false;\n    if (this.p1.equals(p, tolerance) || this.p2.equals(p, tolerance)) return true;\n    if (nearlyEquals(this.p1.x, this.p2.x, tolerance)) {\n      return isBetween(p.y, this.p1.y, this.p2.y);\n    } else {\n      return isBetween(p.x, this.p1.x, this.p2.x);\n    }\n  }\n\n  project(p: SimplePoint) {\n    const a = Point.difference(this.p2, this.p1);\n    const b = Point.difference(p, this.p1);\n\n    const q = clamp(Point.dot(a, b) / this.lengthSquared, 0, 1);\n    return this.p1.add(a.scale(q));\n  }\n\n  /** Contracts (or expands) a line by a specific ratio. */\n  contract(x: number) {\n    return new Segment(this.at(x), this.at(1 - x));\n  }\n\n  equals(other: Segment, tolerance?: number, oriented = false) {\n    if (other.type !== 'segment') return false;\n\n    return (this.p1.equals(other.p1, tolerance) && this.p2.equals(other.p2, tolerance)) ||\n           (!oriented && this.p1.equals(other.p2, tolerance) && this.p2.equals(other.p1, tolerance));\n  }\n\n  toString() {\n    return `segment(${this.p1},${this.p2})`;\n  }\n}\n", "// =============================================================================\n// Euclid.js | Point Class\n// (c) Mathigon\n// =============================================================================\n\n\nimport {total} from '@mathigon/core';\nimport {clamp, lerp, nearlyEquals, Random, roundTo, square} from '@mathigon/fermat';\nimport {Bounds} from './bounds';\nimport {Line} from './line';\nimport {isPoint} from './types';\nimport {GeoElement, rad, SimplePoint, TransformMatrix} from './utilities';\n\n\n/** A single point class defined by two coordinates x and y. */\nexport class Point implements GeoElement, SimplePoint {\n  readonly type = 'point';\n\n  constructor(readonly x = 0, readonly y = 0) {}\n\n  get unitVector() {\n    if (nearlyEquals(this.length, 0)) return new Point(1, 0);\n    return this.scale(1 / this.length);\n  }\n\n  get length() {\n    return Math.sqrt(this.x ** 2 + this.y ** 2);\n  }\n\n  get inverse() {\n    return new Point(-this.x, -this.y);\n  }\n\n  get flip() {\n    return new Point(this.y, this.x);\n  }\n\n  get perpendicular() {\n    return new Point(-this.y, this.x);\n  }\n\n  get array() {\n    return [this.x, this.y];\n  }\n\n  /** Finds the perpendicular distance between this point and a line. */\n  distanceFromLine(l: Line) {\n    return Point.distance(this, l.project(this));\n  }\n\n  /** Clamps this point to specific bounds. */\n  clamp(bounds: Bounds, padding = 0) {\n    const x = clamp(this.x, bounds.xMin + padding, bounds.xMax - padding);\n    const y = clamp(this.y, bounds.yMin + padding, bounds.yMax - padding);\n    return new Point(x, y);\n  }\n\n  changeCoordinates(originCoords: Bounds, targetCoords: Bounds) {\n    const x = targetCoords.xMin + (this.x - originCoords.xMin) /\n              (originCoords.dx) * (targetCoords.dx);\n    const y = targetCoords.yMin + (this.y - originCoords.yMin) /\n              (originCoords.dy) * (targetCoords.dy);\n    return new Point(x, y);\n  }\n\n  add(p: SimplePoint) {\n    return Point.sum(this, p);\n  }\n\n  subtract(p: SimplePoint) {\n    return Point.difference(this, p);\n  }\n\n  round(inc = 1) {\n    return new Point(roundTo(this.x, inc), roundTo(this.y, inc));\n  }\n\n  floor() {\n    return new Point(Math.floor(this.x), Math.floor(this.y));\n  }\n\n  mod(x: number, y = x) {\n    return new Point(this.x % x, this.y % y);\n  }\n\n  angle(c = ORIGIN) {\n    return rad(this, c);\n  }\n\n  // Snap to the x or y values of another point\n  snap(p: Point, tolerance = 5) {\n    if (nearlyEquals(this.x, p.x, tolerance)) return new Point(p.x, this.y);\n    if (nearlyEquals(this.y, p.y, tolerance)) return new Point(this.x, p.y);\n    return this;\n  }\n\n  /** Calculates the average of multiple points. */\n  static average(...points: SimplePoint[]) {\n    const x = total(points.map(p => p.x)) / points.length;\n    const y = total(points.map(p => p.y)) / points.length;\n    return new Point(x, y);\n  }\n\n  /** Calculates the dot product of two points p1 and p2. */\n  static dot(p1: SimplePoint, p2: SimplePoint) {\n    return p1.x * p2.x + p1.y * p2.y;\n  }\n\n  static sum(p1: SimplePoint, p2: SimplePoint) {\n    return new Point(p1.x + p2.x, p1.y + p2.y);\n  }\n\n  static difference(p1: SimplePoint, p2: SimplePoint) {\n    return new Point(p1.x - p2.x, p1.y - p2.y);\n  }\n\n  /** Returns the Euclidean distance between two points p1 and p2. */\n  static distance(p1: SimplePoint, p2: SimplePoint) {\n    return Math.sqrt(square(p1.x - p2.x) + square(p1.y - p2.y));\n  }\n\n  /** Returns the Manhattan distance between two points p1 and p2. */\n  static manhattan(p1: SimplePoint, p2: SimplePoint) {\n    return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n  }\n\n  /** Interpolates two points p1 and p2 by a factor of t. */\n  static interpolate(p1: SimplePoint, p2: SimplePoint, t = 0.5) {\n    return new Point(lerp(p1.x, p2.x, t), lerp(p1.y, p2.y, t));\n  }\n\n  /** Interpolates a list of multiple points. */\n  static interpolateList(points: SimplePoint[], t = 0.5) {\n    const n = points.length - 1;\n    const a = Math.floor(clamp(t, 0, 1) * n);\n    return Point.interpolate(points[a], points[a + 1], n * t - a);\n  }\n\n  /** Creates a point from polar coordinates. */\n  static fromPolar(angle: number, r = 1) {\n    return new Point(r * Math.cos(angle), r * Math.sin(angle));\n  }\n\n  static random(b: Bounds) {\n    const x = Random.uniform(b.xMin, b.xMax);\n    const y = Random.uniform(b.yMin, b.yMax);\n    return new Point(x, y);\n  }\n\n  static equals(p1: SimplePoint, p2: SimplePoint, precision?: number) {\n    return nearlyEquals(p1.x, p2.x, precision) && nearlyEquals(p1.y, p2.y, precision);\n  }\n\n  /** Check if p1, p2 and p3 lie on a straight line. */\n  static colinear(p1: SimplePoint, p2: SimplePoint, p3: SimplePoint, tolerance?: number) {\n    const dx1 = p1.x - p2.x;\n    const dy1 = p1.y - p2.y;\n    const dx2 = p2.x - p3.x;\n    const dy2 = p2.y - p3.y;\n    return nearlyEquals(dx1 * dy2, dx2 * dy1, tolerance);\n  }\n\n  // ---------------------------------------------------------------------------\n\n  /** Transforms this point using a 2x3 matrix m. */\n  transform(m: TransformMatrix) {\n    const x = m[0][0] * this.x + m[0][1] * this.y + m[0][2];\n    const y = m[1][0] * this.x + m[1][1] * this.y + m[1][2];\n    return new Point(x, y);\n  }\n\n  /** Rotates this point by a given angle (in radians) around point `c`. */\n  rotate(angle: number, c: SimplePoint = ORIGIN) {\n    if (nearlyEquals(angle, 0)) return this;\n\n    const x0 = this.x - c.x;\n    const y0 = this.y - c.y;\n\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n\n    const x = x0 * cos - y0 * sin + c.x;\n    const y = x0 * sin + y0 * cos + c.y;\n    return new Point(x, y);\n  }\n\n  /** Reflects this point across a line l. */\n  reflect(l: Line) {\n    const v = l.p2.x - l.p1.x;\n    const w = l.p2.y - l.p1.y;\n\n    const x0 = this.x - l.p1.x;\n    const y0 = this.y - l.p1.y;\n\n    const mu = (v * y0 - w * x0) / (v * v + w * w);\n\n    const x = this.x + 2 * mu * w;\n    const y = this.y - 2 * mu * v;\n    return new Point(x, y);\n  }\n\n  scale(sx: number, sy = sx) {\n    return new Point(this.x * sx, this.y * sy);\n  }\n\n  shift(x: number, y = x) {\n    return new Point(this.x + x, this.y + y);\n  }\n\n  translate(p: SimplePoint) {\n    return this.shift(p.x, p.y);  // Alias for .add()\n  }\n\n  equals(other: GeoElement|SimplePoint, precision?: number) {\n    return Point.equals(this, other as SimplePoint, precision);\n  }\n\n  toString() {\n    return `point(${this.x},${this.y})`;\n  }\n}\n\nexport const ORIGIN = new Point(0, 0);\n", "// =============================================================================\n// Euclid.js | Utilities\n// (c) Mathigon\n// =============================================================================\n\n\nimport {mod} from '@mathigon/fermat';\nimport {Line} from './line';\nimport {Point} from './point';\n\n\nexport type TransformMatrix = [[number, number, number], [number, number, number]];\n\nexport type SimplePoint = {x: number, y: number};\n\nexport interface GeoElement {\n  type: string;\n  transform(matrix: TransformMatrix): GeoElement;\n  rotate(angle: number, center?: SimplePoint): GeoElement;\n  reflect(l: Line): GeoElement;\n  scale(sx: number, sy?: number): GeoElement;\n  shift(x: number, y?: number): GeoElement;\n  translate(p: Point): GeoElement;\n  equals(other: GeoElement, tolerance?: number, oriented?: boolean): boolean;\n  toString(): string;\n}\n\nexport interface GeoShape extends GeoElement {\n  project(p: Point): Point;\n  contains(p: Point, tolerance?: number): boolean;\n  at(t: number): Point;\n  offset(p: Point): number;\n\n  rotate(angle: number, center?: SimplePoint): GeoShape;\n  reflect(l: Line): GeoShape;\n  scale(sx: number, sy?: number): GeoShape;\n  shift(x: number, y?: number): GeoShape;\n  translate(p: SimplePoint): GeoShape;\n}\n\nexport const TWO_PI = 2 * Math.PI;\n\nexport function rad(p: SimplePoint, c?: SimplePoint) {\n  const a = Math.atan2(p.y - (c ? c.y : 0), p.x - (c ? c.x : 0));\n  return mod(a, TWO_PI);\n}\n\n// TODO Merge this with findMin() in @mathigon/core\nexport function findClosest(p: Point, items: GeoShape[]): [Point, number]|undefined {\n  let q: Point|undefined = undefined;\n  let d = Infinity;\n  let index = -1;\n\n  for (const [i, e] of items.entries()) {\n    const q1 = e.project(p);\n    const d1 = Point.distance(p, q1);\n    if (d1 < d) {\n      q = q1;\n      d = d1;\n      index = i;\n    }\n  }\n\n  return q ? [q, index] : undefined;\n}\n", "// =============================================================================\n// Euclid.js | Type Checking\n// (c) Mathigon\n// =============================================================================\n\n\nimport {Angle} from './angle';\nimport {Arc, Sector} from './arc';\nimport {Circle} from './circle';\nimport {Ellipse} from './ellipse';\nimport {Line, Ray, Segment} from './line';\nimport {Point} from './point';\nimport {Polygon, Polyline} from './polygon';\nimport {Rectangle} from './rectangle';\nimport {GeoElement} from './utilities';\n\n\nexport function isPolygonLike(shape: GeoElement): shape is Polygon|Rectangle {\n  return ['polygon', 'polyline', 'rectangle', 'triangle'].includes(shape.type);\n}\n\nexport function isPolygon(shape: GeoElement): shape is Polygon {\n  return ['polygon', 'triangle'].includes(shape.type);\n}\n\nexport function isPolyline(shape: GeoElement): shape is Polyline {\n  return shape.type === 'polyline';\n}\n\nexport function isRectangle(shape: GeoElement): shape is Rectangle {\n  return shape.type === 'rectangle';\n}\n\nexport function isLineLike(shape: GeoElement): shape is Line|Ray|Segment {\n  return ['line', 'ray', 'segment'].includes(shape.type);\n}\n\nexport function isLine(shape: GeoElement): shape is Line {\n  return shape.type === 'line';\n}\n\nexport function isRay(shape: GeoElement): shape is Ray {\n  return shape.type === 'ray';\n}\n\nexport function isSegment(shape: GeoElement): shape is Segment {\n  return shape.type === 'segment';\n}\n\nexport function isCircle(shape: GeoElement): shape is Circle {\n  return shape.type === 'circle';\n}\n\nexport function isEllipse(shape: GeoElement): shape is Ellipse {\n  return shape.type === 'ellipse';\n}\n\nexport function isArc(shape: GeoElement): shape is Arc {\n  return shape.type === 'arc';\n}\n\nexport function isSector(shape: GeoElement): shape is Sector {\n  return shape.type === 'sector';\n}\n\nexport function isAngle(shape: GeoElement): shape is Angle {\n  return shape.type === 'angle';\n}\n\nexport function isPoint(shape: GeoElement): shape is Point {\n  return shape.type === 'point';\n}\n", "// =============================================================================\n// Euclid.js | Polygon and Polyline Classes\n// (c) Mathigon\n// =============================================================================\n\n\nimport {last, tabulate} from '@mathigon/core';\nimport {nearlyEquals} from '@mathigon/fermat';\nimport {difference, intersect, union} from './boolean';\nimport {Circle} from './circle';\nimport {intersections} from './intersection';\nimport {Line, Segment} from './line';\nimport {ORIGIN, Point} from './point';\nimport {findClosest, GeoShape, SimplePoint, TransformMatrix, TWO_PI} from './utilities';\n\n\n/** A polygon defined by its vertex points. */\nexport class Polygon implements GeoShape {\n  readonly type: string = 'polygon';\n  readonly points: Point[];\n  readonly ['constructor']!: new (...points: Point[]) => this;\n\n  constructor(...points: Point[]) {\n    this.points = points;\n  }\n\n  get circumference() {\n    if (this.points.length <= 1) return 0;\n    let length = Point.distance(this.points[0], last(this.points));\n    for (let i = 1; i < this.points.length; ++i) {\n      length += Point.distance(this.points[i - 1], this.points[i]);\n    }\n    return length;\n  }\n\n  /**\n   * The (signed) area of this polygon. The result is positive if the vertices\n   * are ordered clockwise, and negative otherwise.\n   */\n  get signedArea() {\n    const p = this.points;\n    const n = p.length;\n    let A = p[n - 1].x * p[0].y - p[0].x * p[n - 1].y;\n\n    for (let i = 1; i < n; ++i) {\n      A += p[i - 1].x * p[i].y - p[i].x * p[i - 1].y;\n    }\n\n    return A / 2;\n  }\n\n  get area() {\n    return Math.abs(this.signedArea);\n  }\n\n  get centroid() {\n    const p = this.points;\n    const n = p.length;\n\n    let Cx = 0;\n    for (let i = 0; i < n; ++i) Cx += p[i].x;\n\n    let Cy = 0;\n    for (let i = 0; i < n; ++i) Cy += p[i].y;\n\n    return new Point(Cx / n, Cy / n);\n  }\n\n  get edges() {\n    const n = this.points.length;\n    const edges = [];\n    for (let i = 0; i < n; ++i) {\n      edges.push(new Segment(this.points[i], this.points[(i + 1) % n]));\n    }\n    return edges;\n  }\n\n  get radius() {\n    const c = this.centroid;\n    const radii = this.points.map(p => Point.distance(p, c));\n    return Math.max(...radii);\n  }\n\n  /** The oriented version of this polygon (vertices in clockwise order). */\n  get oriented(): this {\n    if (this.signedArea >= 0) return this;\n    const points = [...this.points].reverse();\n    return new this.constructor(...points);\n  }\n\n  /** Cut this polygon along a line, and return multiple parts. */\n  cut(line: Line) {\n    // This feels a bit hacky... can we find the bounding box of the Polygon?\n    const t = this.radius / line.length * 10;\n    const a = line.at(-t);\n    const b = line.at(t);\n    const d = line.perpendicularVector.scale(line.length * t);\n    const mask = [a, b, b.add(d), a.add(d)];\n\n    const side1 = intersect([this.points], [mask]);\n    const side2 = difference([this.points], [mask]);\n    return [...side1, ...side2].map(p => new Polygon(...p));\n  }\n\n  /** Checks if two polygons p1 and p2 collide. */\n  static collision(p1: Polygon, p2: Polygon) {\n    // Check if one of the vertices is in one of the polygons.\n    if (p1.points.some(q => p2.contains(q))) return true;\n    if (p2.points.some(q => p1.contains(q))) return true;\n\n    // Check if any of the edges overlap.\n    for (const e1 of p1.edges) {\n      for (const e2 of p2.edges) {\n        if (intersections(e1, e2)[0]) return true;\n      }\n    }\n\n    return false;\n  }\n\n  static union(...polygons: Polygon[]): Polygon[] {\n    const [first, ...other] = polygons;\n    if (!other.length) return [first];\n\n    const p1 = [first.points];\n    const p2 = other.length > 1 ? Polygon.union(...other).map(p => p.points) : [polygons[1].points];\n    return union(p1, p2).map(p => new Polygon(...p));\n  }\n\n  /** Creates a regular polygon. */\n  static regular(n: number, radius = 1) {\n    const da = TWO_PI / n;\n    const a0 = Math.PI / 2 - da / 2;\n\n    const points = tabulate((i) => Point.fromPolar(a0 + da * i, radius), n);\n    return new Polygon(...points);\n  }\n\n  /** Interpolates the points of two polygons */\n  static interpolate(p1: Polygon, p2: Polygon, t = 0.5) {\n    // TODO support interpolating polygons with different numbers of points\n    const points = p1.points.map(\n      (p, i) => Point.interpolate(p, p2.points[i], t));\n    return new Polygon(...points);\n  }\n\n  static convexHull(...points: Point[]) {\n    // https://algorithmist.com/wiki/Monotone_chain_convex_hull\n    if (points.length <= 3) return new Polygon(...points);\n\n    const sorted = points.sort((a, b) => a.x !== b.x ? a.x - b.x : a.y - b.y);\n    const sortedReverse = sorted.slice(0).reverse();\n\n    const upper: Point[] = [];\n    const lower: Point[] = [];\n\n    for (const [source, target] of [[sorted, upper], [sortedReverse, lower]]) {\n      for (const p of source) {\n        while (target.length >= 2) {\n          const p1 = target[target.length - 1];\n          const p2 = target[target.length - 2];\n          if ((p1.x - p2.x) * (p.y - p2.y) >= (p.x - p2.x) * (p1.y - p2.y)) {\n            target.pop();\n          } else {\n            break;\n          }\n        }\n        target.push(p);\n      }\n      target.pop();\n    }\n\n    return new Polygon(...upper.concat(lower));\n  }\n\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Checks if a point p lies inside this polygon, by using a ray-casting\n   * algorithm and calculating the number of intersections.\n   */\n  contains(p: Point) {\n    let inside = false;\n\n    for (const e of this.edges) {\n      // Exclude points lying *on* the edge.\n      if (e.p1.equals(p) || e.contains(p)) return false;\n      if ((e.p1.y > p.y) === (e.p2.y > p.y)) continue;\n\n      const det = (e.p2.x - e.p1.x) / (e.p2.y - e.p1.y);\n      if (p.x < det * (p.y - e.p1.y) + e.p1.x) inside = !inside;\n    }\n\n    return inside;\n  }\n\n  at(t: number) {\n    if (t < 0) t += Math.floor(t);\n    const offset = t * this.circumference;\n    let cum = 0;\n    for (const e of this.edges) {\n      const l = e.length;\n      if (cum + l > offset) return e.at((offset - cum) / l);\n      cum += l;\n    }\n    return this.points[0];\n  }\n\n  offset(p: Point) {\n    const edges = this.edges;\n    const proj = findClosest(p, this.edges) || [this.points[0], 0] as const;\n\n    let offset = 0;\n    for (let i = 0; i < proj[1]; ++i) offset += edges[i].length;\n    offset += edges[proj[1]].offset(p) * edges[proj[1]].length;\n\n    return offset / this.circumference;\n  }\n\n  project(p: Point) {\n    const proj = findClosest(p, this.edges);\n    return proj ? proj[0] : this.points[0];\n  }\n\n  /** Center this polygon on a given point or the origin */\n  centerAt(on = ORIGIN) {\n    return this.translate(on.subtract(this.centroid));\n  }\n\n  // ---------------------------------------------------------------------------\n\n  transform(m: TransformMatrix): this {\n    return new this.constructor(...this.points.map(p => p.transform(m)));\n  }\n\n  /** Rotates this polygon by a given angle (in radians), optionally around point `center`. */\n  rotate(a: number, center = ORIGIN): this {\n    if (nearlyEquals(a, 0)) return this;\n    const points = this.points.map(p => p.rotate(a, center));\n    return new this.constructor(...points);\n  }\n\n  reflect(line: Line): this {\n    const points = this.points.map(p => p.reflect(line));\n    return new this.constructor(...points);\n  }\n\n  scale(sx: number, sy = sx): this {\n    const points = this.points.map(p => p.scale(sx, sy));\n    return new this.constructor(...points);\n  }\n\n  shift(x: number, y = x): this {\n    const points = this.points.map(p => p.shift(x, y));\n    return new this.constructor(...points);\n  }\n\n  translate(p: SimplePoint) {\n    return this.shift(p.x, p.y);\n  }\n\n  equals(other: Polygon, tolerance?: number, oriented?: boolean) {\n    const n = this.points.length;\n    if (n !== other.points.length) return false;\n    const p1 = oriented ? this : this.oriented;\n    const p2 = oriented ? other : other.oriented;\n\n    // Check if all the points, match, but allow different offsets\n    for (let offset = 0; offset < n; ++offset) {\n      if (p1.points.every((p, i) => p.equals(p2.points[(i + offset) % n], tolerance))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  toString() {\n    return `polygon(${this.points.join(',')})`;\n  }\n}\n\n\n/** A polyline defined by its vertex points. */\nexport class Polyline extends Polygon {\n  readonly type = 'polyline';\n\n  get circumference() {\n    return this.length;\n  }\n\n  get length() {\n    let length = 0;\n    for (let i = 1; i < this.points.length; ++i) {\n      length += Point.distance(this.points[i - 1], this.points[i]);\n    }\n    return length;\n  }\n\n  /** @returns {Segment[]} */\n  get edges() {\n    const edges = [];\n    for (let i = 0; i < this.points.length - 1; ++i) {\n      edges.push(new Segment(this.points[i], this.points[i + 1]));\n    }\n    return edges;\n  }\n\n  toString() {\n    return `polyline(${this.points.join(',')})`;\n  }\n}\n\n\n/** A triangle defined by its three vertices. */\nexport class Triangle extends Polygon {\n  readonly type = 'triangle';\n\n  get circumcircle() {\n    const [a, b, c] = this.points;\n\n    const d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));\n\n    const ux = (a.x ** 2 + a.y ** 2) * (b.y - c.y) +\n               (b.x ** 2 + b.y ** 2) * (c.y - a.y) +\n               (c.x ** 2 + c.y ** 2) * (a.y - b.y);\n\n    const uy = (a.x ** 2 + a.y ** 2) * (c.x - b.x) +\n               (b.x ** 2 + b.y ** 2) * (a.x - c.x) +\n               (c.x ** 2 + c.y ** 2) * (b.x - a.x);\n\n    const center = new Point(ux / d, uy / d);\n    const radius = Point.distance(center, this.points[0]);\n\n    if (isNaN(radius) || radius > Number.MAX_SAFE_INTEGER) return;\n    return new Circle(center, radius);\n  }\n\n  get incircle() {\n    const edges = this.edges;\n    const sides = edges.map(e => e.length);\n    const total = sides[0] + sides[1] + sides[2];\n    const [a, b, c] = this.points;\n\n    const ux = sides[1] * a.x + sides[2] * b.x + sides[0] * c.x;\n    const uy = sides[1] * a.y + sides[2] * b.y + sides[0] * c.y;\n\n    const center = new Point(ux / total, uy / total);\n    const radius = center.distanceFromLine(edges[0]);\n\n    return isNaN(radius) ? undefined : new Circle(center, radius);\n  }\n\n  get orthocenter() {\n    const [a, b, c] = this.points;\n    const h1 = new Line(a, b).perpendicular(c);\n    const h2 = new Line(a, c).perpendicular(b);\n    return intersections(h1, h2)[0];\n  }\n}\n", "// =============================================================================\n// Euclid.js | Boolean Operations for Polygons\n// (c) Mathigon\n// =============================================================================\n\n\nimport {last} from '@mathigon/core';\nimport {nearlyEquals} from '@mathigon/fermat';\nimport {Point} from './point';\n\n// Based on https://github.com/velipso/polybooljs (MIT License)\n// \u2013 Converted to typescript\n// - Use Euclid.js's existing Point/Polygon classes\n// \u2013 Removed unneeded features (e.g. GeoJSON support and inverted polygons)\n\n\n// -----------------------------------------------------------------------------\n// Utility Functions\n\nconst PRECISION = 0.001;\n\nfunction pointAboveOrOnLine(pt: Point, left: Point, right: Point) {\n  const d1 = (right.x - left.x) * (pt.y - left.y);\n  const d2 = (right.y - left.y) * (pt.x - left.x);\n  return d1 - d2 >= -PRECISION;\n}\n\nfunction pointBetween(p: Point, left: Point, right: Point) {\n  // p must be collinear with left->right\n  // returns false if p == left, p == right, or left == right\n  const dpyly = p.y - left.y;\n  const drxlx = right.x - left.x;\n  const dpxlx = p.x - left.x;\n  const dryly = right.y - left.y;\n\n  const dot = dpxlx * drxlx + dpyly * dryly;\n  // if `dot` is 0, then `p` == `left` or `left` == `right` (reject)\n  // if `dot` is less than 0, then `p` is to the left of `left` (reject)\n  if (dot < PRECISION) return false;\n\n  const sqlen = drxlx * drxlx + dryly * dryly;\n  // if `dot` > `sqlen`, then `p` is to the right of `right` (reject)\n  // therefore, if `dot - sqlen` is greater than 0, then `p` is to the right of `right` (reject)\n  return dot - sqlen <= -PRECISION;\n}\n\nfunction pointsCompare(p1: Point, p2: Point) {\n  // returns -1 if p1 is smaller, 1 if p2 is smaller, 0 if equal\n  if (nearlyEquals(p1.x, p2.x)) {\n    return nearlyEquals(p1.y, p2.y) ? 0 : (p1.y < p2.y ? -1 : 1);\n  }\n  return p1.x < p2.x ? -1 : 1;\n}\n\n/**\n * Categorize where intersection point is along A and B:\n *  -2: intersection point is before segment's first point\n *  -1: intersection point is directly on segment's first point\n *   0: intersection point is between segment's first and second points (exclusive)\n *   1: intersection point is directly on segment's second point\n *   2: intersection point is after segment's second point\n */\nfunction getOffset(A: number): -2|-1|0|1|2 {\n  if (A <= -PRECISION) return -2;\n  if (A < PRECISION) return -1;\n  if (A - 1 <= -PRECISION) return 0;\n  if (A - 1 < PRECISION) return 1;\n  return 2;\n}\n\nfunction linesIntersect(a0: Point, a1: Point, b0: Point, b1: Point) {\n  const adx = a1.x - a0.x;\n  const ady = a1.y - a0.y;\n  const bdx = b1.x - b0.x;\n  const bdy = b1.y - b0.y;\n\n  const axb = adx * bdy - ady * bdx;\n  if (nearlyEquals(axb, 0)) return false;  // lines are coincident\n\n  const dx = a0.x - b0.x;\n  const dy = a0.y - b0.y;\n  const A = (bdx * dy - bdy * dx) / axb;\n  const B = (adx * dy - ady * dx) / axb;\n\n  const pt = new Point(a0.x + A * adx, a0.y + A * ady);\n  return {alongA: getOffset(A), alongB: getOffset(B), pt};\n}\n\n\n// -----------------------------------------------------------------------------\n// Types\n\ntype Node<T> = {prev?: Node<T>, next?: Node<T>, root?: boolean, remove: () => void} & T;\n\ninterface Segment {\n  start: Point;\n  end: Point;\n  myFill: {above?: boolean, below?: boolean};  // Is there fill above or below us?\n  otherFill?: {above?: boolean, below?: boolean};\n}\n\ninterface Event {\n  isStart?: boolean;\n  pt: Point;\n  seg: Segment;\n  primary?: boolean;\n  other?: Node<Event>;\n  status?: Node<Event>;\n  ev?: Node<Event>;\n}\n\ntype Status = {ev: Node<Event>};\n\n\n// -----------------------------------------------------------------------------\n// Linked List\n\nclass LinkedList<T> {\n  // TODO Better types without any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  root: any = {root: true, next: undefined};\n\n  exists(node: Node<T>) {\n    return node !== undefined && node !== this.root;\n  }\n\n  get head() {\n    return this.root.next;\n  }\n\n  insertBefore(node: Node<T>, check: (n: Node<T>) => boolean) {\n    let last = this.root;\n    let here = this.root.next;\n    while (here) {\n      if (check(here)) {\n        node.prev = here.prev;\n        node.next = here;\n        here.prev.next = node;\n        here.prev = node;\n        return;\n      }\n      last = here;\n      here = here.next;\n    }\n    last.next = node;\n    node.prev = last;\n    node.next = undefined;\n  }\n\n  findTransition(check: (n: Node<T>) => boolean) {\n    let prev = this.root;\n    let here = this.root.next;\n    while (here) {\n      if (check(here)) break;\n      prev = here;\n      here = here.next;\n    }\n    return {\n      before: prev === this.root ? undefined : prev,\n      after: here,\n      insert: (node: Node<T>) => {\n        node.prev = prev;\n        node.next = here;\n        prev.next = node;\n        if (here) here.prev = node;\n        return node;\n      }\n    };\n  }\n\n  static node<T>(data: T) {\n    const d = data as Node<T>;  // TODO Fix this typing!\n    d.remove = () => {\n      if (d.prev) d.prev.next = d.next;\n      if (d.next) d.next.prev = d.prev;\n      d.prev = d.next = undefined;\n    };\n    return d;\n  }\n}\n\n\n// -----------------------------------------------------------------------------\n// Main Algorithm\n\nfunction copy(start: Point, end: Point, seg: Segment) {\n  const myFill = {above: seg.myFill.above, below: seg.myFill.below};\n  return {start, end, myFill};\n}\n\nfunction eventCompare(p1isStart: boolean, p11: Point, p12: Point, p2isStart: boolean, p21: Point, p22: Point) {\n  const comp = pointsCompare(p11, p21);\n  if (comp !== 0) return comp;  // the selected points are the same\n\n  // If the non-selected points are the same too then the segments are equal.\n  if (Point.equals(p12, p22)) return 0;\n\n  // If one is a start and the other isn't favor the one that isn't the start.\n  if (p1isStart !== p2isStart) return p1isStart ? 1 : -1;\n\n  // Otherwise, we'll have to calculate which one is below the other manually. Order matters!\n  return pointAboveOrOnLine(p12, p2isStart ? p21 : p22, p2isStart ? p22 : p21,) ? 1 : -1;\n}\n\nfunction eventAdd(eventRoot: LinkedList<Event>, ev: Node<Event>, otherPt: Point) {\n  eventRoot.insertBefore(ev, (here) =>\n    eventCompare(!!ev.isStart, ev.pt, otherPt, !!here.isStart, here.pt, here.other!.pt) < 0);\n}\n\nfunction addSegmentStart(eventRoot: LinkedList<Event>, seg: Segment, primary: boolean) {\n  const evStart = LinkedList.node({isStart: true, pt: seg.start, seg, primary});\n  eventAdd(eventRoot, evStart, seg.end);\n  return evStart;\n}\n\nfunction addSegmentEnd(eventRoot: LinkedList<Event>, evStart: Node<Event>, seg: Segment, primary: boolean) {\n  const evEnd = LinkedList.node({pt: seg.end, seg, primary, other: evStart});\n  evStart.other = evEnd;\n  eventAdd(eventRoot, evEnd, evStart.pt);\n}\n\nfunction addSegment(eventRoot: LinkedList<Event>, seg: Segment, primary: boolean) {\n  const evStart = addSegmentStart(eventRoot, seg, primary);\n  addSegmentEnd(eventRoot, evStart, seg, primary);\n  return evStart;\n}\n\nfunction eventUpdateEnd(eventRoot: LinkedList<Event>, ev: Node<Event>, end: Point) {\n  // Slides an end backwards\n  ev.other!.remove();\n  ev.seg.end = end;\n  ev.other!.pt = end;\n  eventAdd(eventRoot, ev.other!, ev.pt);\n}\n\nfunction eventDivide(eventRoot: LinkedList<Event>, ev: Node<Event>, pt: Point) {\n  const ns = copy(pt, ev.seg.end, ev.seg);\n  eventUpdateEnd(eventRoot, ev, pt);\n  return addSegment(eventRoot, ns, !!ev.primary);\n}\n\nfunction statusCompare(ev1: Node<Event>, ev2: Node<Event>) {\n  const a1 = ev1.seg.start;\n  const a2 = ev1.seg.end;\n  const b1 = ev2.seg.start;\n  const b2 = ev2.seg.end;\n\n  if (!Point.colinear(a1, b1, b2)) return pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;\n  if (!Point.colinear(a2, b1, b2)) return pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;\n  return 1;\n}\n\n/** Returns the segment equal to ev1, or false if nothing equal. */\nfunction checkIntersection(eventRoot: LinkedList<Event>, ev1: Node<Event>, ev2: Node<Event>) {\n  const seg1 = ev1.seg;\n  const seg2 = ev2.seg;\n  const a1 = seg1.start;\n  const a2 = seg1.end;\n  const b1 = seg2.start;\n  const b2 = seg2.end;\n\n  const i = linesIntersect(a1, a2, b1, b2);\n\n  if (i === false) {\n    // Segments are parallel or coincident. If points aren't collinear, then\n    // the segments are parallel, so no intersections. Otherwise, segments are\n    // on top of each other somehow (aka coincident)\n    if (!Point.colinear(a1, a2, b1)) return false;\n    if (Point.equals(a1, b2) || Point.equals(a2, b1)) return false;\n\n    const a1isb1 = Point.equals(a1, b1);\n    const a2isb2 = Point.equals(a2, b2);\n\n    if (a1isb1 && a2isb2) return ev2;  // Segments are exactly equal\n\n    const a1Between = !a1isb1 && pointBetween(a1, b1, b2);\n    const a2Between = !a2isb2 && pointBetween(a2, b1, b2);\n\n    if (a1isb1) {\n      a2Between ? eventDivide(eventRoot, ev2, a2) : eventDivide(eventRoot, ev1, b2);\n      return ev2;\n    } else if (a1Between) {\n      if (!a2isb2) {\n        a2Between ? eventDivide(eventRoot, ev2, a2) : eventDivide(eventRoot, ev1, b2);\n      }\n      eventDivide(eventRoot, ev2, a1);\n    }\n\n  } else {\n    // Otherwise, lines intersect at i.pt, which may or may not be between the endpoints\n\n    // Is A divided between its endpoints? (exclusive)\n    if (i.alongA === 0) {\n      if (i.alongB === -1) { // yes, at exactly b1\n        eventDivide(eventRoot, ev1, b1);\n      } else if (i.alongB === 0) { // yes, somewhere between B's endpoints\n        eventDivide(eventRoot, ev1, i.pt);\n      } else if (i.alongB === 1) { // yes, at exactly b2\n        eventDivide(eventRoot, ev1, b2);\n      }\n    }\n\n    // Is B divided between its endpoints? (exclusive)\n    if (i.alongB === 0) {\n      if (i.alongA === -1) { // yes, at exactly a1\n        eventDivide(eventRoot, ev2, a1);\n      } else if (i.alongA === 0) { // yes, somewhere between A's endpoints (exclusive)\n        eventDivide(eventRoot, ev2, i.pt);\n      } else if (i.alongA === 1) { // yes, at exactly a2\n        eventDivide(eventRoot, ev2, a2);\n      }\n    }\n  }\n  return false;\n}\n\nfunction calculate(eventRoot: LinkedList<Event>, selfIntersection: boolean) {\n  const statusRoot = new LinkedList<Status>();\n\n  const segments = [];\n  while (eventRoot.head) {\n    const ev = eventRoot.head;\n\n    if (ev.isStart) {\n      const surrounding = statusRoot.findTransition((here) => statusCompare(ev, here.ev) > 0);\n      const above = surrounding.before?.ev;\n      const below = surrounding.after?.ev;\n\n      // eslint-disable-next-line no-inner-declarations\n      function checkBothIntersections() {\n        if (above) {\n          const eve = checkIntersection(eventRoot, ev, above);\n          if (eve) return eve;\n        }\n        if (below) return checkIntersection(eventRoot, ev, below);\n        return false;\n      }\n\n      const eve = checkBothIntersections();\n      if (eve) {\n        // ev and eve are equal: we'll keep eve and throw away ev\n\n        if (selfIntersection) {\n          // If we are a toggling edge, we merge two segments that belong to the\n          // same polygon. Think of this as sandwiching two segments together,\n          // where `eve.seg` is the bottom. This will cause the above fill flag to toggle\n          const toggle = !ev.seg.myFill.below ? true : ev.seg.myFill.above !== ev.seg.myFill.below;\n          if (toggle) eve.seg.myFill.above = !eve.seg.myFill.above;\n        } else {\n          // Merge two segments that belong to different polygons. Each segment\n          // has distinct knowledge, so no special logic is needed note that\n          // this can only happen once per segment in this phase, because we are\n          // guaranteed that all self-intersections are gone.\n          eve.seg.otherFill = ev.seg.myFill;\n        }\n\n        ev.other.remove();\n        ev.remove();\n      }\n\n      // something was inserted before us in the event queue, so loop back around and\n      // process it before continuing\n      if (eventRoot.head !== ev) continue;\n\n      // Calculate fill flags\n\n      if (selfIntersection) {\n        // We toggle an edge if if we are a new segment, or we are a segment\n        // that has previous knowledge from a division\n        const toggle = (!ev.seg.myFill.below) ? true : ev.seg.myFill.above !== ev.seg.myFill.below;\n\n        // Calculate whether we are filled below us. If nothing is below us, we\n        // are not filled below. Otherwise, the answer is the same if whatever\n        // is below us is filled above it.\n        ev.seg.myFill.below = !below ? false : below.seg.myFill.above;\n\n        // since now we know if we're filled below us, we can calculate whether\n        // we're filled above us by applying toggle to whatever is below us\n        ev.seg.myFill.above = toggle ? !ev.seg.myFill.below : ev.seg.myFill.below;\n\n      } else if (ev.seg.otherFill === undefined) {\n        // If we don't have other information, we need to figure out if we're\n        // inside the other polygon. If nothing is below us, then we're\n        // outside. Otherwise copy the below segment's other polygon's above.\n        const inside = !below ? false : (ev.primary === below.primary) ? below.seg.otherFill.above : below.seg.myFill.above;\n        ev.seg.otherFill = {above: inside, below: inside};\n      }\n\n      // Insert the status and remember it for later removal\n      ev.other.status = surrounding.insert(LinkedList.node({ev}));\n\n    } else {\n      const st = ev.status;\n      if (st === undefined) throw new Error('[Euclid.js] Zero-length segment detected!');\n\n      // Removing the status will create two new adjacent edges, so we'll need\n      // to check for those.\n      if (statusRoot.exists(st.prev) && statusRoot.exists(st.next)) {\n        checkIntersection(eventRoot, st.prev.ev, st.next.ev);\n      }\n\n      st.remove();\n\n      // Now we've calculated everything, so save the segment for reporting.\n      if (!ev.primary) {\n        const s = ev.seg.myFill;  // Make sure `seg.myFill` points to the primary polygon.\n        ev.seg.myFill = ev.seg.otherFill;\n        ev.seg.otherFill = s;\n      }\n      segments.push(ev.seg);\n    }\n\n    eventRoot.head.remove();\n  }\n\n  return segments;\n}\n\n\n// -----------------------------------------------------------------------------\n// Segment Chainer\n\nfunction segmentChainer(segments: Segment[]) {\n  const chains: Point[][] = [];\n  const regions: Point[][] = [];\n\n  segments.forEach((seg) => {\n    const pt1 = seg.start;\n    const pt2 = seg.end;\n    if (Point.equals(pt1, pt2)) return;  // Zero-length segment: maybe PRECISION is too small or too large!\n\n    // Search for two chains that this segment matches.\n    const firstMatch = {index: 0, matchesHead: false, matchesPt1: false};\n    const secondMatch = {index: 0, matchesHead: false, matchesPt1: false};\n\n    // TODO Better types without any\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let nextMatch: any = firstMatch;\n\n    function setMatch(index: number, matchesHead: boolean, matchesPt1: boolean) {\n      nextMatch.index = index;\n      nextMatch.matchesHead = matchesHead;\n      nextMatch.matchesPt1 = matchesPt1;\n      const match = nextMatch === firstMatch;\n      nextMatch = match ? secondMatch : undefined;\n      return !match;\n    }\n\n    for (let i = 0; i < chains.length; i++) {\n      const chain = chains[i];\n      const head = chain[0];\n      const tail = last(chain);\n      if (Point.equals(head, pt1)) {\n        if (setMatch(i, true, true)) break;\n      } else if (Point.equals(head, pt2)) {\n        if (setMatch(i, true, false)) break;\n      } else if (Point.equals(tail, pt1)) {\n        if (setMatch(i, false, true)) break;\n      } else if (Point.equals(tail, pt2)) {\n        if (setMatch(i, false, false)) break;\n      }\n    }\n\n    if (nextMatch === firstMatch) {\n      // We didn't match anything, so create a new chain.\n      chains.push([pt1, pt2]);\n      return;\n    }\n\n    if (nextMatch === secondMatch) {\n      // We matched a single chain. Add the other point to the appropriate end,\n      // and check to see if we've closed the chain into a loop.\n\n      const index = firstMatch.index;\n      const pt = firstMatch.matchesPt1 ? pt2 : pt1;\n      const addToHead = firstMatch.matchesHead;\n\n      const chain = chains[index];\n      let grow = addToHead ? chain[0] : chain[chain.length - 1];\n      const grow2 = addToHead ? chain[1] : chain[chain.length - 2];\n      const oppo = addToHead ? chain[chain.length - 1] : chain[0];\n      const oppo2 = addToHead ? chain[chain.length - 2] : chain[1];\n\n      if (Point.colinear(grow2, grow, pt)) {\n        // Grow isn't needed because it's directly between grow2 and pt.\n        addToHead ? chain.shift() : chain.pop();\n        grow = grow2; // Old grow is gone... new grow is what grow2 was.\n      }\n\n      if (Point.equals(oppo, pt)) {\n        // We're closing the loop, so remove chain from chains.\n        chains.splice(index, 1);\n\n        if (Point.colinear(oppo2, oppo, grow)) {\n          // Oppo isn't needed because it's directly between oppo2 and grow.\n          addToHead ? chain.pop() : chain.shift();\n        }\n\n        regions.push(chain);\n        return;\n      }\n\n      // Not closing a loop, so just add it to the appropriate side.\n      addToHead ? chain.unshift(pt) : chain.push(pt);\n      return;\n    }\n\n    // Otherwise, we matched two chains, so we need to combine those chains together.\n\n    function reverseChain(index: number) {\n      chains[index].reverse();\n    }\n\n    function appendChain(index1: number, index2: number) {\n      // index1 gets index2 appended to it, and index2 is removed\n      const chain1 = chains[index1];\n      const chain2 = chains[index2];\n      let tail = chain1[chain1.length - 1];\n      const tail2 = chain1[chain1.length - 2];\n      const head = chain2[0];\n      const head2 = chain2[1];\n\n      if (Point.colinear(tail2, tail, head)) {\n        // Tail isn't needed because it's directly between tail2 and head\n        chain1.pop();\n        tail = tail2; // old tail is gone... new tail is what tail2 was\n      }\n\n      if (Point.colinear(tail, head, head2)) {\n        // Head isn't needed because it's directly between tail and head2\n        chain2.shift();\n      }\n\n      chains[index1] = chain1.concat(chain2);\n      chains.splice(index2, 1);\n    }\n\n    const F = firstMatch.index;\n    const S = secondMatch.index;\n\n    const reverseF = chains[F].length < chains[S].length;  // Reverse the shorter chain\n    if (firstMatch.matchesHead) {\n      if (secondMatch.matchesHead) {\n        if (reverseF) {\n          reverseChain(F);\n          appendChain(F, S);\n        } else {\n          reverseChain(S);\n          appendChain(S, F);\n        }\n      } else {\n        appendChain(S, F);\n      }\n    } else {\n      if (secondMatch.matchesHead) {\n        appendChain(F, S);\n      } else {\n        if (reverseF) {\n          reverseChain(F);\n          appendChain(S, F);\n        } else {\n          reverseChain(S);\n          appendChain(F, S);\n        }\n      }\n    }\n  });\n\n  return regions;\n}\n\n\n// -----------------------------------------------------------------------------\n// Workflow\n\nfunction select(segments: Segment[], selection: number[]) {\n  const result: Segment[] = [];\n\n  for (const seg of segments) {\n    const index = (seg.myFill.above ? 8 : 0) +\n                  (seg.myFill.below ? 4 : 0) +\n                  ((seg.otherFill && seg.otherFill.above) ? 2 : 0) +\n                  ((seg.otherFill && seg.otherFill.below) ? 1 : 0);\n    if (selection[index] !== 0) {\n      result.push({\n        start: seg.start,\n        end: seg.end,\n        myFill: {above: selection[index] === 1, below: selection[index] === 2}\n      });\n    }\n  }\n\n  return result;\n}\n\nfunction segments(poly: MultiPolygon) {\n  const root = new LinkedList<Event>();\n\n  for (const region of poly) {\n    for (let i = 0; i < region.length; i++) {\n      const pt1 = i ? region[i - 1] : last(region);\n      const pt2 = region[i];\n\n      const forward = pointsCompare(pt1, pt2);\n      if (forward === 0) continue; // skip zero-length segments\n\n      const start = forward < 0 ? pt1 : pt2;\n      const end = forward < 0 ? pt2 : pt1;\n      addSegment(root, {start, end, myFill: {}}, true);\n    }\n  }\n\n  return calculate(root, true);\n}\n\nfunction operate(poly1: MultiPolygon, poly2: MultiPolygon, selection: number[]) {\n  const root = new LinkedList<Event>();\n  for (const s of segments(poly1)) addSegment(root, copy(s.start, s.end, s), true);\n  for (const s of segments(poly2)) addSegment(root, copy(s.start, s.end, s), false);\n\n  const results = select(calculate(root, false), selection);\n  return segmentChainer(results);\n}\n\n\n// -----------------------------------------------------------------------------\n// Public Exports\n\ntype MultiPolygon = Point[][];\n\nconst UNION = [0, 2, 1, 0, 2, 2, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0];\nconst INTERSECT = [0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 1, 1, 0, 2, 1, 0];\nconst DIFFERENCE = [0, 0, 0, 0, 2, 0, 2, 0, 1, 1, 0, 0, 0, 1, 2, 0];\nconst XOR = [0, 2, 1, 0, 2, 0, 0, 1, 1, 0, 0, 2, 0, 1, 2, 0];\n\nexport const union = (p1: MultiPolygon, p2: MultiPolygon) => operate(p1, p2, UNION);\nexport const intersect = (p1: MultiPolygon, p2: MultiPolygon) => operate(p1, p2, INTERSECT);\nexport const difference = (p1: MultiPolygon, p2: MultiPolygon) => operate(p1, p2, DIFFERENCE);\nexport const xor = (p1: MultiPolygon, p2: MultiPolygon) => operate(p1, p2, XOR);\n", "// =============================================================================\n// Euclid.js | Intersection utilities\n// (c) Mathigon\n// =============================================================================\n\n\nimport {flatten} from '@mathigon/core';\nimport {isBetween, nearlyEquals, square, subsets} from '@mathigon/fermat';\nimport {Arc} from './arc';\nimport {Circle} from './circle';\nimport {Line, Ray, Segment} from './line';\nimport {Point} from './point';\nimport {isAngle, isArc, isCircle, isLineLike, isPolygonLike, isRay, isSegment} from './types';\nimport {GeoShape} from './utilities';\n\n\n// -----------------------------------------------------------------------------\n// Helper functions\n\nfunction liesOnSegment(s: Segment, p: Point) {\n  if (nearlyEquals(s.p1.x, s.p2.x)) return isBetween(p.y, s.p1.y, s.p2.y);\n  return isBetween(p.x, s.p1.x, s.p2.x);\n}\n\nfunction liesOnRay(r: Ray, p: Point) {\n  if (nearlyEquals(r.p1.x, r.p2.x)) return (p.y - r.p1.y) / (r.p2.y - r.p1.y) > 0;\n  return (p.x - r.p1.x) / (r.p2.x - r.p1.x) > 0;\n}\n\nfunction liesOnArc(a: Arc, p: Point) {\n  return isBetween(a.offset(p), 0, 1);\n}\n\n\n// -----------------------------------------------------------------------------\n// Foundations\n\nfunction lineLineIntersection(l1: Line, l2: Line) {\n  const d1x = l1.p1.x - l1.p2.x;\n  const d1y = l1.p1.y - l1.p2.y;\n\n  const d2x = l2.p1.x - l2.p2.x;\n  const d2y = l2.p1.y - l2.p2.y;\n\n  const d = d1x * d2y - d1y * d2x;\n  if (nearlyEquals(d, 0)) return [];  // Colinear lines never intersect\n\n  const q1 = l1.p1.x * l1.p2.y - l1.p1.y * l1.p2.x;\n  const q2 = l2.p1.x * l2.p2.y - l2.p1.y * l2.p2.x;\n\n  const x = q1 * d2x - d1x * q2;\n  const y = q1 * d2y - d1y * q2;\n  return [new Point(x / d, y / d)];\n}\n\nfunction circleCircleIntersection(c1: Circle, c2: Circle) {\n  const d = Point.distance(c1.c, c2.c);\n\n  // Circles are separate:\n  if (d > c1.r + c2.r) return [];\n\n  // One circles contains the other:\n  if (d < Math.abs(c1.r - c2.r)) return [];\n\n  // Circles are the same:\n  if (nearlyEquals(d, 0) && nearlyEquals(c1.r, c2.r)) return [];\n\n  // Circles touch:\n  if (nearlyEquals(d, c1.r + c2.r)) return [new Line(c1.c, c2.c).midpoint];\n\n  const a = (square(c1.r) - square(c2.r) + square(d)) / (2 * d);\n  const b = Math.sqrt(square(c1.r) - square(a));\n\n  const px = (c2.c.x - c1.c.x) * a / d + (c2.c.y - c1.c.y) * b / d + c1.c.x;\n  const py = (c2.c.y - c1.c.y) * a / d - (c2.c.x - c1.c.x) * b / d + c1.c.y;\n  const qx = (c2.c.x - c1.c.x) * a / d - (c2.c.y - c1.c.y) * b / d + c1.c.x;\n  const qy = (c2.c.y - c1.c.y) * a / d + (c2.c.x - c1.c.x) * b / d + c1.c.y;\n\n  return [new Point(px, py), new Point(qx, qy)];\n}\n\n// From http://mathworld.wolfram.com/Circle-LineIntersection.html\nfunction lineCircleIntersection(l: Line, c: Circle) {\n  const dx = l.p2.x - l.p1.x;\n  const dy = l.p2.y - l.p1.y;\n  const dr2 = square(dx) + square(dy);\n\n  const cx = c.c.x;\n  const cy = c.c.y;\n  const D = (l.p1.x - cx) * (l.p2.y - cy) - (l.p2.x - cx) * (l.p1.y - cy);\n\n  const disc = square(c.r) * dr2 - square(D);\n  if (disc < 0) return [];  // No solution\n\n  const xa = D * dy / dr2;\n  const ya = -D * dx / dr2;\n  if (nearlyEquals(disc, 0)) return [c.c.shift(xa, ya)];  // One solution\n\n  const xb = dx * (dy < 0 ? -1 : 1) * Math.sqrt(disc) / dr2;\n  const yb = Math.abs(dy) * Math.sqrt(disc) / dr2;\n  return [c.c.shift(xa + xb, ya + yb), c.c.shift(xa - xb, ya - yb)];\n}\n\n\n// -----------------------------------------------------------------------------\n// Exported functions\n\nfunction simpleIntersection(a: Line|Circle|Arc, b: Line|Circle|Arc): Point[] {\n  let results: Point[] = [];\n\n  const a1 = isArc(a) ? a.circle : a;\n  const b1 = isArc(b) ? b.circle : b;\n\n  if (isLineLike(a) && isLineLike(b)) {\n    results = lineLineIntersection(a, b);\n  } else if (isLineLike(a1) && isCircle(b1)) {\n    results = lineCircleIntersection(a1, b1);\n  } else if (isCircle(a1) && isLineLike(b1)) {\n    results = lineCircleIntersection(b1, a1);\n  } else if (isCircle(a1) && isCircle(b1)) {\n    results = circleCircleIntersection(a1, b1);\n  }\n\n  for (const x of [a, b]) {\n    if (isSegment(x)) results = results.filter(i => liesOnSegment(x, i));\n    if (isRay(x)) results = results.filter(i => liesOnRay(x, i));\n    if (isArc(x)) results = results.filter(i => liesOnArc(x, i));\n  }\n\n  return results;\n}\n\n/** Returns the intersection of two or more geometry objects. */\nexport function intersections(...elements: GeoShape[]): Point[] {\n  if (elements.length < 2) return [];\n  if (elements.length > 2) {\n    return flatten(subsets(elements, 2).map(e => intersections(...e)));\n  }\n\n  let [a, b] = elements;\n\n  if (isAngle(a)) a = a.shape(true);\n  if (isAngle(b)) b = b.shape(true);\n  if (isPolygonLike(b)) [a, b] = [b, a];\n\n  if (isPolygonLike(a)) {\n    // This hack is necessary to capture intersections between a line and a\n    // vertex of a polygon. There are more edge cases to consider!\n    const results = isLineLike(b) ? a.points.filter(p => (b as Line).contains(p)) : [];\n\n    for (const e of a.edges) results.push(...intersections(e, b));\n    return results;\n  }\n\n  // TODO Handle arcs, sectors and angles!\n  return simpleIntersection(a as (Line|Circle|Arc), b as (Line|Circle|Arc));\n}\n", "// =============================================================================\n// Euclid.js | Bounds Class\n// (c) Mathigon\n// =============================================================================\n\n\nimport {isBetween} from '@mathigon/fermat';\nimport {Point} from './point';\nimport {Rectangle} from './rectangle';\n\n\nexport class Bounds {\n\n  /**\n   * Use the `errorHandling` option to decide how to deal with cases where the\n   * min and max values are in the wrong order.\n   */\n  constructor(public xMin: number, public xMax: number, public yMin: number,\n    public yMax: number, errorHandling?: 'swap'|'center') {\n    if (errorHandling === 'swap') {\n      if (this.dx < 0) [this.xMin, this.xMax] = [xMax, xMin];\n      if (this.dy < 0) [this.yMin, this.yMax] = [yMax, yMin];\n    } else if (errorHandling === 'center') {\n      if (this.dx < 0) this.xMin = this.xMax = (xMin + xMax) / 2;\n      if (this.dy < 0) this.yMin = this.yMax = (yMin + yMax) / 2;\n    }\n  }\n\n  contains(p: Point) {\n    return this.containsX(p) && this.containsY(p);\n  }\n\n  containsX(p: Point) {\n    return isBetween(p.x, this.xMin, this.xMax);\n  }\n\n  containsY(p: Point) {\n    return isBetween(p.y, this.yMin, this.yMax);\n  }\n\n  resize(dx: number, dy: number) {\n    return new Bounds(this.xMin, this.xMax + dx, this.yMin, this.yMax + dy);\n  }\n\n  get dx() {\n    return this.xMax - this.xMin;\n  }\n\n  get dy() {\n    return this.yMax - this.yMin;\n  }\n\n  get xRange(): [number, number] {\n    return [this.xMin, this.xMax];\n  }\n\n  get yRange(): [number, number] {\n    return [this.yMin, this.yMax];\n  }\n\n  extend(top: number, right = top, bottom = top, left = right) {\n    return new Bounds(this.xMin - left, this.xMax + right, this.yMin - top, this.yMax + bottom);\n  }\n\n  get rect() {\n    return new Rectangle(new Point(this.xMin, this.yMin), this.dx, this.dy);\n  }\n\n  get center() {\n    return new Point(this.xMin + this.dx / 2, this.yMin + this.dy / 2);\n  }\n\n  get flip() {\n    return new Bounds(this.yMin, this.yMax, this.xMin, this.xMax);\n  }\n}\n", "// =============================================================================\n// Euclid.js | Reactangle Class\n// (c) Mathigon\n// =============================================================================\n\n\nimport {isBetween, nearlyEquals} from '@mathigon/fermat';\nimport {Bounds} from './bounds';\nimport {Line} from './line';\nimport {ORIGIN, Point} from './point';\nimport {Polygon} from './polygon';\nimport {GeoShape, SimplePoint, TransformMatrix} from './utilities';\n\n\n/** A rectangle, defined by its top left vertex, width and height. */\nexport class Rectangle implements GeoShape {\n  readonly type = 'rectangle';\n\n  constructor(readonly p: Point, readonly w = 1, readonly h = w) {}\n\n  /** Creates the smallest rectangle containing all given points. */\n  static aroundPoints(points: Iterable<SimplePoint>) {\n    let xMin = Infinity;\n    let xMax = -Infinity;\n    let yMin = Infinity;\n    let yMax = -Infinity;\n\n    for (const p of points) {\n      xMin = xMin < p.x ? xMin : p.x;\n      xMax = xMax > p.x ? xMax : p.x;\n      yMin = yMin < p.y ? yMin : p.y;\n      yMax = yMax > p.y ? yMax : p.y;\n    }\n\n    return new Rectangle(new Point(xMin, yMin), xMax - xMin, yMax - yMin);\n  }\n\n  get center() {\n    return new Point(this.p.x + this.w / 2, this.p.y + this.h / 2);\n  }\n\n  get centroid() {\n    return this.center;\n  }\n\n  get circumference() {\n    return 2 * Math.abs(this.w) + 2 * Math.abs(this.h);\n  }\n\n  get area() {\n    return Math.abs(this.signedArea);\n  }\n\n  get signedArea() {\n    return this.w * this.h;\n  }\n\n  /** @returns {Segment[]} */\n  get edges() {\n    return this.polygon.edges;\n  }\n\n  /** @returns {Point[]} */\n  get points() {\n    return this.polygon.points;\n  }\n\n  /** A polygon class representing this rectangle. */\n  get polygon() {\n    const b = new Point(this.p.x + this.w, this.p.y);\n    const c = new Point(this.p.x + this.w, this.p.y + this.h);\n    const d = new Point(this.p.x, this.p.y + this.h);\n    return new Polygon(this.p, b, c, d);\n  }\n\n  get bounds() {\n    return new Bounds(this.p.x, this.p.x + this.w, this.p.y, this.p.y + this.h);\n  }\n\n  collision(r: Rectangle) {\n    return (this.p.x < r.p.x + r.w && this.p.x + this.w > r.p.x &&\n            this.p.y < r.p.y + r.h && this.p.y + this.h > r.p.y);\n  }\n\n  padding(top: number, right: number, bottom: number, left: number) {\n    return new Rectangle(this.p.shift(-left, -top), this.w + left + right, this.h + top + bottom);\n  }\n\n  get unsigned(): Rectangle {\n    if (this.w > 0 && this.h > 0) return this;\n    const p = this.p.shift(this.w < 0 ? this.w : 0, this.h < 0 ? this.h : 0);\n    return new Rectangle(p, Math.abs(this.w), Math.abs(this.h));\n  }\n\n  // ---------------------------------------------------------------------------\n\n  contains(p: Point, tolerance?: number) {\n    return isBetween(p.x, this.p.x, this.p.x + this.w, tolerance) &&\n           isBetween(p.y, this.p.y, this.p.y + this.h, tolerance);\n  }\n\n  project(p: SimplePoint): Point {\n    let q: Point|undefined = undefined;\n\n    for (const e of this.edges) {\n      const q1 = e.project(p);\n      if (!q || Point.distance(p, q1) < Point.distance(p, q)) q = q1;\n    }\n\n    return q!;\n  }\n\n  at(t: number) {\n    return this.polygon.at(t);\n  }\n\n  offset(p: Point) {\n    return this.polygon.offset(p);\n  }\n\n  cut(line: Line) {\n    return this.polygon.cut(line);\n  }\n\n  get oriented() {\n    return this.polygon.oriented;\n  }\n\n  // ---------------------------------------------------------------------------\n\n  transform(m: TransformMatrix) {\n    return this.polygon.transform(m);\n  }\n\n  /** Rotates this rectangle by a given angle (in radians), optionally around point `c`. */\n  rotate(a: number, c = ORIGIN) {\n    if (nearlyEquals(a, 0)) return this;\n    return this.polygon.rotate(a, c);\n  }\n\n  reflect(l: Line) {\n    return this.polygon.reflect(l);\n  }\n\n  scale(sx: number, sy = sx) {\n    return new Rectangle(this.p.scale(sx, sy), this.w * sx, this.h * sy);\n  }\n\n  shift(x: number, y = x) {\n    return new Rectangle(this.p.shift(x, y), this.w, this.h);\n  }\n\n  translate(p: SimplePoint) {\n    return this.shift(p.x, p.y);\n  }\n\n  equals(_other: Polygon) {\n    // TODO Implement\n    return false;\n  }\n\n  toString() {\n    return `rectangle(${this.p},${this.w},${this.h})`;\n  }\n}\n", "// =============================================================================\n// Euclid.js | Canvas Drawing Tools\n// (c) Mathigon\n// =============================================================================\n\n\nimport {intersections} from './intersection';\nimport {Rectangle} from './rectangle';\nimport {isAngle, isCircle, isEllipse, isLineLike, isPolygonLike, isPolyline, isRay, isSegment} from './types';\nimport {GeoElement, TWO_PI} from './utilities';\n\n\nexport interface CanvasDrawingOptions {\n  fill?: string;\n  opacity?: number;\n  stroke?: string;\n  strokeWidth?: number;\n  lineCap?: CanvasLineCap;\n  lineJoin?: CanvasLineJoin;\n  box?: Rectangle;\n}\n\ntype CanvasLineCap = 'butt' | 'round' | 'square';\ntype CanvasLineJoin = 'bevel' | 'miter' | 'round';\n\n\nexport function drawCanvas(ctx: CanvasRenderingContext2D, obj: GeoElement, options: CanvasDrawingOptions = {}): void {\n  if (isAngle(obj)) return drawCanvas(ctx, obj.shape(!!options.fill), options);\n\n  if (options.fill) ctx.fillStyle = options.fill;\n  if (options.opacity) ctx.globalAlpha = options.opacity;\n\n  if (options.stroke) {\n    ctx.strokeStyle = options.stroke;\n    ctx.lineWidth = options.strokeWidth || 1;\n    if (options.lineCap) ctx.lineCap = options.lineCap;\n    if (options.lineJoin) ctx.lineJoin = options.lineJoin;\n  }\n\n  ctx.beginPath();\n\n  if (isSegment(obj)) {\n    ctx.moveTo(obj.p1.x, obj.p1.y);\n    ctx.lineTo(obj.p2.x, obj.p2.y);\n\n  } else if (isLineLike(obj)) {\n    if (!options.box) return;\n    let [start, end] = intersections(obj, options.box);\n    if (isRay(obj)) end = obj.p1;\n    if (!start || !end) return;\n    ctx.moveTo(start.x, start.y);\n    ctx.lineTo(end.x, end.y);\n\n  } else if (isCircle(obj)) {\n    ctx.arc(obj.c.x, obj.c.y, obj.r, 0, TWO_PI);\n\n  } else if (isPolygonLike(obj)) {\n    const points = obj.points;\n    ctx.moveTo(points[0].x, points[0].y);\n    for (const p of points.slice(1)) ctx.lineTo(p.x, p.y);\n    ctx.closePath();\n\n  } else if (isPolyline(obj)) {\n    ctx.moveTo(obj.points[0].x, obj.points[0].y);\n    for (const p of obj.points.slice(1)) ctx.lineTo(p.x, p.y);\n\n  } else if (isEllipse(obj)) {\n    ctx.ellipse(obj.c.x, obj.c.y, obj.a, obj.b, obj.angle, 0, TWO_PI);\n  }\n\n  // TODO Support for Line, Ray, Arc and Sector objects\n\n  if (options.fill) ctx.fill();\n  if (options.stroke) ctx.stroke();\n}\n", "// =============================================================================\n// Euclid.js | SVG Drawing Tools\n// (c) Mathigon\n// =============================================================================\n\n\nimport {isOneOf} from '@mathigon/core';\nimport {toDeg} from './angle';\nimport {Arc} from './arc';\nimport {intersections} from './intersection';\nimport {Line} from './line';\nimport {Point} from './point';\nimport {Rectangle} from './rectangle';\nimport {isAngle, isArc, isCircle, isEllipse, isLine, isPolygon, isPolyline, isRay, isRectangle, isSector, isSegment} from './types';\nimport {GeoElement} from './utilities';\n\n\nexport type LineMark = 'bar'|'bar2'|'arrow'|'arrow2';\nexport type LineArrow = 'start'|'end'|'both';\n\nexport interface SVGDrawingOptions {\n  round?: boolean;  // For angles (round vs square right angles)\n  size?: number;  // For angles\n  fill?: string;  // For angles (stroke arc vs fill sector)\n  mark?: LineMark;  // For lines, rays, segments and arcs\n  arrows?: LineArrow;  // For segments and arcs\n  box?: Rectangle;  // For lines and rays (bounding box)\n  cornerRadius?: number;  // For rectangles and polygons\n}\n\n\n// -----------------------------------------------------------------------------\n// Utility Functions\n\n/** Draws an arc from a to c, with center b. */\nfunction drawArc(a: Point, b: Point, c: Point) {\n  const orient = b.x * (c.y - a.y) + a.x * (b.y - c.y) + c.x * (a.y - b.y);\n  const sweep = (orient > 0) ? 1 : 0;\n  const size = Point.distance(b, a);\n  return [a.x, `${a.y}A${size}`, size, 0, sweep, 1, c.x, c.y].join(',');\n}\n\nfunction drawPath(...points: Point[]) {\n  return `M${points.map(p => `${p.x},${p.y}`).join('L')}`;\n}\n\n\n// -----------------------------------------------------------------------------\n// Arrows and Line Marks\n\nfunction drawLineMark(x: Line, type: LineMark) {\n  const p = x.perpendicularVector.scale(6);\n  const n = x.unitVector.scale(3);\n  const m = x.midpoint;\n\n  switch (type) {\n    case 'bar':\n      return drawPath(m.add(p), m.add(p.inverse));\n    case 'bar2':\n      return drawPath(m.add(n).add(p), m.add(n).add(p.inverse)) +\n             drawPath(m.add(n.inverse).add(p), m.add(n.inverse).add(p.inverse));\n    case 'arrow':\n      return drawPath(m.add(n.inverse).add(p), m.add(n),\n        m.add(n.inverse).add(p.inverse));\n    case 'arrow2':\n      return drawPath(m.add(n.scale(-2)).add(p), m,\n        m.add(n.scale(-2)).add(p.inverse)) +\n             drawPath(m.add(p), m.add(n.scale(2)), m.add(p.inverse));\n    default:\n      return '';\n  }\n}\n\nfunction arrowPath(start: Point, normal: Point) {\n  if (!start || !normal) return '';\n  const perp = normal.perpendicular;\n  const a = start.add(normal.scale(9)).add(perp.scale(9));\n  const b = start.add(normal.scale(9)).add(perp.scale(-9));\n  return drawPath(a, start, b);\n}\n\nfunction drawLineArrows(x: Line, type: LineArrow) {\n  let path = '';\n  if (isOneOf(type, 'start', 'both')) {\n    path += arrowPath(x.p1, x.unitVector);\n  }\n  if (isOneOf(type, 'end', 'both')) {\n    path += arrowPath(x.p2, x.unitVector.inverse);\n  }\n  return path;\n}\n\nfunction drawArcArrows(x: Arc, type: LineArrow) {\n  let path = '';\n\n  if (isOneOf(type, 'start', 'both')) {\n    const normal = new Line(x.c, x.start).perpendicularVector.inverse;\n    path += arrowPath(x.start, normal);\n  }\n\n  if (isOneOf(type, 'end', 'both')) {\n    const normal = new Line(x.c, x.end).perpendicularVector;\n    path += arrowPath(x.end, normal);\n  }\n\n  return path;\n}\n\n// top-left, top-right, btm-right, btm-left corner radius\nexport function drawRoundedRect(rect: Rectangle, tl: number, tr = tl, br = tl, bl = tr) {\n  const {p, w, h} = rect;\n  return `M${p.x} ${p.y + tl}a${tl} ${tl} 0 0 1 ${tl} ${-tl}h${w - tl - tr}a${tr} ${tr} 0 0 1 ${tr} ${tr}v${h - tr - br}a${br} ${br} 0 0 1 ${-br} ${br}h${-w + bl + br}a${bl} ${bl} 0 0 1 ${-bl} ${-bl}Z`;\n}\n\n\n// -----------------------------------------------------------------------------\n// Draw Function\n\nexport function drawSVG(obj: GeoElement, options: SVGDrawingOptions = {}): string {\n\n  if (isAngle(obj)) {\n    const shape = obj.shape(!!options.fill, options.size, options.round);\n    return drawSVG(shape, options);\n  }\n\n  if (isSegment(obj)) {\n    if (obj.p1.equals(obj.p2)) return '';\n    let line = drawPath(obj.p1, obj.p2);\n    if (options.mark) line += drawLineMark(obj, options.mark);\n    if (options.arrows) line += drawLineArrows(obj, options.arrows);\n    return line;\n  }\n\n  if (isRay(obj)) {\n    if (!options.box) return '';\n    const end = intersections(obj, options.box)[0];\n    if (!end) return '';\n    let line = drawPath(obj.p1, end);\n    if (options.mark) line += drawLineMark(obj, options.mark);\n    return line;\n  }\n\n  if (isLine(obj)) {\n    if (!options.box) return '';\n    const points = intersections(obj, options.box);\n    if (points.length < 2) return '';\n    let line = drawPath(points[0], points[1]);\n    if (options.mark) line += drawLineMark(obj, options.mark);\n    return line;\n  }\n\n  if (isCircle(obj)) {\n    return `M${obj.c.x - obj.r} ${obj.c.y}a${obj.r},${obj.r} 0 1 0 ` +\n           `${2 * obj.r} 0a${obj.r} ${obj.r} 0 1 0 ${-2 * obj.r} 0Z`;\n  }\n\n  if (isEllipse(obj)) {\n    const [u, v] = obj.majorVertices;\n    const rot = toDeg(obj.angle);\n    return `M${u.x} ${u.y}A${obj.a} ${obj.b} ${rot} 0 0 ${v.x} ${v.y}A${obj.a} ${obj.b} ${rot} 0 0 ${u.x} ${u.y}Z`;\n  }\n\n  if (isArc(obj)) {\n    let path = `M${drawArc(obj.start, obj.c, obj.end)}`;\n    if (options.arrows) path += drawArcArrows(obj, options.arrows);\n    return path;\n  }\n\n  if (isSector(obj)) {\n    return `M${obj.c.x} ${obj.c.y} L ${drawArc(obj.start, obj.c, obj.end)}Z`;\n  }\n\n  if (isPolyline(obj)) {\n    return drawPath(...obj.points);\n  }\n\n  if (isPolygon(obj)) {\n    // TODO Implement `options.cornerRadius`\n    return `${drawPath(...obj.points)}Z`;\n  }\n\n  if (isRectangle(obj)) {\n    if (!options.cornerRadius) return `${drawPath(...obj.polygon.points)}Z`;\n    const rect = obj.unsigned;\n    const radius = Math.min(options.cornerRadius, rect.w / 2, rect.h / 2);\n    return drawRoundedRect(rect, radius);\n  }\n\n  return '';\n}\n", "// =============================================================================\n// Euclid.js | Ellipse Class\n// (c) Mathigon\n// =============================================================================\n\n\nimport {nearlyEquals, quadratic} from '@mathigon/fermat';\nimport {Angle} from './angle';\nimport {Line} from './line';\nimport {ORIGIN, Point} from './point';\nimport {GeoShape, SimplePoint, TransformMatrix, TWO_PI} from './utilities';\n\n\nexport class Ellipse implements GeoShape {\n  readonly type = 'ellipse';\n  readonly a: number;\n  readonly b: number;\n  readonly angle: number;\n  readonly f1: Point;\n  readonly f2: Point;\n\n  /**\n   * @param c Center of the ellipse\n   * @param a Major axis\n   * @param b Minor axis\n   * @param angle The rotation of the major axis of the ellipse.\n   */\n  constructor(readonly c: Point, a: number, b: number, angle = 0) {\n    if (a < b) {\n      [a, b] = [b, a];\n      angle += Math.PI / 2;\n    }\n    this.a = a;\n    this.b = b;\n    this.angle = angle;\n\n    const f = Math.sqrt(a ** 2 - b ** 2);  // Distance from focus to the center.\n    this.f1 = this.c.add(new Point(-f, 0).rotate(angle));\n    this.f2 = this.c.add(new Point(f, 0).rotate(angle));\n  }\n\n  get rx() {\n    return nearlyEquals(this.angle, 0) ? this.a : nearlyEquals(this.angle, Math.PI / 2) ? this.b : undefined;\n  }\n\n  get ry() {\n    return nearlyEquals(this.angle, 0) ? this.b : nearlyEquals(this.angle, Math.PI / 2) ? this.a : undefined;\n  }\n\n  normalAt(p: Point) {\n    return new Angle(this.f1, p, this.f2).bisector!;\n  }\n\n  /** Intersection between an ellipse and a line. */\n  intersect(line: Line) {\n    line = line.rotate(-this.angle, this.c);\n\n    const dx = line.p1.x - line.p2.x;\n    const dy = line.p1.y - line.p2.y;\n\n    const px = this.c.x - line.p1.x;\n    const py = this.c.y - line.p1.y;\n\n    const A = (dx / this.a) ** 2 + (dy / this.b) ** 2;\n    const B = (2 * px * dx) / this.a ** 2 + (2 * py * dy) / this.b ** 2;\n    const C = (px / this.a) ** 2 + (py / this.b) ** 2 - 1;\n\n    const points = quadratic(A, B, C);\n    return points.map((t) => line.at(t).rotate(this.angle, this.c));\n  }\n\n  /**\n   * Creates a new Ellipse. StringLength is the length of string from one foci\n   * to a point on the circumference, to the other foci.\n   */\n  static fromFoci(f1: Point, f2: Point, stringLength: number) {\n    const c = Point.distance(f1, f2) / 2;  // Half distance between foci.\n    const a = stringLength / 2;\n    const b = Math.sqrt(a ** 2 - c ** 2);\n    const angle = new Line(f1, f2).angle;\n    return new Ellipse(Point.interpolate(f1, f2), a, b, angle);\n  }\n\n  // ---------------------------------------------------------------------------\n\n  get majorVertices() {\n    return [this.c.add(new Point(-this.a, 0).rotate(this.angle)),\n      this.c.add(new Point(this.a, 0).rotate(this.angle))];\n  }\n\n  get minorVertices() {\n    return [this.c.add(new Point(0, -this.b).rotate(this.angle)),\n      this.c.add(new Point(0, this.b).rotate(this.angle))];\n  }\n\n  get extremes(): Point[] {\n    // See https://math.stackexchange.com/questions/4457548/find-extreme-values-of-ellipse\n    const {a, b, angle} = this;\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n\n    const sqSum = a**2 + b**2;\n    const sqDiff = (a**2 - b**2) * Math.cos(2 * angle);\n\n    const yMax = Math.sqrt((sqSum - sqDiff) / 2);\n    const xAtYMax = yMax * sqSum * sin * cos / (a**2 * sin**2 + b**2 * cos**2);\n\n    const xMax = Math.sqrt((sqSum + sqDiff) / 2);\n    const yAtXMax = xMax * sqSum * sin * cos / (a**2 * cos**2 + b**2 * sin**2);\n\n    return [new Point(xAtYMax, yMax).add(this.c),\n      new Point(xAtYMax, yMax).inverse.add(this.c),\n      new Point(xMax, yAtXMax).add(this.c),\n      new Point(xMax, yAtXMax).inverse.add(this.c)];\n  }\n\n  project(p: Point) {\n    p = p.rotate(-this.angle, this.c);\n    const th = p.angle(this.c);\n    return this.at(th / TWO_PI);\n  }\n\n  at(t: number) {\n    const th = TWO_PI * t;\n    return this.c\n      .shift(this.a * Math.cos(th), this.b * Math.sin(th))\n      .rotate(this.angle, this.c);\n  }\n\n  offset(_p: Point) {\n    // TODO Implement\n    return 0.5;\n  }\n\n  contains(p: Point) {\n    const cos = Math.cos(this.angle);\n    const sin = Math.sin(this.angle);\n\n    const A = cos ** 2 / this.a ** 2 + sin ** 2 / this.b ** 2;\n    const B = 2 * cos * sin * (1 / this.a ** 2 - 1 / this.b ** 2);\n    const C = sin ** 2 / this.a ** 2 + cos ** 2 / this.b ** 2;\n    return A * p.x ** 2 + B * p.x * p.y + C * p.y ** 2 <= 1;\n  }\n\n  // ---------------------------------------------------------------------------\n\n  transform(_m: TransformMatrix): this {\n    // TODO Implement\n    return this;\n  }\n\n  rotate(a: number, c = ORIGIN) {\n    const l = new Line(this.f1, this.f2).rotate(a, c);\n    return Ellipse.fromFoci(l.p1, l.p2, this.a * 2);\n  }\n\n  reflect(l: Line) {\n    const axis = new Line(this.f1, this.f2).reflect(l);\n    return Ellipse.fromFoci(axis.p1, axis.p2, this.a * 2);\n  }\n\n  scale(sx: number, sy = sx) {\n    return new Ellipse(this.c.scale(sx, sy), this.a * sx, this.b * sy, this.angle);\n  }\n\n  shift(x: number, y = x) {\n    return new Ellipse(this.c.shift(x, y), this.a, this.b, this.angle);\n  }\n\n  translate(p: SimplePoint) {\n    return new Ellipse(this.c.translate(p), this.a, this.b, this.angle);\n  }\n\n  equals(other: Ellipse, tolerance?: number) {\n    return (\n      nearlyEquals(this.a, other.a, tolerance) &&\n      nearlyEquals(this.b, other.b, tolerance) &&\n      nearlyEquals(this.angle, other.angle, tolerance) &&\n      this.c.equals(other.c, tolerance)\n    );\n  }\n\n  toString() {\n    return `ellipse(${this.c},${this.a},${this.b},${this.angle})`;\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_fermat", "import_fermat", "import_fermat", "import_fermat", "import_fermat", "import_core", "import_fermat", "import_core", "import_fermat", "last", "segments", "checkBothIntersections", "eve", "import_core", "import_fermat", "total", "import_fermat", "import_fermat", "import_core", "import_fermat"]
}
