import { Interval } from './eval';
export interface MathMLArgument {
    val: ExprElement;
    toString: () => string;
}
export type CustomFunction = ((...args: number[]) => number);
export type VarMap = Record<string, number | string | Interval | ExprElement | CustomFunction>;
export type ExprMap = Record<string, ExprElement>;
export type MathMLMap = Record<string, (...args: MathMLArgument[]) => string>;
/**
 * Maths Expression
 */
export declare abstract class ExprElement {
    /** Evaluates an expression using a given map of variables and functions. */
    evaluate(_vars?: VarMap, _privateNested?: boolean): number;
    interval(vars?: VarMap, _privateNested?: boolean): Interval;
    /** Substitutes a new expression for a variable. */
    substitute(_vars?: ExprMap): ExprElement;
    /**
     * Recursively substitutes a new expression for a variable.
     * NOTE: This function does not test for cyclical dependencies, which could
     * lead to an infinite loop. You have to manually validate expressions first!
     */
    recursiveSubstitute(vars: ExprMap): ExprElement;
    /** Returns the simplest mathematically equivalent expression. */
    get simplified(): ExprElement;
    /** Returns a list of all variables used in the expression (excluding defined constants). */
    get unknowns(): string[];
    /** Returns a list of all variables used in the expression (including defined constants). */
    get variables(): string[];
    /** Returns a list of all functions called by the expression. */
    get functions(): string[];
    /** Collapses all terms into functions. */
    collapse(): ExprElement;
    /** Converts the expression to a plain text string. */
    toString(): string;
    /** Converts the expression to a MathML string. */
    toVoice(_custom?: MathMLMap): string;
    /** Converts the expression to a MathML string. */
    toMathML(_custom?: MathMLMap): string;
}
export declare class ExprNumber extends ExprElement {
    readonly n: number;
    constructor(n: number);
    evaluate(): number;
    toString(): string;
    toVoice(): string;
    toMathML(): string;
}
export declare class ExprIdentifier extends ExprElement {
    readonly i: string;
    constructor(i: string);
    evaluate(vars?: VarMap, privateNested?: boolean): number;
    interval(vars?: VarMap, privateNested?: boolean): Interval;
    toMathML(): string;
    substitute(vars?: ExprMap): ExprElement;
    get variables(): string[];
    toString(): string;
    toVoice(): string;
}
export declare class ExprString extends ExprElement {
    readonly s: string;
    constructor(s: string);
    evaluate(vars?: VarMap, privateNested?: boolean): number;
    toString(): string;
    toVoice(): string;
    toMathML(): string;
}
export declare class ExprSpace extends ExprElement {
    toString(): string;
    toMathML(): string;
}
export declare class ExprOperator extends ExprElement {
    readonly o: string;
    constructor(o: string);
    toString(): string;
    toVoice(): string;
    get functions(): string[];
    toMathML(): string;
}
