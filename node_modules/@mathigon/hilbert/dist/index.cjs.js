"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ExprElement: () => ExprElement,
  ExprError: () => ExprError,
  ExprFunction: () => ExprFunction,
  ExprIdentifier: () => ExprIdentifier,
  ExprNumber: () => ExprNumber,
  ExprOperator: () => ExprOperator,
  Expression: () => Expression,
  HILBERT_CONSTANTS: () => CONSTANTS,
  SPECIAL_IDENTIFIERS: () => SPECIAL_IDENTIFIERS,
  hasZero: () => hasZero,
  isSpecialFunction: () => isSpecialFunction,
  isWhole: () => isWhole,
  width: () => width
});
module.exports = __toCommonJS(src_exports);

// src/errors.ts
var ExprError = class _ExprError extends Error {
  constructor(name, message) {
    super(message);
    this.name = name;
  }
  // ---------------------------------------------------------------------------
  // Eval Errors
  static undefinedVariable(x) {
    return new _ExprError("EvalError", `Undefined variable \u201C${x}\u201D.`);
  }
  static undefinedFunction(x) {
    return new _ExprError("EvalError", `Undefined function \u201C${x}\u201D.`);
  }
  static uncallableExpression(x) {
    return new _ExprError("EvalError", `Cannot call \u201C${x}\u201D.`);
  }
  static evalLoop(x) {
    return new _ExprError("EvalError", `Loop in nested evaluation \u201C${x}\u201D.`);
  }
  // ---------------------------------------------------------------------------
  // Syntax Errors
  static invalidCharacter(x) {
    return new _ExprError("SyntaxError", `Unknown symbol \u201C${x}\u201D.`);
  }
  static conflictingBrackets(x) {
    return new _ExprError("SyntaxError", `Conflicting brackets \u201C${x}\u201D.`);
  }
  static unclosedBracket(x) {
    return new _ExprError("SyntaxError", `Unclosed bracket \u201C${x}\u201D.`);
  }
  static startOperator(x) {
    return new _ExprError("SyntaxError", `A term cannot start with a \u201C${x}\u201D.`);
  }
  static endOperator(x) {
    return new _ExprError("SyntaxError", `A term cannot end with a \u201C${x}\u201D.`);
  }
  static consecutiveOperators(x, y) {
    return new _ExprError(
      "SyntaxError",
      `A \u201C${x}\u201D cannot be followed by a \u201C${y}\u201D.`
    );
  }
  static invalidExpression() {
    return new _ExprError("SyntaxError", `This expression is invalid.`);
  }
};

// src/expression.ts
var import_core4 = require("@mathigon/core");
var import_fermat2 = require("@mathigon/fermat");

// src/symbols.ts
var CONSTANTS = {
  pi: Math.PI,
  \u03C0: Math.PI,
  e: Math.E
};
var BRACKETS = {
  "(": ")",
  "[": "]",
  "{": "}"
};
var SPECIAL_OPERATORS = {
  "*": "\xB7",
  "**": "\u2217",
  "//": "//",
  "+-": "\xB1",
  "\u2013": "\u2212",
  "-": "\u2212",
  "xx": "\xD7",
  "sum": "\u2211",
  "prod": "\u220F",
  "int": "\u222B",
  "del": "\u2202",
  "grad": "\u2207",
  "aleph": "\u2135",
  "not": "\xAC",
  "AA": "\u2200",
  "EE": "\u2203",
  "'": "\u2019",
  "!=": "\u2260",
  "?=": "\u225F",
  "<=": "\u2264",
  ">=": "\u2265",
  "in": "\u2208",
  "!in": "\u2209",
  "==": "\u2261",
  "~=": "\u2245",
  "~~": "\u2248",
  "sub": "\u2282",
  "sube": "\u2286",
  "prop": "\u221D",
  "oo": "\u221E",
  "cap": "\u2229",
  "cup": "\u222A",
  "<-": "\u2190",
  "->": "\u2192",
  "=>": "\u21D2",
  "<=>": "\u21D4",
  "|->": "\u21A6",
  "uarr": "\u2191",
  "darr": "\u2193",
  "lArr": "\u21D0"
};
var SPECIAL_IDENTIFIERS = {
  Gamma: "\u0393",
  Delta: "\u0394",
  Theta: "\u0398",
  Lambda: "\u039B",
  Xi: "\u039E",
  Pi: "\u03A0",
  Sigma: "\u03A3",
  Phi: "\u03A6",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u025B",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  pi: "\u03C0",
  rho: "\u03C1",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  CC: "\u2102",
  NN: "\u2115",
  QQ: "\u211A",
  RR: "\u211D",
  ZZ: "\u2124"
};
var ALPHABET = "abcdefghijklmnopqrstuvwxyz";
var LOWERCASE = ALPHABET.split("");
var UPPERCASE = ALPHABET.toUpperCase().split("");
var GREEK = Object.values(SPECIAL_IDENTIFIERS);
var IDENTIFIER_SYMBOLS = [...LOWERCASE, ...UPPERCASE, ...GREEK, "$"];
var SIMPLE_SYMBOLS = "|()[]{}\xF7,!?<>=*/+-\u2013\u2212~^_\u2026\xB0\u2022\u2225\u22A5'\u2220:%\u223C\u25B3";
var COMPLEX_SYMBOLS = Object.values(SPECIAL_OPERATORS);
var OPERATOR_SYMBOLS = [...SIMPLE_SYMBOLS, ...COMPLEX_SYMBOLS];
var FUNCTION_NAMES = {
  "_": "sub",
  "^": "sup",
  "//": "/",
  "\xF7": "/"
};
var ESCAPES = {
  "<": "&lt;",
  ">": "&gt;"
};
function escape(char) {
  return char in ESCAPES ? ESCAPES[char] : char;
}
var SPECIAL_FUNCTIONS = [
  "abs",
  "round",
  "floor",
  "ceil",
  "max",
  "min",
  "mod",
  "lcm",
  "gcd",
  "gcf",
  "log",
  "exp",
  "ln",
  "sqrt",
  "root",
  "sin",
  "cos",
  "tan",
  "sec",
  "csc",
  "cot",
  "cosec",
  "cotan",
  "arcsin",
  "arccos",
  "arctan",
  "sinh",
  "cosh",
  "tanh",
  "sech",
  "csch",
  "coth",
  "cosech"
];
function isSpecialFunction(fn) {
  return SPECIAL_FUNCTIONS.includes(fn);
}
var VOICE_STRINGS = {
  "+": "plus",
  "\u2212": "minus",
  "\xB7": "times",
  "\xD7": "times",
  "/": "over",
  "//": "divided by",
  "%": "percent",
  "!": "factorial",
  "\xB1": "plus-minus",
  "=": "equals",
  "\u2260": "does not equal",
  "\u225F": "is it equal?",
  "<": "is less than",
  ">": "is greater than",
  "\u2264": "is less than or equal to",
  "\u2265": "is greater than or equal to",
  "\u03C0": "pi",
  "\u2245": "is congruent to",
  "\u2225": "is parallel to",
  "\u22A5": "is perpendicular to"
};
for (const name of Object.keys(SPECIAL_IDENTIFIERS)) {
  VOICE_STRINGS[SPECIAL_IDENTIFIERS[name]] = name;
}

// src/parser.ts
var import_core3 = require("@mathigon/core");

// src/elements.ts
var toNumber = (x) => typeof x === "number" ? x : x[0];
var toInterval = (x) => typeof x === "number" ? [x, x] : x;
var ExprElement = class {
  /** Evaluates an expression using a given map of variables and functions. */
  evaluate(_vars = {}, _privateNested) {
    return NaN;
  }
  interval(vars = {}, _privateNested) {
    return toInterval(this.evaluate(vars));
  }
  /** Substitutes a new expression for a variable. */
  substitute(_vars = {}) {
    return this;
  }
  /**
   * Recursively substitutes a new expression for a variable.
   * NOTE: This function does not test for cyclical dependencies, which could
   * lead to an infinite loop. You have to manually validate expressions first!
   */
  recursiveSubstitute(vars) {
    const varList = Object.keys(vars);
    if (!this.unknowns.filter((v) => varList.includes(v)).length)
      return this;
    return this.substitute(vars).recursiveSubstitute(vars);
  }
  /** Returns the simplest mathematically equivalent expression. */
  get simplified() {
    return this;
  }
  /** Returns a list of all variables used in the expression (excluding defined constants). */
  get unknowns() {
    return this.variables.filter((v) => !Object.prototype.hasOwnProperty.call(CONSTANTS, v));
  }
  /** Returns a list of all variables used in the expression (including defined constants). */
  get variables() {
    return [];
  }
  /** Returns a list of all functions called by the expression. */
  get functions() {
    return [];
  }
  /** Collapses all terms into functions. */
  collapse() {
    return this;
  }
  /** Converts the expression to a plain text string. */
  toString() {
    return "";
  }
  /** Converts the expression to a MathML string. */
  toVoice(_custom = {}) {
    return "";
  }
  /** Converts the expression to a MathML string. */
  toMathML(_custom = {}) {
    return "";
  }
};
var LOOP_DETECTION = /* @__PURE__ */ new Set();
function evaluateHelper(name, vars, nested = false) {
  var _a;
  let value = (_a = vars[name]) != null ? _a : CONSTANTS[name];
  if (value === void 0)
    throw ExprError.undefinedVariable(name);
  if (typeof value === "string" || value instanceof ExprElement) {
    if (!nested)
      LOOP_DETECTION.clear();
    if (LOOP_DETECTION.has(name))
      throw ExprError.evalLoop(name);
    LOOP_DETECTION.add(name);
    if (typeof value === "string")
      value = Expression.parse(value);
    return value.evaluate(vars, true);
  } else if (typeof value === "function") {
    return value();
  } else {
    return value;
  }
}
var ExprNumber = class extends ExprElement {
  constructor(n) {
    super();
    this.n = n;
  }
  evaluate() {
    return this.n;
  }
  toString() {
    return `${this.n}`;
  }
  toVoice() {
    return `${this.n}`;
  }
  toMathML() {
    return `<mn>${this.n}</mn>`;
  }
};
var ExprIdentifier = class extends ExprElement {
  constructor(i) {
    super();
    this.i = i;
  }
  evaluate(vars = {}, privateNested) {
    return toNumber(evaluateHelper(this.i, vars, privateNested));
  }
  interval(vars = {}, privateNested) {
    return toInterval(evaluateHelper(this.i, vars, privateNested));
  }
  toMathML() {
    const variant = isSpecialFunction(this.i) ? ' mathvariant="normal"' : "";
    return `<mi${variant}>${this.i}</mi>`;
  }
  substitute(vars = {}) {
    return vars[this.i] || this;
  }
  get variables() {
    return [this.i];
  }
  toString() {
    return this.i;
  }
  toVoice() {
    if (this.i in VOICE_STRINGS)
      return VOICE_STRINGS[this.i];
    if (this.i.length === 1)
      return `_${this.i}_`;
    return this.i;
  }
};
var ExprString = class extends ExprElement {
  constructor(s) {
    super();
    this.s = s;
  }
  evaluate(vars = {}, privateNested) {
    return toNumber(evaluateHelper(this.s, vars, privateNested));
  }
  toString() {
    return `"${this.s}"`;
  }
  toVoice() {
    return this.s;
  }
  toMathML() {
    return `<mtext>${this.s}</mtext>`;
  }
};
var ExprSpace = class extends ExprElement {
  toString() {
    return " ";
  }
  toMathML() {
    return `<mspace></mspace>`;
  }
};
var ExprOperator = class extends ExprElement {
  constructor(o) {
    super();
    this.o = o;
  }
  toString() {
    return this.o.replace("//", "/");
  }
  toVoice() {
    return VOICE_STRINGS[this.o] || this.o;
  }
  get functions() {
    return [this.o];
  }
  toMathML() {
    const op = escape(this.toString());
    return `<mo value="${op}">${op}</mo>`;
  }
};

// src/functions.ts
var import_core2 = require("@mathigon/core");

// src/eval.ts
var import_core = require("@mathigon/core");
var import_fermat = require("@mathigon/fermat");
var WHOLE = [-Infinity, Infinity];
var EMPTY = [NaN, NaN];
var HALF_PI = Math.PI / 2;
var TWO_PI = Math.PI * 2;
var int = (a, b) => [a - Number.EPSILON, b + Number.EPSILON];
var range = (...args) => int(Math.min(...args), Math.max(...args));
var width = (a) => Math.abs(a[1] - a[0]);
var isWhole = (a) => a[0] === -Infinity && a[1] === Infinity;
var isEmpty = (a) => isNaN(a[0]) || isNaN(a[1]);
var isInfinite = (a) => !isFinite(a[0]) && a[0] === a[1];
var contains = (a, v) => (0, import_fermat.isBetween)(v, a[0] - Number.EPSILON, a[1] + Number.EPSILON);
var hasZero = (a) => contains(a, 0);
var evaluate = {
  add: (...args) => args.reduce((a, b) => a + b, 0),
  sub: (...args) => args.length > 1 ? args[0] - args[1] : -args[0],
  mul: (...args) => args.reduce((a, b) => a * b, 1),
  div: (a, b) => a / b,
  abs: (a) => Math.abs(a),
  round: (a) => Math.round(a),
  floor: (a) => Math.floor(a),
  ceil: (a) => Math.ceil(a),
  max: (...args) => Math.max(...args),
  min: (...args) => Math.min(...args),
  mod: (a, b) => a % b,
  lcm: (...args) => (0, import_fermat.lcm)(...args),
  gcd: (...args) => (0, import_fermat.gcd)(...args),
  gcf: (...args) => (0, import_fermat.gcd)(...args),
  sup: (a, b) => Math.pow(a, b),
  log: (a, b) => Math.log(a) / (b === void 0 ? 1 : Math.log(b)),
  exp: (a) => Math.exp(a),
  ln: (a) => Math.log(a),
  sqrt: (a) => Math.sqrt(a),
  root: (a, b) => Math.pow(a, 1 / b),
  sin: (a) => Math.sin(a),
  cos: (a) => Math.cos(a),
  tan: (a) => Math.tan(a),
  sec: (a) => 1 / Math.cos(a),
  csc: (a) => 1 / Math.sin(a),
  cot: (a) => 1 / Math.tan(a),
  cosec: (a) => evaluate.csc(a),
  cotan: (a) => evaluate.cot(a),
  arcsin: (a) => Math.asin(a),
  arccos: (a) => Math.acos(a),
  arctan: (a) => Math.atan(a),
  sinh: (a) => Math.sinh(a),
  cosh: (a) => Math.cosh(a),
  tanh: (a) => Math.tanh(a),
  sech: (a) => 1 / Math.cosh(a),
  csch: (a) => 1 / Math.sinh(a),
  coth: (a) => 1 / Math.tanh(a),
  cosech: (a) => evaluate.csch(a)
};
function pow(a, b) {
  if (a[0] > 0) {
    if (b[0] >= 0)
      return int(a[0] ** b[0], a[1] ** b[1]);
    return range(a[0] ** b[0], a[0] ** b[1], a[1] ** b[0], a[1] ** b[1]);
  }
  const k = b[0];
  if (Number.isInteger(k) && k === b[1]) {
    if (k === 0)
      return [hasZero(a) ? 0 : 1, 1];
    if (k % 2)
      return int(a[0] ** k, a[1] ** k);
    if (hasZero(a))
      return [0, Math.max(a[0] ** k, a[1] ** k)];
    return range(a[1] ** k, a[0] ** k);
  }
  return EMPTY;
}
function intervalMod(a, m = TWO_PI) {
  const d = Math.floor(a[0] / m) * m;
  return [a[0] - d, a[1] - d];
}
var interval = {
  add: (...args) => int((0, import_core.total)(args.map((a) => a[0])), (0, import_core.total)(args.map((a) => a[1]))),
  sub: (a, b) => b !== void 0 ? int(a[0] - b[1], a[1] - b[0]) : int(-a[1], -a[0]),
  mul: (a, ...b) => {
    if (b.length > 1)
      b = [interval.mul(...b)];
    return range(a[0] * b[0][0], a[0] * b[0][1], a[1] * b[0][0], a[1] * b[0][1]);
  },
  div: (a, b) => hasZero(b) ? WHOLE : range(a[0] / b[0], a[0] / b[1], a[1] / b[0], a[1] / b[1]),
  abs: (a) => {
    if (hasZero(a))
      return int(0, Math.max(-a[0], a[1]));
    return range(Math.abs(a[0]), Math.abs(a[1]));
  },
  round: (a) => int(Math.round(a[0]), Math.round(a[1])),
  floor: (a) => int(Math.floor(a[0]), Math.floor(a[1])),
  ceil: (a) => int(Math.ceil(a[0]), Math.ceil(a[1])),
  max: (...args) => int(Math.max(...args.map((a) => a[0])), Math.max(...args.map((a) => a[1]))),
  min: (...args) => int(Math.min(...args.map((a) => a[0])), Math.min(...args.map((a) => a[1]))),
  mod: (a, b) => {
    if (isEmpty(a) || isEmpty(b))
      return EMPTY;
    let n = a[0] / (a[0] < 0 ? b[0] : b[1]);
    n = n < 0 ? Math.ceil(n) : Math.floor(n);
    return interval.sub(a, interval.mul(b, [n, n]));
  },
  lcm: (...args) => range((0, import_fermat.lcm)(...args.map((a) => a[0]))),
  // TODO Review this!
  gcd: (...args) => range((0, import_fermat.gcd)(...args.map((a) => a[0]))),
  // TODO Review this!
  gcf: (...args) => interval.gcd(...args),
  sup: (a, b) => pow(a, b),
  log: (a, b) => {
    if (b !== void 0)
      interval.div(interval.log(a), interval.log(b));
    return int(a[0] <= 0 ? -Infinity : Math.log(a[0]), Math.log(a[1]));
  },
  exp: (a) => pow([Math.E, Math.E], a),
  ln: (a) => interval.log(a),
  sqrt: (a) => pow(a, [0.5, 0.5]),
  root: (a, b) => pow(a, interval.div([1, 1], b)),
  sin: (a) => interval.cos(interval.sub(a, [HALF_PI, HALF_PI])),
  cos: (a) => {
    if (isEmpty(a) || isInfinite(a))
      return EMPTY;
    if (width(a) >= TWO_PI - Number.EPSILON)
      return [-1, 1];
    a = intervalMod(a);
    if (a[0] > Math.PI + Number.EPSILON)
      return interval.sub(interval.cos(interval.sub(a, [Math.PI, Math.PI])));
    if (a[1] < Math.PI - Number.EPSILON)
      return int(Math.cos(a[1]), Math.cos(a[0]));
    if (a[1] < TWO_PI - Number.EPSILON)
      return int(-1, Math.max(Math.cos(a[1]), Math.cos(a[0])));
    return int(-1, 1);
  },
  tan: (a) => {
    if (isEmpty(a) || isInfinite(a))
      return EMPTY;
    a = intervalMod(a, Math.PI);
    if (a[0] > HALF_PI + Number.EPSILON)
      a = interval.sub(a, [Math.PI, Math.PI]);
    if (a[0] < -HALF_PI + Number.EPSILON || a[1] > HALF_PI - Number.EPSILON)
      return WHOLE;
    return int(Math.tan(a[0]), Math.tan(a[1]));
  },
  sec: (a) => interval.div([1, 1], interval.cos(a)),
  csc: (a) => interval.div([1, 1], interval.sin(a)),
  cot: (a) => interval.div([1, 1], interval.tan(a)),
  cosec: (a) => interval.csc(a),
  cotan: (a) => interval.cot(a),
  arcsin: (a) => {
    if (isEmpty(a) || a[1] < -1 || a[0] > 1)
      return EMPTY;
    return int(a[0] <= -1 ? -HALF_PI : Math.asin(a[0]), a[1] >= 1 ? HALF_PI : Math.asin(a[1]));
  },
  arccos: (a) => {
    if (isEmpty(a) || a[1] < -1 || a[0] > 1)
      return EMPTY;
    return int(a[1] >= 1 ? 0 : Math.acos(a[1]), a[0] <= -1 ? Math.PI : Math.acos(a[0]));
  },
  arctan: (a) => int(Math.atan(a[0]), Math.atan(a[1])),
  sinh: (a) => int(Math.sinh(a[0]), Math.sinh(a[1])),
  cosh: (a) => {
    if (a[1] < 0)
      return int(Math.cosh(a[1]), Math.cosh(a[0]));
    if (a[0] > 0)
      return int(Math.cosh(a[0]), Math.cosh(a[1]));
    return int(1, Math.cosh(Math.max(-a[0], a[1])));
  },
  tanh: (a) => int(Math.tanh(a[0]), Math.tanh(a[1])),
  sech: (a) => interval.div([1, 1], interval.cosh(a)),
  csch: (a) => interval.div([1, 1], interval.sinh(a)),
  coth: (a) => interval.div([1, 1], interval.tanh(a)),
  cosech: (a) => interval.csch(a)
};

// src/functions.ts
var PRECEDENCE = (0, import_core2.words)("+ \u2212 * \xD7 \xB7 / \xF7 // sup sub subsup");
var SUBSUP = (0, import_core2.words)("sub sup subsup");
var COMMA = '<mo value="," lspace="0">,</mo>';
function needsBrackets(expr, parentFn) {
  if (!PRECEDENCE.includes(parentFn))
    return false;
  if (expr instanceof ExprTerm)
    return true;
  if (!(expr instanceof ExprFunction))
    return false;
  if (!PRECEDENCE.includes(expr.fn))
    return false;
  if (SUBSUP.includes(expr.fn) && SUBSUP.includes(parentFn))
    return true;
  return PRECEDENCE.indexOf(parentFn) > PRECEDENCE.indexOf(expr.fn);
}
function addMFence(expr, fn, string) {
  return needsBrackets(expr, fn) ? `<mfenced>${string}</mfenced>` : string;
}
function addMRow(expr, string) {
  const needsRow = expr instanceof ExprTerm || expr instanceof ExprFunction;
  return needsRow ? `<mrow>${string}</mrow>` : string;
}
function supVoice(a) {
  return a === "2" ? "squared" : a === "3" ? "cubed" : `to the power of ${a}`;
}
var ExprFunction = class _ExprFunction extends ExprElement {
  constructor(fn, args = []) {
    super();
    this.fn = fn;
    this.args = args;
  }
  evaluate(vars = {}) {
    const args = this.args.map((a) => a.evaluate(vars));
    if (this.fn in vars) {
      const fn = vars[this.fn];
      if (typeof fn === "function")
        return fn(...args);
      if (typeof fn === "number" && args.length === 1)
        return evaluate.mul(fn, args[0]);
      throw ExprError.uncallableExpression(this.fn);
    }
    if (this.fn === "+")
      return evaluate.add(...args);
    if (this.fn === "\u2212")
      return evaluate.sub(...args);
    if (["*", "\xB7", "\xD7"].includes(this.fn))
      return evaluate.mul(...args);
    if (this.fn === "/")
      return evaluate.div(...args);
    if (this.fn === "sup")
      return evaluate.sup(...args);
    if (isSpecialFunction(this.fn))
      return evaluate[this.fn](...args);
    if (this.fn === "(")
      return args[0];
    throw ExprError.undefinedFunction(this.fn);
  }
  interval(vars = {}) {
    const args = this.args.map((a) => a.interval(vars));
    if (this.fn in vars) {
      const fn = vars[this.fn];
      if (typeof fn === "function")
        return (0, import_core2.repeat)(fn(...args.map((a) => a[0])), 2);
      if (typeof fn === "number" && args.length === 1)
        return interval.mul([fn, fn], args[0]);
      if (Array.isArray(fn) && args.length === 1)
        return interval.mul(fn, args[0]);
      throw ExprError.uncallableExpression(this.fn);
    }
    if (this.fn === "+")
      return interval.add(...args);
    if (this.fn === "\u2212")
      return interval.sub(...args);
    if (["*", "\xB7", "\xD7"].includes(this.fn))
      return interval.mul(...args);
    if (this.fn === "/")
      return interval.div(...args);
    if (this.fn === "sup")
      return interval.sup(...args);
    if (isSpecialFunction(this.fn))
      return interval[this.fn](...args);
    if (this.fn === "(")
      return args[0];
    throw ExprError.undefinedFunction(this.fn);
  }
  substitute(vars = {}) {
    return new _ExprFunction(this.fn, this.args.map((a) => a.substitute(vars)));
  }
  collapse() {
    if (this.fn === "(")
      return this.args[0].collapse();
    return new _ExprFunction(this.fn, this.args.map((a) => a.collapse()));
  }
  get simplified() {
    return this;
  }
  get variables() {
    return (0, import_core2.unique)((0, import_core2.flatten)(this.args.map((a) => a.variables)));
  }
  get functions() {
    return (0, import_core2.unique)([this.fn, ...(0, import_core2.flatten)(this.args.map((a) => a.functions))]);
  }
  toString() {
    const args = this.args.map((a) => needsBrackets(a, this.fn) ? `(${a.toString()})` : a.toString());
    if (this.fn === "\u2212") {
      return args.length > 1 ? args.join(" \u2212 ") : `\u2212${args[0]}`;
    }
    if (this.fn === "sup")
      return args.join("^");
    if (this.fn === "sub")
      return args.join("_");
    if (this.fn === "subsup")
      return `${args[0]}_${args[1]}^${args[2]}`;
    if ((0, import_core2.words)("+ * \xD7 \xB7 / = < > \u2264 \u2265 \u2248 \u225F \u2260").includes(this.fn)) {
      return args.join(` ${this.fn} `);
    }
    if ((0, import_core2.isOneOf)(this.fn, "(", "[", "{")) {
      return this.fn + this.args.join(", ") + BRACKETS[this.fn];
    }
    if ((0, import_core2.isOneOf)(this.fn, "!", "%"))
      return args[0] + this.fn;
    return `${this.fn}(${args.join(", ")})`;
  }
  toMathML(custom = {}) {
    const args = this.args.map((a) => a.toMathML(custom));
    const argsF = this.args.map((a, i) => addMFence(a, this.fn, args[i]));
    if (this.fn in custom) {
      const argsX = args.map((a, i) => ({
        toString: () => a,
        val: this.args[i]
      }));
      return custom[this.fn](...argsX);
    }
    if (this.fn === "\u2212") {
      return argsF.length > 1 ? argsF.join('<mo value="\u2212">\u2212</mo>') : `<mo rspace="0" value="\u2212">\u2212</mo>${argsF[0]}`;
    }
    if ((0, import_core2.isOneOf)(this.fn, "+", "=", "<", ">", "\u2264", "\u2265", "\u2248", "\u225F", "\u2260")) {
      const fn = escape(this.fn);
      return argsF.join(`<mo value="${fn}">${fn}</mo>`);
    }
    if ((0, import_core2.isOneOf)(this.fn, "*", "\xD7", "\xB7")) {
      let str = argsF[0];
      for (let i = 1; i < argsF.length - 1; ++i) {
        const showTimes = this.args[0] instanceof ExprNumber && this.args[1] instanceof ExprNumber;
        str += (showTimes ? `<mo value="\xD7">\xD7</mo>` : "") + argsF[1];
      }
      return str;
    }
    if (this.fn === "//")
      return argsF.join(`<mo value="/">/</mo>`);
    if (this.fn === "sqrt")
      return `<msqrt>${argsF[0]}</msqrt>`;
    if ((0, import_core2.isOneOf)(this.fn, "/", "root")) {
      const el = this.fn === "/" ? "mfrac" : "mroot";
      const args1 = this.args.map((a, i) => addMRow(a, args[i]));
      return `<${el}>${args1.join("")}</${el}>`;
    }
    if ((0, import_core2.isOneOf)(this.fn, "sup", "sub")) {
      const args1 = [
        addMRow(this.args[0], argsF[0]),
        addMRow(this.args[1], args[1])
      ];
      return `<m${this.fn}>${args1.join("")}</m${this.fn}>`;
    }
    if (this.fn === "subsup") {
      const args1 = [
        addMRow(this.args[0], argsF[0]),
        addMRow(this.args[1], args[1]),
        addMRow(this.args[2], args[2])
      ];
      return `<msubsup>${args1.join("")}</msubsup>`;
    }
    if ((0, import_core2.isOneOf)(this.fn, "(", "[", "{")) {
      return `<mfenced open="${this.fn}" close="${BRACKETS[this.fn]}">${argsF.join(COMMA)}</mfenced>`;
    }
    if ((0, import_core2.isOneOf)(this.fn, "!", "%")) {
      return `${argsF[0]}<mo value="${this.fn}" lspace="0">${this.fn}</mo>`;
    }
    if (this.fn === "abs") {
      return `<mfenced open="|" close="|">${argsF.join(COMMA)}</mfenced>`;
    }
    if (this.fn === "bar") {
      return `<mover>${addMRow(this.args[0], argsF[0])}<mo value="\u203E">\u203E</mo></mover>`;
    }
    if (this.fn === "vec") {
      return `<mover>${addMRow(this.args[0], argsF[0])}<mo value="\u2192">\u2192</mo></mover>`;
    }
    const variant = isSpecialFunction(this.fn) ? ' mathvariant="normal"' : "";
    return `<mi${variant}>${this.fn}</mi><mfenced>${argsF.join(COMMA)}</mfenced>`;
  }
  toVoice(custom = {}) {
    const args = this.args.map((a) => a.toVoice(custom));
    const joined = args.join(" ");
    if (this.fn in custom) {
      const argsX = args.map((a, i) => ({
        toString: () => a,
        val: this.args[i]
      }));
      return custom[this.fn](...argsX);
    }
    if ((0, import_core2.isOneOf)(this.fn, "(", "[", "{"))
      return joined;
    if (this.fn === "sqrt")
      return `square root of ${joined}`;
    if (this.fn === "%")
      return `${joined} percent`;
    if (this.fn === "!")
      return `${joined} factorial`;
    if (this.fn === "/")
      return `${args[0]} over ${args[1]}`;
    if (this.fn === "//")
      return `${args[0]} divided by ${args[1]}`;
    if (this.fn === "sub")
      return joined;
    if (this.fn === "subsup")
      return `${args[0]} ${args[1]} ${supVoice(args[2])}`;
    if (this.fn === "sup")
      return `${args[0]} ${supVoice(args[1])}`;
    if (VOICE_STRINGS[this.fn])
      return args.join(` ${VOICE_STRINGS[this.fn]} `);
    if (isSpecialFunction(this.fn))
      return `${this.fn} ${joined}`;
    return `${this.fn} of ${joined}`;
  }
};
var ExprTerm = class extends ExprElement {
  constructor(items) {
    super();
    this.items = items;
  }
  evaluate(vars = {}) {
    return this.collapse().evaluate(vars);
  }
  interval(vars = {}) {
    return this.collapse().interval(vars);
  }
  substitute(vars = {}) {
    return this.collapse().substitute(vars);
  }
  get simplified() {
    return this.collapse().simplified;
  }
  get variables() {
    return (0, import_core2.unique)((0, import_core2.join)(...this.items.map((i) => i.variables)));
  }
  get functions() {
    return this.collapse().functions;
  }
  toString() {
    return this.items.map((i) => i.toString()).join(" ");
  }
  toMathML(custom = {}) {
    return this.items.map((i) => i.toMathML(custom)).join("");
  }
  toVoice(custom = {}) {
    return this.items.map((i) => i.toVoice(custom)).join(" ");
  }
  collapse() {
    return collapseTerm(this.items).collapse();
  }
};

// src/parser.ts
function createToken(buffer, type) {
  if (type === 2 /* STR */)
    return new ExprString(buffer);
  if (!buffer || !type)
    return;
  if (type === 1 /* SPACE */ && buffer.length > 1)
    return new ExprSpace();
  if (type === 3 /* NUM */) {
    if (isNaN(+buffer))
      throw ExprError.invalidExpression();
    return new ExprNumber(+buffer);
  }
  if (type === 4 /* VAR */) {
    if (buffer in SPECIAL_IDENTIFIERS) {
      return new ExprIdentifier(SPECIAL_IDENTIFIERS[buffer]);
    } else if (buffer in SPECIAL_OPERATORS) {
      return new ExprOperator(SPECIAL_OPERATORS[buffer]);
    } else {
      return new ExprIdentifier(buffer);
    }
  }
  if (type === 5 /* OP */) {
    if (buffer in SPECIAL_OPERATORS) {
      return new ExprOperator(SPECIAL_OPERATORS[buffer]);
    } else {
      return new ExprOperator(buffer);
    }
  }
}
function tokenize(str) {
  const tokens = [];
  let buffer = "";
  let type = 0 /* UNKNOWN */;
  for (const s of str) {
    if (s === '"') {
      const newType = type === 2 /* STR */ ? 0 /* UNKNOWN */ : 2 /* STR */;
      const token2 = createToken(buffer, type);
      if (token2)
        tokens.push(token2);
      buffer = "";
      type = newType;
      continue;
    } else if (type === 2 /* STR */) {
      buffer += s;
      continue;
    }
    const sType = s.match(/[0-9.]/) ? 3 /* NUM */ : IDENTIFIER_SYMBOLS.includes(s) ? 4 /* VAR */ : OPERATOR_SYMBOLS.includes(s) ? 5 /* OP */ : s.match(/\s/) ? 1 /* SPACE */ : 0 /* UNKNOWN */;
    if (!sType)
      throw ExprError.invalidCharacter(s);
    if (!type || type === 3 /* NUM */ && sType !== 3 /* NUM */ || type === 4 /* VAR */ && sType !== 4 /* VAR */ && sType !== 3 /* NUM */ || type === 5 /* OP */ && !(buffer + s in SPECIAL_OPERATORS) || type === 1 /* SPACE */ && sType !== 1 /* SPACE */) {
      const token2 = createToken(buffer, type);
      if (token2)
        tokens.push(token2);
      buffer = "";
      type = sType;
    }
    buffer += s;
  }
  const token = createToken(buffer, type);
  if (token)
    tokens.push(token);
  return tokens;
}
function makeTerm(items) {
  if (items.length > 1)
    return new ExprTerm(items);
  if (items[0] instanceof ExprOperator)
    return new ExprTerm(items);
  return items[0];
}
function splitArray(items, check) {
  const result = [[]];
  for (const i of items) {
    if (check(i)) {
      result.push([]);
    } else {
      (0, import_core3.last)(result).push(i);
    }
  }
  return result;
}
function isOperator(expr, fns) {
  return expr instanceof ExprOperator && (0, import_core3.words)(fns).includes(expr.o);
}
function removeBrackets(expr) {
  return expr instanceof ExprFunction && expr.fn === "(" ? expr.args[0] : expr;
}
function findBinaryFunction(tokens, fn) {
  if (isOperator(tokens[0], fn))
    throw ExprError.startOperator(tokens[0]);
  if (isOperator((0, import_core3.last)(tokens), fn))
    throw ExprError.endOperator((0, import_core3.last)(tokens));
  for (let i = 1; i < tokens.length - 1; ++i) {
    if (!isOperator(tokens[i], fn))
      continue;
    const token = tokens[i];
    const a = tokens[i - 1];
    const b = tokens[i + 1];
    if (a instanceof ExprOperator) {
      throw ExprError.consecutiveOperators(a.o, token.o);
    }
    if (b instanceof ExprOperator) {
      throw ExprError.consecutiveOperators(token.o, b.o);
    }
    const token2 = tokens[i + 2];
    if (fn === "^ _" && isOperator(token, "_ ^") && isOperator(token2, "_ ^") && token.o !== token2.o) {
      const c = tokens[i + 3];
      if (c instanceof ExprOperator)
        throw ExprError.consecutiveOperators(token2.o, c.o);
      const args = [removeBrackets(a), removeBrackets(b), removeBrackets(c)];
      if (token.o === "^")
        [args[1], args[2]] = [args[2], args[1]];
      tokens.splice(i - 1, 5, new ExprFunction("subsup", args));
      i -= 4;
    } else {
      const fn2 = FUNCTION_NAMES[token.o] || token.o;
      const args = [removeBrackets(a), removeBrackets(b)];
      tokens.splice(i - 1, 3, new ExprFunction(fn2, args));
      i -= 2;
    }
  }
}
function prepareTerm(tokens) {
  findBinaryFunction(tokens, "^ _");
  findBinaryFunction(tokens, "/");
  return makeTerm(tokens);
}
function matchBrackets(tokens, context) {
  const stack = [[]];
  const safeVariables = ["\u03C0", ...(context == null ? void 0 : context.variables) || []];
  for (const t of tokens) {
    const lastOpen = (0, import_core3.last)(stack).length ? (0, import_core3.last)(stack)[0].o : void 0;
    if (isOperator(t, ") ] }")) {
      if (!isOperator(t, BRACKETS[lastOpen])) {
        throw ExprError.conflictingBrackets(t.o);
      }
      const closed = stack.pop();
      const term = (0, import_core3.last)(stack);
      const lastTerm = (0, import_core3.last)(term);
      const isFn = isOperator(t, ")") && lastTerm instanceof ExprIdentifier && !safeVariables.includes(lastTerm.i);
      const fnName = isFn ? term.pop().i : closed[0].o;
      const args = splitArray(closed.slice(1), (a) => isOperator(a, ","));
      term.push(new ExprFunction(fnName, args.map(prepareTerm)));
    } else if (isOperator(t, "( [ {")) {
      stack.push([t]);
    } else {
      (0, import_core3.last)(stack).push(t);
    }
  }
  if (stack.length > 1) {
    throw ExprError.unclosedBracket((0, import_core3.last)(stack)[0].o);
  }
  return prepareTerm(stack[0]);
}
function findAssociativeFunction(tokens, symbol, implicit = false) {
  const result = [];
  let buffer = [];
  let lastWasSymbol = false;
  function clearBuffer() {
    if (lastWasSymbol)
      throw ExprError.invalidExpression();
    if (!buffer.length)
      return;
    result.push(buffer.length > 1 ? new ExprFunction(symbol[0], buffer) : buffer[0]);
    buffer = [];
  }
  for (const t of tokens) {
    if (isOperator(t, symbol)) {
      if (lastWasSymbol || !buffer.length)
        throw ExprError.invalidExpression();
      lastWasSymbol = true;
    } else if (t instanceof ExprOperator) {
      clearBuffer();
      result.push(t);
      lastWasSymbol = false;
    } else {
      const noImplicit = !implicit || t instanceof ExprNumber;
      if (buffer.length && !lastWasSymbol && noImplicit)
        throw ExprError.invalidExpression();
      buffer.push(t);
      lastWasSymbol = false;
    }
  }
  clearBuffer();
  return result;
}
function collapseTerm(tokens) {
  tokens = tokens.filter((t) => !(t instanceof ExprSpace));
  if (!tokens.length)
    throw ExprError.invalidExpression();
  const comp = tokens.findIndex((t) => isOperator(t, "= < > \u2264 \u2265 \u225F \u2260"));
  if (comp === 0)
    throw ExprError.startOperator(tokens[0]);
  if (comp === tokens.length - 1)
    throw ExprError.endOperator(tokens[0]);
  if (comp > 0) {
    const left = collapseTerm(tokens.slice(0, comp));
    const right = collapseTerm(tokens.slice(comp + 1));
    return new ExprFunction(tokens[comp].o, [left, right]);
  }
  if (isOperator(tokens[0], "%!"))
    throw ExprError.startOperator(tokens[0]);
  for (let i = 0; i < tokens.length; ++i) {
    if (!isOperator(tokens[i], "%!"))
      continue;
    tokens.splice(i - 1, 2, new ExprFunction(tokens[i].o, [tokens[i - 1]]));
    i -= 1;
  }
  findBinaryFunction(tokens, "// \xF7");
  for (let i = 1; i < tokens.length; ++i) {
    const t = tokens[i];
    if (t instanceof ExprFunction && t.fn === "/") {
      const s = tokens[i - 1];
      if (s instanceof ExprNumber) {
        tokens.splice(i - 1, 2, new ExprFunction("+", [s, t]));
        i -= 1;
      } else if (!(s instanceof ExprOperator)) {
        throw ExprError.consecutiveOperators(s.toString(), t.toString());
      }
    }
  }
  tokens = findAssociativeFunction(tokens, "\xD7 * \xB7", true);
  if (isOperator(tokens[0], "\u2212 \xB1")) {
    tokens.splice(0, 2, new ExprFunction(tokens[0].o, [tokens[1]]));
  }
  findBinaryFunction(tokens, "\u2212 \xB1");
  if (isOperator(tokens[0], "+"))
    tokens = tokens.slice(1);
  tokens = findAssociativeFunction(tokens, "+");
  if (tokens.length > 1)
    throw ExprError.invalidExpression();
  return tokens[0];
}

// src/expression.ts
function parse(str, collapse = false, context) {
  const expr = matchBrackets(tokenize(str), context);
  return collapse ? expr.collapse() : expr;
}
function numEquals(expr1, expr2) {
  try {
    const vars = (0, import_core4.unique)([...expr1.variables, ...expr2.variables]);
    const fn1 = expr1.collapse();
    const fn2 = expr2.collapse();
    let matches = 0;
    for (let i = 0; i < 5; ++i) {
      const substitution = {};
      for (const v of vars)
        substitution[v] = CONSTANTS[v] || Math.random() * 5;
      const a = fn1.evaluate(substitution);
      const b = fn2.evaluate(substitution);
      if (isNaN(a) || isNaN(b))
        continue;
      if (!(0, import_fermat2.nearlyEquals)(a, b))
        return false;
      matches += 1;
    }
    return !!matches;
  } catch (e) {
    return false;
  }
}
var Expression = {
  numEquals,
  parse: (0, import_core4.cache)(parse)
};
//# sourceMappingURL=index.cjs.js.map
