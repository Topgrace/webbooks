{
  "version": 3,
  "sources": ["../src/errors.ts", "../src/expression.ts", "../src/symbols.ts", "../src/parser.ts", "../src/elements.ts", "../src/functions.ts", "../src/eval.ts"],
  "sourcesContent": ["// =============================================================================\n// Hilbert.js | Expression Errors\n// (c) Mathigon\n// =============================================================================\n\n\nimport {ExprElement} from './elements';\n\n\n/** Expression Error Class */\nexport class ExprError extends Error {\n\n  constructor(name: string, message: string) {\n    super(message);\n    this.name = name;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Eval Errors\n\n  static undefinedVariable(x: string) {\n    return new ExprError('EvalError', `Undefined variable \u201C${x}\u201D.`);\n  }\n\n  static undefinedFunction(x: string) {\n    return new ExprError('EvalError', `Undefined function \u201C${x}\u201D.`);\n  }\n\n  static uncallableExpression(x: string) {\n    return new ExprError('EvalError', `Cannot call \u201C${x}\u201D.`);\n  }\n\n  static evalLoop(x: string) {\n    return new ExprError('EvalError', `Loop in nested evaluation \u201C${x}\u201D.`);\n  }\n\n\n  // ---------------------------------------------------------------------------\n  // Syntax Errors\n\n  static invalidCharacter(x: string) {\n    return new ExprError('SyntaxError', `Unknown symbol \u201C${x}\u201D.`);\n  }\n\n  static conflictingBrackets(x: string) {\n    return new ExprError('SyntaxError', `Conflicting brackets \u201C${x}\u201D.`);\n  }\n\n  static unclosedBracket(x: string) {\n    return new ExprError('SyntaxError', `Unclosed bracket \u201C${x}\u201D.`);\n  }\n\n  static startOperator(x: ExprElement) {\n    return new ExprError('SyntaxError', `A term cannot start with a \u201C${x}\u201D.`);\n  }\n\n  static endOperator(x: ExprElement) {\n    return new ExprError('SyntaxError', `A term cannot end with a \u201C${x}\u201D.`);\n  }\n\n  static consecutiveOperators(x: string, y: string) {\n    return new ExprError('SyntaxError',\n      `A \u201C${x}\u201D cannot be followed by a \u201C${y}\u201D.`);\n  }\n\n  static invalidExpression() {\n    return new ExprError('SyntaxError', `This expression is invalid.`);\n  }\n}\n", "// =============================================================================\n// Hilbert.js | Expressions\n// (c) Mathigon\n// =============================================================================\n\n\nimport {cache, Obj, unique} from '@mathigon/core';\nimport {nearlyEquals} from '@mathigon/fermat';\nimport {ExprElement} from './elements';\nimport {CONSTANTS} from './symbols';\nimport {matchBrackets, tokenize} from './parser';\n\n\n/**\n * Parses a string to an expression.\n *\n * If `context` is supplied, interpret `f(a+b)` as `f*(a+b)` if `f` is in\n * `context.variables`.\n */\nfunction parse(str: string, collapse = false, context?: {variables?: string[]}) {\n  const expr = matchBrackets(tokenize(str), context);\n  return collapse ? expr.collapse() : expr;\n}\n\n/**\n * Checks numerically if two expressions are equal. Obviously this is not a\n * very robust solution, but much easier than the full CAS simplification.\n */\nfunction numEquals(expr1: ExprElement, expr2: ExprElement) {\n  try {\n    const vars = unique([...expr1.variables, ...expr2.variables]);\n    const fn1 = expr1.collapse();\n    const fn2 = expr2.collapse();\n\n    // We only test positive random numbers, because negative numbers raised\n    // to non-integer powers return NaN.\n    let matches = 0;\n    for (let i = 0; i < 5; ++i) {\n      const substitution: Obj<number> = {};\n      for (const v of vars) substitution[v] = CONSTANTS[v] || Math.random() * 5;\n      const a = fn1.evaluate(substitution);\n      const b = fn2.evaluate(substitution);\n      if (isNaN(a) || isNaN(b)) continue;  // This might happen in square roots.\n      if (!nearlyEquals(a, b)) return false;\n      matches += 1;\n    }\n\n    // Return false if all items were NaN.\n    return !!matches;\n  } catch (e) {\n    return false;\n  }\n}\n\nexport const Expression = {\n  numEquals,\n  parse: cache(parse)\n};\n", "// =============================================================================\n// Hilbert.js | Symbols\n// (c) Mathigon\n// =============================================================================\n\n\nimport {Obj} from '@mathigon/core';\n\n\nexport const CONSTANTS: Obj<number> = {\n  pi: Math.PI,\n  \u03C0: Math.PI,\n  e: Math.E\n};\n\nexport const BRACKETS: Obj<string> = {\n  '(': ')',\n  '[': ']',\n  '{': '}'\n};\n\nexport const SPECIAL_OPERATORS: Obj<string> = {\n  '*': '\u00B7',\n  '**': '\u2217',\n  '//': '//',\n  '+-': '\u00B1',\n  '\u2013': '\u2212',\n  '-': '\u2212',\n  'xx': '\u00D7',\n  'sum': '\u2211',\n  'prod': '\u220F',\n  'int': '\u222B',\n  'del': '\u2202',\n  'grad': '\u2207',\n  'aleph': '\u2135',\n  'not': '\u00AC',\n  'AA': '\u2200',\n  'EE': '\u2203',\n  '\\'': '\u2019',\n\n  '!=': '\u2260',\n  '?=': '\u225F',\n  '<=': '\u2264',\n  '>=': '\u2265',\n  'in': '\u2208',\n  '!in': '\u2209',\n  '==': '\u2261',\n  '~=': '\u2245',\n  '~~': '\u2248',\n  'sub': '\u2282',\n  'sube': '\u2286',\n  'prop': '\u221D',\n  'oo': '\u221E',\n  'cap': '\u2229',\n  'cup': '\u222A',\n\n  '<-': '\u2190',\n  '->': '\u2192',\n  '=>': '\u21D2',\n  '<=>': '\u21D4',\n  '|->': '\u21A6',\n  'uarr': '\u2191',\n  'darr': '\u2193',\n  'lArr': '\u21D0'\n};\n\nexport const SPECIAL_IDENTIFIERS: Obj<string> = {\n  Gamma: '\u0393',\n  Delta: '\u0394',\n  Theta: '\u0398',\n  Lambda: '\u039B',\n  Xi: '\u039E',\n  Pi: '\u03A0',\n  Sigma: '\u03A3',\n  Phi: '\u03A6',\n  Psi: '\u03A8',\n  Omega: '\u03A9',\n\n  alpha: '\u03B1',\n  beta: '\u03B2',\n  gamma: '\u03B3',\n  delta: '\u03B4',\n  epsilon: '\u025B',\n  zeta: '\u03B6',\n  eta: '\u03B7',\n  theta: '\u03B8',\n  iota: '\u03B9',\n  kappa: '\u03BA',\n  lambda: '\u03BB',\n  mu: '\u03BC',\n  nu: '\u03BD',\n  xi: '\u03BE',\n  pi: '\u03C0',\n  rho: '\u03C1',\n  sigma: '\u03C3',\n  tau: '\u03C4',\n  upsilon: '\u03C5',\n  phi: '\u03C6',\n  chi: '\u03C7',\n  psi: '\u03C8',\n  omega: '\u03C9',\n\n  CC: '\u2102',\n  NN: '\u2115',\n  QQ: '\u211A',\n  RR: '\u211D',\n  ZZ: '\u2124'\n};\n\nconst ALPHABET = 'abcdefghijklmnopqrstuvwxyz';\nconst LOWERCASE = ALPHABET.split('');\nconst UPPERCASE = ALPHABET.toUpperCase().split('');\nconst GREEK = Object.values(SPECIAL_IDENTIFIERS);\nexport const IDENTIFIER_SYMBOLS = [...LOWERCASE, ...UPPERCASE, ...GREEK, '$'];\n\nconst SIMPLE_SYMBOLS = '|()[]{}\u00F7,!?<>=*/+-\u2013\u2212~^_\u2026\u00B0\u2022\u2225\u22A5\\'\u2220:%\u223C\u25B3';\nconst COMPLEX_SYMBOLS = Object.values(SPECIAL_OPERATORS);\nexport const OPERATOR_SYMBOLS = [...SIMPLE_SYMBOLS, ...COMPLEX_SYMBOLS];\n\nexport const FUNCTION_NAMES: Obj<string> = {\n  '_': 'sub',\n  '^': 'sup',\n  '//': '/',\n  '\u00F7': '/'\n};\n\nconst ESCAPES: Obj<string> = {\n  '<': '&lt;',\n  '>': '&gt;'\n};\n\nexport function escape(char: string) {\n  return (char in ESCAPES) ? ESCAPES[char] : char;\n}\n\nconst SPECIAL_FUNCTIONS = ['abs', 'round', 'floor', 'ceil', 'max', 'min', 'mod',\n  'lcm', 'gcd', 'gcf', 'log', 'exp', 'ln', 'sqrt', 'root', 'sin', 'cos', 'tan',\n  'sec', 'csc', 'cot', 'cosec', 'cotan', 'arcsin', 'arccos', 'arctan', 'sinh',\n  'cosh', 'tanh', 'sech', 'csch', 'coth', 'cosech'] as const;\nexport type SpecialFunction = typeof SPECIAL_FUNCTIONS[number];\n\nexport function isSpecialFunction(fn: string): fn is SpecialFunction {\n  return SPECIAL_FUNCTIONS.includes(fn as SpecialFunction);\n}\n\nexport const VOICE_STRINGS: Obj<string> = {\n  '+': 'plus',\n  '\u2212': 'minus',\n  '\u00B7': 'times',\n  '\u00D7': 'times',\n  '/': 'over',\n  '//': 'divided by',\n  '%': 'percent',\n  '!': 'factorial',\n  '\u00B1': 'plus-minus',\n  '=': 'equals',\n  '\u2260': 'does not equal',\n  '\u225F': 'is it equal?',\n  '<': 'is less than',\n  '>': 'is greater than',\n  '\u2264': 'is less than or equal to',\n  '\u2265': 'is greater than or equal to',\n  '\u03C0': 'pi',\n  '\u2245': 'is congruent to',\n  '\u2225': 'is parallel to',\n  '\u22A5': 'is perpendicular to'\n};\n\nfor (const name of Object.keys(SPECIAL_IDENTIFIERS)) {\n  VOICE_STRINGS[SPECIAL_IDENTIFIERS[name]] = name;\n}\n", "// =============================================================================\n// Hilbert.js | Expression Parser\n// (c) Mathigon\n// =============================================================================\n\n\nimport {last, words} from '@mathigon/core';\nimport {BRACKETS, FUNCTION_NAMES, IDENTIFIER_SYMBOLS, OPERATOR_SYMBOLS, SPECIAL_IDENTIFIERS, SPECIAL_OPERATORS} from './symbols';\nimport {ExprElement, ExprIdentifier, ExprNumber, ExprOperator, ExprSpace, ExprString} from './elements';\nimport {ExprFunction, ExprTerm} from './functions';\nimport {ExprError} from './errors';\n\n\n// -----------------------------------------------------------------------------\n// Tokenizer\n\nenum TokenType {UNKNOWN, SPACE, STR, NUM, VAR, OP}\n\n\nfunction createToken(buffer: string, type: TokenType) {\n  if (type === TokenType.STR) return new ExprString(buffer);\n\n  // Strings can be empty, but other types cannot.\n  if (!buffer || !type) return;\n\n  if (type === TokenType.SPACE && buffer.length > 1) return new ExprSpace();\n\n  if (type === TokenType.NUM) {\n    // This can happen if users simply type \".\", which get parsed as number.\n    if (isNaN(+buffer)) throw ExprError.invalidExpression();\n    return new ExprNumber(+buffer);\n  }\n\n  if (type === TokenType.VAR) {\n    if (buffer in SPECIAL_IDENTIFIERS) {\n      return new ExprIdentifier(SPECIAL_IDENTIFIERS[buffer]);\n    } else if (buffer in SPECIAL_OPERATORS) {\n      return new ExprOperator(SPECIAL_OPERATORS[buffer]);\n    } else {\n      return new ExprIdentifier(buffer);\n    }\n  }\n\n  if (type === TokenType.OP) {\n    if (buffer in SPECIAL_OPERATORS) {\n      return new ExprOperator(SPECIAL_OPERATORS[buffer]);\n    } else {\n      return new ExprOperator(buffer);\n    }\n  }\n}\n\nexport function tokenize(str: string) {\n  const tokens = [];\n  let buffer = '';\n  let type = TokenType.UNKNOWN;\n\n  for (const s of str) {\n\n    // Handle Strings\n    if (s === '\"') {\n      const newType: TokenType = (((type as TokenType) === TokenType.STR) ? TokenType.UNKNOWN : TokenType.STR);\n      const token = createToken(buffer, type);\n      if (token) tokens.push(token);\n      buffer = '';\n      type = newType;\n      continue;\n    } else if ((type as TokenType) === TokenType.STR) {\n      buffer += s;\n      continue;\n    }\n\n    const sType = s.match(/[0-9.]/) ? TokenType.NUM :\n      IDENTIFIER_SYMBOLS.includes(s) ? TokenType.VAR :\n        OPERATOR_SYMBOLS.includes(s) ? TokenType.OP :\n          s.match(/\\s/) ? TokenType.SPACE : TokenType.UNKNOWN;\n    if (!sType) throw ExprError.invalidCharacter(s);\n\n    if (!type || (type === TokenType.NUM && sType !== TokenType.NUM) ||\n        (type === TokenType.VAR && sType !== TokenType.VAR && sType !==\n         TokenType.NUM) ||\n        (type === TokenType.OP && !((buffer + s) in SPECIAL_OPERATORS)) ||\n        (type === TokenType.SPACE && sType !== TokenType.SPACE)) {\n      const token = createToken(buffer, type);\n      if (token) tokens.push(token);\n      buffer = '';\n      type = sType;\n    }\n\n    buffer += s;\n  }\n\n  const token = createToken(buffer, type);\n  if (token) tokens.push(token);\n\n  return tokens;\n}\n\n\n// -----------------------------------------------------------------------------\n// Utility Functions\n\nfunction makeTerm(items: ExprElement[]) {\n  if (items.length > 1) return new ExprTerm(items);\n  if (items[0] instanceof ExprOperator) return new ExprTerm(items);\n  return items[0];\n}\n\nfunction splitArray(items: ExprElement[], check: (x: ExprElement) => boolean) {\n  const result: ExprElement[][] = [[]];\n  for (const i of items) {\n    if (check(i)) {\n      result.push([]);\n    } else {\n      last(result).push(i);\n    }\n  }\n  return result;\n}\n\nfunction isOperator(expr: ExprElement, fns: string): expr is ExprOperator {\n  return expr instanceof ExprOperator && words(fns).includes(expr.o);\n}\n\nfunction removeBrackets(expr: ExprElement) {\n  return (expr instanceof ExprFunction && expr.fn === '(') ? expr.args[0] : expr;\n}\n\nfunction findBinaryFunction(tokens: ExprElement[], fn: string) {\n  if (isOperator(tokens[0], fn)) throw ExprError.startOperator(tokens[0]);\n  if (isOperator(last(tokens), fn)) throw ExprError.endOperator(last(tokens));\n\n  for (let i = 1; i < tokens.length - 1; ++i) {\n    if (!isOperator(tokens[i], fn)) continue;\n    const token = tokens[i] as ExprOperator;\n\n    const a = tokens[i - 1];\n    const b = tokens[i + 1];\n\n    if (a instanceof ExprOperator) {\n      throw ExprError.consecutiveOperators(a.o, token.o);\n    }\n    if (b instanceof ExprOperator) {\n      throw ExprError.consecutiveOperators(token.o, b.o);\n    }\n\n    const token2 = tokens[i + 2];\n    if (fn === '^ _' && isOperator(token, '_ ^') && isOperator(token2, '_ ^') && token.o !== token2.o) {\n      // Special handling for subsup operator.\n      const c = tokens[i + 3];\n      if (c instanceof ExprOperator) throw ExprError.consecutiveOperators(token2.o, c.o);\n      const args = [removeBrackets(a), removeBrackets(b), removeBrackets(c)];\n      if (token.o === '^') [args[1], args[2]] = [args[2], args[1]];\n      tokens.splice(i - 1, 5, new ExprFunction('subsup', args));\n      i -= 4;\n\n    } else {\n      const fn = FUNCTION_NAMES[token.o] || token.o;\n      const args = [removeBrackets(a), removeBrackets(b)];\n      tokens.splice(i - 1, 3, new ExprFunction(fn, args));\n      i -= 2;\n    }\n  }\n}\n\n\n// -----------------------------------------------------------------------------\n// Match Brackets\n\nfunction prepareTerm(tokens: ExprElement[]) {\n  findBinaryFunction(tokens, '^ _');\n  findBinaryFunction(tokens, '/');\n  return makeTerm(tokens);\n}\n\nexport function matchBrackets(tokens: ExprElement[], context?: {variables?: string[]}) {\n  const stack: ExprElement[][] = [[]];\n\n  // When these identifiers appear immediately before parenthesis, like x(y),\n  // they will be treated as variables with implicit multiplication, rather\n  // than a custom function call.\n  const safeVariables = ['\u03C0', ...(context?.variables || [])];\n\n  for (const t of tokens) {\n    const lastOpen = last(stack).length ? (last(stack)[0] as ExprOperator).o : undefined;\n\n    if (isOperator(t, ') ] }')) {\n\n      if (!isOperator(t, BRACKETS[lastOpen!])) {\n        throw ExprError.conflictingBrackets((t as ExprOperator).o);\n      }\n\n      const closed = stack.pop();\n      const term = last(stack);\n\n      const lastTerm = last(term);\n      const isFn = isOperator(t, ')') && lastTerm instanceof ExprIdentifier &&\n        !safeVariables.includes(lastTerm.i);\n\n      const fnName = isFn ? (term.pop() as ExprIdentifier).i : (closed![0] as ExprOperator).o;\n\n      // Support multiple arguments for function calls.\n      const args = splitArray(closed!.slice(1), a => isOperator(a, ','));\n      term.push(new ExprFunction(fnName, args.map(prepareTerm)));\n\n    } else if (isOperator(t, '( [ {')) {\n      stack.push([t]);\n\n    } else {\n      last(stack).push(t);\n    }\n  }\n\n  if (stack.length > 1) {\n    throw ExprError.unclosedBracket((last(stack)[0] as ExprOperator).o);\n  }\n  return prepareTerm(stack[0]);\n}\n\n\n// -----------------------------------------------------------------------------\n// Collapse term items\n\nfunction findAssociativeFunction(tokens: ExprElement[], symbol: string, implicit = false) {\n  const result: ExprElement[] = [];\n  let buffer: ExprElement[] = [];\n  let lastWasSymbol = false;\n\n  function clearBuffer() {\n    if (lastWasSymbol) throw ExprError.invalidExpression();\n    if (!buffer.length) return;\n    result.push(buffer.length > 1 ? new ExprFunction(symbol[0], buffer) : buffer[0]);\n    buffer = [];\n  }\n\n  for (const t of tokens) {\n    if (isOperator(t, symbol)) {\n      if (lastWasSymbol || !buffer.length) throw ExprError.invalidExpression();\n      lastWasSymbol = true;\n    } else if (t instanceof ExprOperator) {\n      clearBuffer();\n      result.push(t);\n      lastWasSymbol = false;\n    } else {\n      // If implicit=true, we allow implicit multiplication, except where the\n      // second factor is a number. For example, \"3 5\" is invalid.\n      const noImplicit = (!implicit || t instanceof ExprNumber);\n      if (buffer.length && !lastWasSymbol &&\n          noImplicit) throw ExprError.invalidExpression();\n      buffer.push(t);\n      lastWasSymbol = false;\n    }\n  }\n\n  clearBuffer();\n  return result;\n}\n\nexport function collapseTerm(tokens: ExprElement[]): ExprElement {\n  // Filter out whitespace.\n  tokens = tokens.filter(t => !(t instanceof ExprSpace));\n  if (!tokens.length) throw ExprError.invalidExpression();\n\n  // Match comparison operators first\n  const comp = tokens.findIndex(t => isOperator(t, '= < > \u2264 \u2265 \u225F \u2260'));\n  if (comp === 0) throw ExprError.startOperator(tokens[0]);\n  if (comp === tokens.length - 1) throw ExprError.endOperator(tokens[0]);\n  if (comp > 0) {\n    const left = collapseTerm(tokens.slice(0, comp));\n    const right = collapseTerm(tokens.slice(comp + 1));\n    return new ExprFunction((tokens[comp] as ExprOperator).o, [left, right]);\n  }\n\n  // Match percentage and factorial operators.\n  if (isOperator(tokens[0], '%!')) throw ExprError.startOperator(tokens[0]);\n  for (let i = 0; i < tokens.length; ++i) {\n    if (!isOperator(tokens[i], '%!')) continue;\n    tokens.splice(i - 1, 2, new ExprFunction((tokens[i] as ExprOperator).o, [tokens[i - 1]]));\n    i -= 1;\n  }\n\n  // Match division operators.\n  findBinaryFunction(tokens, '// \u00F7');\n\n  // Detect mixed numbers.\n  for (let i = 1; i < tokens.length; ++i) {\n    const t = tokens[i];\n    if (t instanceof ExprFunction && t.fn === '/') {\n      const s = tokens[i - 1];  // previous token\n      if (s instanceof ExprNumber) {\n        tokens.splice(i - 1, 2, new ExprFunction('+', [s, t]));\n        i -= 1;\n      } else if (!(s instanceof ExprOperator)) {\n        throw ExprError.consecutiveOperators(s.toString(), t.toString());\n      }\n    }\n  }\n\n  // Match multiplication operators.\n  tokens = findAssociativeFunction(tokens, '\u00D7 * \u00B7', true);\n\n  // Match - and \u00B1 operators, including a unary -/\u00B1 at the start of an expression.\n  if (isOperator(tokens[0], '\u2212 \u00B1')) {\n    tokens.splice(0, 2, new ExprFunction((tokens[0] as ExprOperator).o, [tokens[1]]));\n  }\n  findBinaryFunction(tokens, '\u2212 \u00B1');\n\n  // Match + operators.\n  if (isOperator(tokens[0], '+')) tokens = tokens.slice(1);\n  tokens = findAssociativeFunction(tokens, '+');\n\n  if (tokens.length > 1) throw ExprError.invalidExpression();\n  return tokens[0];\n}\n", "// =============================================================================\n// Hilbert.js | Expressions\n// (c) Mathigon\n// =============================================================================\n\n\nimport {Interval} from './eval';\nimport {Expression} from './expression';\nimport {CONSTANTS, escape, isSpecialFunction, VOICE_STRINGS} from './symbols';\nimport {ExprError} from './errors';\n\n\nexport interface MathMLArgument {\n  val: ExprElement;\n  toString: () => string;\n}\n\nexport type CustomFunction = ((...args: number[]) => number);\nexport type VarMap = Record<string, number|string|Interval|ExprElement|CustomFunction>;\nexport type ExprMap = Record<string, ExprElement>;\nexport type MathMLMap = Record<string, (...args: MathMLArgument[]) => string>;\n\nconst toNumber = (x: number|Interval) => ((typeof x === 'number') ? x : x[0]);\nconst toInterval = (x: number|Interval): Interval => ((typeof x === 'number') ? [x, x] : x);\n\n\n/**\n * Maths Expression\n */\nexport abstract class ExprElement {\n\n  /** Evaluates an expression using a given map of variables and functions. */\n  evaluate(_vars: VarMap = {}, _privateNested?: boolean): number {\n    return NaN;\n  }\n\n  interval(vars: VarMap = {}, _privateNested?: boolean): Interval {\n    return toInterval(this.evaluate(vars));\n  }\n\n  /** Substitutes a new expression for a variable. */\n  substitute(_vars: ExprMap = {}): ExprElement {\n    return this;\n  }\n\n  /**\n   * Recursively substitutes a new expression for a variable.\n   * NOTE: This function does not test for cyclical dependencies, which could\n   * lead to an infinite loop. You have to manually validate expressions first!\n   */\n  recursiveSubstitute(vars: ExprMap): ExprElement {\n    const varList = Object.keys(vars);\n    if (!this.unknowns.filter(v => varList.includes(v)).length) return this;\n    return this.substitute(vars).recursiveSubstitute(vars);\n  }\n\n  /** Returns the simplest mathematically equivalent expression. */\n  get simplified(): ExprElement {\n    return this;\n  }\n\n  /** Returns a list of all variables used in the expression (excluding defined constants). */\n  get unknowns(): string[] {\n    return this.variables.filter(v => !Object.prototype.hasOwnProperty.call(CONSTANTS, v));\n  }\n\n  /** Returns a list of all variables used in the expression (including defined constants). */\n  get variables(): string[] {\n    return [];\n  }\n\n  /** Returns a list of all functions called by the expression. */\n  get functions(): string[] {\n    return [];\n  }\n\n  /** Collapses all terms into functions. */\n  collapse(): ExprElement {\n    return this;\n  }\n\n  /** Converts the expression to a plain text string. */\n  toString() {\n    return '';\n  }\n\n  /** Converts the expression to a MathML string. */\n  toVoice(_custom: MathMLMap = {}) {\n    return '';\n  }\n\n  /** Converts the expression to a MathML string. */\n  toMathML(_custom: MathMLMap = {}) {\n    return '';\n  }\n}\n\n\n// -----------------------------------------------------------------------------\n// Evaluation tools\n\nconst LOOP_DETECTION = new Set<string>();\n\n// TODO Cache results for performance!\nfunction evaluateHelper(name: string, vars: VarMap, nested = false): number|Interval {\n  let value = vars[name] ?? CONSTANTS[name];\n  if (value === undefined) throw ExprError.undefinedVariable(name);\n\n  if (typeof value === 'string' || value instanceof ExprElement) {\n    if (!nested) LOOP_DETECTION.clear();\n    if (LOOP_DETECTION.has(name)) throw ExprError.evalLoop(name);\n    LOOP_DETECTION.add(name);\n    if (typeof value === 'string') value = Expression.parse(value);\n    return value.evaluate(vars, true);\n  } else if (typeof value === 'function') {\n    return value();\n  } else {\n    return value;\n  }\n}\n\n\n// -----------------------------------------------------------------------------\n\nexport class ExprNumber extends ExprElement {\n\n  constructor(readonly n: number) {\n    super();\n  }\n\n  evaluate() {\n    return this.n;\n  }\n\n  toString() {\n    return `${this.n}`;\n  }\n\n  toVoice() {\n    return `${this.n}`;\n  }\n\n  toMathML() {\n    return `<mn>${this.n}</mn>`;\n  }\n}\n\nexport class ExprIdentifier extends ExprElement {\n\n  constructor(readonly i: string) {\n    super();\n  }\n\n  evaluate(vars: VarMap = {}, privateNested?: boolean) {\n    return toNumber(evaluateHelper(this.i, vars, privateNested));\n  }\n\n  interval(vars: VarMap = {}, privateNested?: boolean): Interval {\n    return toInterval(evaluateHelper(this.i, vars, privateNested));\n  }\n\n  toMathML() {\n    const variant = isSpecialFunction(this.i) ? ' mathvariant=\"normal\"' : '';\n    return `<mi${variant}>${this.i}</mi>`;\n  }\n\n  substitute(vars: ExprMap = {}) {\n    return vars[this.i] || this;\n  }\n\n  get variables() {\n    return [this.i];\n  }\n\n  toString() {\n    return this.i;\n  }\n\n  toVoice() {\n    // Surrounding single-letter variables with _s can help with TTS algorithms.\n    if (this.i in VOICE_STRINGS) return VOICE_STRINGS[this.i];\n    if (this.i.length === 1) return `_${this.i}_`;\n    return this.i;\n  }\n}\n\nexport class ExprString extends ExprElement {\n\n  constructor(readonly s: string) {\n    super();\n  }\n\n  evaluate(vars: VarMap = {}, privateNested?: boolean) {\n    return toNumber(evaluateHelper(this.s, vars, privateNested));\n  }\n\n  toString() {\n    return `\"${this.s}\"`;\n  }\n\n  toVoice() {\n    return this.s;\n  }\n\n  toMathML() {\n    return `<mtext>${this.s}</mtext>`;\n  }\n}\n\nexport class ExprSpace extends ExprElement {\n\n  toString() {\n    return ' ';\n  }\n\n  toMathML() {\n    return `<mspace></mspace>`;\n  }\n}\n\nexport class ExprOperator extends ExprElement {\n\n  constructor(readonly o: string) {\n    super();\n  }\n\n  toString() {\n    return this.o.replace('//', '/');\n  }\n\n  toVoice() {\n    return VOICE_STRINGS[this.o] || this.o;\n  }\n\n  get functions() {\n    return [this.o];\n  }\n\n  toMathML() {\n    const op = escape(this.toString());\n    return `<mo value=\"${op}\">${op}</mo>`;\n  }\n}\n", "// =============================================================================\n// Hilbert.js | Functions\n// (c) Mathigon\n// =============================================================================\n\n\nimport {flatten, isOneOf, join, repeat, unique, words} from '@mathigon/core';\nimport {evaluate, interval, Interval} from './eval';\nimport {collapseTerm} from './parser';\nimport {BRACKETS, escape, isSpecialFunction, VOICE_STRINGS} from './symbols';\nimport {ExprElement, ExprMap, ExprNumber, MathMLMap, VarMap} from './elements';\nimport {ExprError} from './errors';\n\n\nconst PRECEDENCE = words('+ \u2212 * \u00D7 \u00B7 / \u00F7 // sup sub subsup');\nconst SUBSUP = words('sub sup subsup');\nconst COMMA = '<mo value=\",\" lspace=\"0\">,</mo>';\n\nfunction needsBrackets(expr: ExprElement, parentFn: string): boolean {\n  if (!PRECEDENCE.includes(parentFn)) return false;\n  if (expr instanceof ExprTerm) return true;\n  if (!(expr instanceof ExprFunction)) return false;\n  if (!PRECEDENCE.includes(expr.fn)) return false;\n  if (SUBSUP.includes(expr.fn) && SUBSUP.includes(parentFn)) return true;\n  return PRECEDENCE.indexOf(parentFn) > PRECEDENCE.indexOf(expr.fn);\n}\n\nfunction addMFence(expr: ExprElement, fn: string, string: string) {\n  return needsBrackets(expr, fn) ? `<mfenced>${string}</mfenced>` : string;\n}\n\nfunction addMRow(expr: ExprElement, string: string) {\n  const needsRow = (expr instanceof ExprTerm) || (expr instanceof ExprFunction);\n  return needsRow ? `<mrow>${string}</mrow>` : string;\n}\n\nfunction supVoice(a: string) {\n  return a === '2' ? 'squared' : a === '3' ? 'cubed' : `to the power of ${a}`;\n}\n\n\nexport class ExprFunction extends ExprElement {\n\n  constructor(readonly fn: string, readonly args: ExprElement[] = []) {\n    super();\n  }\n\n  evaluate(vars: VarMap = {}) {\n    const args = this.args.map(a => a.evaluate(vars));\n\n    if (this.fn in vars) {\n      const fn = vars[this.fn];\n      if (typeof fn === 'function') return fn(...args);\n      if (typeof fn === 'number' && args.length === 1) return evaluate.mul(fn, args[0]);\n      throw ExprError.uncallableExpression(this.fn);\n    }\n\n    if (this.fn === '+') return evaluate.add(...args);\n    if (this.fn === '\u2212') return evaluate.sub(...args);\n    if (['*', '\u00B7', '\u00D7'].includes(this.fn)) return evaluate.mul(...args);\n    if (this.fn === '/') return evaluate.div(...args);\n    if (this.fn === 'sup') return evaluate.sup(...args);\n    if (isSpecialFunction(this.fn)) return evaluate[this.fn](...args);\n    if (this.fn === '(') return args[0];\n    throw ExprError.undefinedFunction(this.fn);\n  }\n\n  interval(vars: VarMap = {}): Interval {\n    const args = this.args.map(a => a.interval(vars));\n\n    if (this.fn in vars) {\n      const fn = vars[this.fn];\n      if (typeof fn === 'function') return repeat(fn(...args.map(a => a[0])), 2) as Interval;\n      if (typeof fn === 'number' && args.length === 1) return interval.mul([fn, fn], args[0]);\n      if (Array.isArray(fn) && args.length === 1) return interval.mul(fn, args[0]);\n      throw ExprError.uncallableExpression(this.fn);\n    }\n\n    if (this.fn === '+') return interval.add(...args);\n    if (this.fn === '\u2212') return interval.sub(...args);\n    if (['*', '\u00B7', '\u00D7'].includes(this.fn)) return interval.mul(...args);\n    if (this.fn === '/') return interval.div(...args);\n    if (this.fn === 'sup') return interval.sup(...args);\n    if (isSpecialFunction(this.fn)) return interval[this.fn](...args);\n    if (this.fn === '(') return args[0];\n    throw ExprError.undefinedFunction(this.fn);\n  }\n\n  substitute(vars: ExprMap = {}) {\n    return new ExprFunction(this.fn, this.args.map(a => a.substitute(vars)));\n  }\n\n  collapse() {\n    if (this.fn === '(') return this.args[0].collapse();\n    return new ExprFunction(this.fn, this.args.map(a => a.collapse()));\n  }\n\n  get simplified() {\n    // TODO Write CAS simplification algorithms\n    return this;\n  }\n\n  get variables() {\n    return unique(flatten(this.args.map(a => a.variables)));\n  }\n\n  get functions() {\n    return unique([this.fn, ...flatten(this.args.map(a => a.functions))]);\n  }\n\n  toString() {\n    const args = this.args.map(a => needsBrackets(a, this.fn) ? `(${a.toString()})` : a.toString());\n\n    if (this.fn === '\u2212') {\n      return args.length > 1 ? args.join(' \u2212 ') : `\u2212${args[0]}`;\n    }\n\n    if (this.fn === 'sup') return args.join('^');\n    if (this.fn === 'sub') return args.join('_');\n    if (this.fn === 'subsup') return `${args[0]}_${args[1]}^${args[2]}`;\n\n    if (words('+ * \u00D7 \u00B7 / = < > \u2264 \u2265 \u2248 \u225F \u2260').includes(this.fn)) {\n      return args.join(` ${this.fn} `);\n    }\n\n    if (isOneOf(this.fn, '(', '[', '{')) {\n      return this.fn + this.args.join(', ') + BRACKETS[this.fn];\n    }\n\n    if (isOneOf(this.fn, '!', '%')) return args[0] + this.fn;\n\n    // TODO Implement other functions\n    return `${this.fn}(${args.join(', ')})`;\n  }\n\n  toMathML(custom: MathMLMap = {}) {\n    const args = this.args.map(a => a.toMathML(custom));\n    const argsF = this.args.map((a, i) => addMFence(a, this.fn, args[i]));\n\n    if (this.fn in custom) {\n      const argsX = args.map((a, i) => ({\n        toString: () => a,\n        val: this.args[i]\n      }));\n      return custom[this.fn](...argsX);\n    }\n\n    if (this.fn === '\u2212') {\n      return argsF.length > 1 ? argsF.join('<mo value=\"\u2212\">\u2212</mo>') : `<mo rspace=\"0\" value=\"\u2212\">\u2212</mo>${argsF[0]}`;\n    }\n\n    if (isOneOf(this.fn, '+', '=', '<', '>', '\u2264', '\u2265', '\u2248', '\u225F', '\u2260')) {\n      const fn = escape(this.fn);\n      return argsF.join(`<mo value=\"${fn}\">${fn}</mo>`);\n    }\n\n    if (isOneOf(this.fn, '*', '\u00D7', '\u00B7')) {\n      let str = argsF[0];\n      for (let i = 1; i < argsF.length - 1; ++i) {\n        // We only show the \u00D7 symbol between consecutive numbers.\n        const showTimes = (this.args[0] instanceof ExprNumber &&\n                           this.args[1] instanceof ExprNumber);\n        str += (showTimes ? `<mo value=\"\u00D7\">\u00D7</mo>` : '') + argsF[1];\n      }\n      return str;\n    }\n\n    if (this.fn === '//') return argsF.join(`<mo value=\"/\">/</mo>`);\n    if (this.fn === 'sqrt') return `<msqrt>${argsF[0]}</msqrt>`;\n\n    if (isOneOf(this.fn, '/', 'root')) {\n      // Fractions or square roots don't have brackets around their arguments\n      const el = (this.fn === '/' ? 'mfrac' : 'mroot');\n      const args1 = this.args.map((a, i) => addMRow(a, args[i]));\n      return `<${el}>${args1.join('')}</${el}>`;\n    }\n\n    if (isOneOf(this.fn, 'sup', 'sub')) {\n      // Sup and sub only have brackets around their first argument.\n      const args1 = [addMRow(this.args[0], argsF[0]),\n        addMRow(this.args[1], args[1])];\n      return `<m${this.fn}>${args1.join('')}</m${this.fn}>`;\n    }\n\n    if (this.fn === 'subsup') {\n      const args1 = [addMRow(this.args[0], argsF[0]),\n        addMRow(this.args[1], args[1]), addMRow(this.args[2], args[2])];\n      return `<msubsup>${args1.join('')}</msubsup>`;\n    }\n\n    if (isOneOf(this.fn, '(', '[', '{')) {\n      return `<mfenced open=\"${this.fn}\" close=\"${BRACKETS[this.fn]}\">${argsF.join(COMMA)}</mfenced>`;\n    }\n\n    if (isOneOf(this.fn, '!', '%')) {\n      return `${argsF[0]}<mo value=\"${this.fn}\" lspace=\"0\">${this.fn}</mo>`;\n    }\n\n    if (this.fn === 'abs') {\n      return `<mfenced open=\"|\" close=\"|\">${argsF.join(COMMA)}</mfenced>`;\n    }\n\n    if (this.fn === 'bar') {\n      return `<mover>${addMRow(this.args[0], argsF[0])}<mo value=\"\u203E\">\u203E</mo></mover>`;\n    }\n\n    if (this.fn === 'vec') {\n      return `<mover>${addMRow(this.args[0], argsF[0])}<mo value=\"\u2192\">\u2192</mo></mover>`;\n    }\n\n    // TODO Implement other functions\n    const variant = isSpecialFunction(this.fn) ? ' mathvariant=\"normal\"' : '';\n    return `<mi${variant}>${this.fn}</mi><mfenced>${argsF.join(COMMA)}</mfenced>`;\n  }\n\n  toVoice(custom: MathMLMap = {}) {\n    const args = this.args.map(a => a.toVoice(custom));\n    const joined = args.join(' ');\n\n    if (this.fn in custom) {\n      const argsX = args.map((a, i) => ({\n        toString: () => a,\n        val: this.args[i]\n      }));\n      return custom[this.fn](...argsX);\n    }\n\n    if (isOneOf(this.fn, '(', '[', '{')) return joined;\n    // Maybe `open bracket ${joined} close bracket` ?\n\n    if (this.fn === 'sqrt') return `square root of ${joined}`;\n    if (this.fn === '%') return `${joined} percent`;\n    if (this.fn === '!') return `${joined} factorial`;\n    if (this.fn === '/') return `${args[0]} over ${args[1]}`;\n    if (this.fn === '//') return `${args[0]} divided by ${args[1]}`;\n\n    if (this.fn === 'sub') return joined;\n    if (this.fn === 'subsup') return `${args[0]} ${args[1]} ${supVoice(args[2])}`;\n    if (this.fn === 'sup') return `${args[0]} ${supVoice(args[1])}`;\n\n    if (VOICE_STRINGS[this.fn]) return args.join(` ${VOICE_STRINGS[this.fn]} `);\n    // TODO Implement other cases\n\n    if (isSpecialFunction(this.fn)) return `${this.fn} ${joined}`;\n    return `${this.fn} of ${joined}`;\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nexport class ExprTerm extends ExprElement {\n\n  constructor(readonly items: ExprElement[]) {\n    super();\n  }\n\n  evaluate(vars: VarMap = {}) {\n    return this.collapse().evaluate(vars);\n  }\n\n  interval(vars: VarMap = {}) {\n    return this.collapse().interval(vars);\n  }\n\n  substitute(vars: ExprMap = {}) {\n    return this.collapse().substitute(vars);\n  }\n\n  get simplified() {\n    return this.collapse().simplified;\n  }\n\n  get variables() {\n    return unique(join(...this.items.map(i => i.variables)));\n  }\n\n  get functions() {\n    return this.collapse().functions;\n  }\n\n  toString() {\n    return this.items.map(i => i.toString()).join(' ');\n  }\n\n  toMathML(custom: MathMLMap = {}) {\n    return this.items.map(i => i.toMathML(custom)).join('');\n  }\n\n  toVoice(custom: MathMLMap = {}) {\n    return this.items.map(i => i.toVoice(custom)).join(' ');\n  }\n\n  collapse() {\n    return collapseTerm(this.items).collapse();\n  }\n}\n", "// =============================================================================\n// Hilbert.js \u2013 Function Evaluation\n// (c) Mathigon\n// =============================================================================\n\n\nimport {total} from '@mathigon/core';\nimport {gcd, isBetween, lcm} from '@mathigon/fermat';\nimport {SpecialFunction} from './symbols';\n\nconst OPERATORS = ['add', 'sub', 'mul', 'div', 'sup'] as const;\ntype Functions = typeof OPERATORS[number] | SpecialFunction;\n\n\n// -----------------------------------------------------------------------------\n// Interval Utilities\n\nexport type Interval = [number, number];\nconst WHOLE = [-Infinity, Infinity] as Interval;\nconst EMPTY = [NaN, NaN] as Interval;\n\nconst HALF_PI = Math.PI / 2;\nconst TWO_PI = Math.PI * 2;\n\nconst int = (a: number, b: number) => [a - Number.EPSILON, b + Number.EPSILON] as Interval;\nconst range = (...args: number[]) => int(Math.min(...args), Math.max(...args)) as Interval;\nexport const width = (a: Interval) => Math.abs(a[1] - a[0]);\n\nexport const isWhole = (a: Interval) => a[0] === -Infinity && a[1] === Infinity;\nconst isEmpty = (a: Interval) => isNaN(a[0]) || isNaN(a[1]);\nconst isInfinite = (a: Interval) => !isFinite(a[0]) && a[0] === a[1];\n\nconst contains = (a: Interval, v: number) => isBetween(v, a[0] - Number.EPSILON, a[1] + Number.EPSILON);\nexport const hasZero = (a: Interval) => contains(a, 0);\n\n\n// -----------------------------------------------------------------------------\n// Standard Evaluation\n\nexport const evaluate: Record<Functions, (...args: number[]) => number> = {\n  add: (...args) => args.reduce((a, b) => a + b, 0),\n  sub: (...args) => (args.length > 1) ? args[0] - args[1] : -args[0],\n  mul: (...args) => args.reduce((a, b) => a * b, 1),\n  div: (a, b) => a / b,\n\n  abs: (a) => Math.abs(a),\n  round: (a) => Math.round(a),\n  floor: (a) => Math.floor(a),\n  ceil: (a) => Math.ceil(a),\n  max: (...args) => Math.max(...args),\n  min: (...args) => Math.min(...args),\n\n  mod: (a, b) => a % b,\n  lcm: (...args) => lcm(...args),\n  gcd: (...args) => gcd(...args),\n  gcf: (...args) => gcd(...args),\n\n  sup: (a, b) => Math.pow(a, b),\n  log: (a, b) => Math.log(a) / (b === undefined ? 1 : Math.log(b)),\n  exp: (a) => Math.exp(a),\n  ln: (a) => Math.log(a),\n\n  sqrt: (a) => Math.sqrt(a),\n  root: (a, b) => Math.pow(a, 1 / b),\n\n  sin: (a) => Math.sin(a),\n  cos: (a) => Math.cos(a),\n  tan: (a) => Math.tan(a),\n  sec: (a) => 1 / Math.cos(a),\n  csc: (a) => 1 / Math.sin(a),\n  cot: (a) => 1 / Math.tan(a),\n  cosec: (a) => evaluate.csc(a),\n  cotan: (a) => evaluate.cot(a),\n\n  arcsin: (a) => Math.asin(a),\n  arccos: (a) => Math.acos(a),\n  arctan: (a) => Math.atan(a),\n\n  sinh: (a) => Math.sinh(a),\n  cosh: (a) => Math.cosh(a),\n  tanh: (a) => Math.tanh(a),\n  sech: (a) => 1 / Math.cosh(a),\n  csch: (a) => 1 / Math.sinh(a),\n  coth: (a) => 1 / Math.tanh(a),\n  cosech: (a) => evaluate.csch(a)\n};\n\n\n// -----------------------------------------------------------------------------\n// Utility Functions\n\n/** Evaluate a^b */\nfunction pow(a: Interval, b: Interval): Interval {\n  // If the base a is positive:\n  if (a[0] > 0) {\n    if (b[0] >= 0) return int(a[0] ** b[0], a[1] ** b[1]);\n    return range(a[0] ** b[0], a[0] ** b[1], a[1] ** b[0], a[1] ** b[1]);\n  }\n\n  // If the exponent b is an integer:\n  const k = b[0];\n  if (Number.isInteger(k) && k === b[1]) {\n    if (k === 0) return [hasZero(a) ? 0 : 1, 1];\n    if (k % 2) return int(a[0] ** k, a[1] ** k);\n    if (hasZero(a)) return [0, Math.max(a[0] ** k, a[1] ** k)];\n    return range(a[1] ** k, a[0] ** k);\n  }\n\n  return EMPTY;  // TODO Implement this!\n}\n\n/** Shift an interval so that a[0] lies between 0 and 2 Pi. */\nfunction intervalMod(a: Interval, m = TWO_PI): Interval {\n  const d = Math.floor(a[0] / m) * m;\n  return [a[0] - d, a[1] - d];\n}\n\n\n// -----------------------------------------------------------------------------\n// Interval Evaluation\n\nexport const interval: Record<Functions, (...args: Interval[]) => Interval> = {\n  add: (...args) => int(total(args.map(a => a[0])), total(args.map(a => a[1]))),\n  sub: (a, b) => b !== undefined ? int(a[0] - b[1], a[1] - b[0]) : int(-a[1], -a[0]),\n  mul: (a, ...b) => {\n    if (b.length > 1) b = [interval.mul(...b)];\n    return range(a[0] * b[0][0], a[0] * b[0][1], a[1] * b[0][0], a[1] * b[0][1]);\n  },\n  div: (a, b) => hasZero(b)? WHOLE : range(a[0] / b[0], a[0] / b[1], a[1] / b[0], a[1] / b[1]),\n\n  abs: (a) => {\n    if (hasZero(a)) return int(0, Math.max(-a[0], a[1]));\n    return range(Math.abs(a[0]), Math.abs(a[1]));\n  },\n  round: (a) => int(Math.round(a[0]), Math.round(a[1])),\n  floor: (a) => int(Math.floor(a[0]), Math.floor(a[1])),\n  ceil: (a) => int(Math.ceil(a[0]), Math.ceil(a[1])),\n  max: (...args) => int(Math.max(...args.map(a => a[0])), Math.max(...args.map(a => a[1]))),\n  min: (...args) => int(Math.min(...args.map(a => a[0])), Math.min(...args.map(a => a[1]))),\n\n  mod: (a, b) => {\n    if (isEmpty(a) || isEmpty(b)) return EMPTY;\n    let n = a[0] / (a[0] < 0 ? b[0] : b[1]);\n    n = (n < 0) ? Math.ceil(n) : Math.floor(n);\n    return interval.sub(a, interval.mul(b, [n, n]));  // a mod b = a - n * b\n  },\n  lcm: (...args) => range(lcm(...args.map(a => a[0]))),  // TODO Review this!\n  gcd: (...args) => range(gcd(...args.map(a => a[0]))),  // TODO Review this!\n  gcf: (...args) => interval.gcd(...args),\n\n  sup: (a, b) => pow(a, b),\n  log: (a, b) => {\n    if (b !== undefined) interval.div(interval.log(a), interval.log(b));\n    return int(a[0] <= 0 ? -Infinity : Math.log(a[0]), Math.log(a[1]));\n  },\n  exp: (a) => pow([Math.E, Math.E], a),\n  ln: (a) => interval.log(a),\n\n  sqrt: (a) => pow(a, [0.5, 0.5]),\n  root: (a, b) => pow(a, interval.div([1, 1], b)),\n\n  sin: (a) => interval.cos(interval.sub(a, [HALF_PI, HALF_PI])),\n  cos: (a) => {\n    if (isEmpty(a) || isInfinite(a)) return EMPTY;\n    if (width(a) >= TWO_PI - Number.EPSILON) return [-1, 1];\n    a = intervalMod(a);\n    if (a[0] > Math.PI + Number.EPSILON) return interval.sub(interval.cos(interval.sub(a, [Math.PI, Math.PI])));\n\n    // Now we know that 0 < a[0] < pi.\n    if (a[1] < Math.PI - Number.EPSILON) return int(Math.cos(a[1]), Math.cos(a[0]));\n    if (a[1] < TWO_PI - Number.EPSILON) return int(-1, Math.max(Math.cos(a[1]), Math.cos(a[0])));\n    return int(-1, 1);\n  },\n  tan: (a) => {\n    if (isEmpty(a) || isInfinite(a)) return EMPTY;\n    a = intervalMod(a, Math.PI);\n    if (a[0] > HALF_PI + Number.EPSILON) a = interval.sub(a, [Math.PI, Math.PI]);\n    if (a[0] < -HALF_PI + Number.EPSILON || a[1] > HALF_PI - Number.EPSILON) return WHOLE;\n    return int(Math.tan(a[0]), Math.tan(a[1]));\n  },\n  sec: (a) => interval.div([1, 1], interval.cos(a)),\n  csc: (a) => interval.div([1, 1], interval.sin(a)),\n  cot: (a) => interval.div([1, 1], interval.tan(a)),\n  cosec: (a) => interval.csc(a),\n  cotan: (a) => interval.cot(a),\n\n  arcsin: (a) => {\n    if (isEmpty(a) || a[1] < -1 || a[0] > 1) return EMPTY;\n    return int(a[0] <= -1 ? -HALF_PI : Math.asin(a[0]), a[1] >= 1 ? HALF_PI : Math.asin(a[1]));\n  },\n  arccos: (a) => {\n    if (isEmpty(a) || a[1] < -1 || a[0] > 1) return EMPTY;\n    return int(a[1] >= 1 ? 0 : Math.acos(a[1]), a[0] <= -1 ? Math.PI : Math.acos(a[0]));\n  },\n  arctan: (a) => int(Math.atan(a[0]), Math.atan(a[1])),\n\n  sinh: (a) => int(Math.sinh(a[0]), Math.sinh(a[1])),\n  cosh: (a) => {\n    if (a[1] < 0) return int(Math.cosh(a[1]), Math.cosh(a[0]));\n    if (a[0] > 0) return int(Math.cosh(a[0]), Math.cosh(a[1]));\n    return int(1, Math.cosh(Math.max(-a[0], a[1])));\n  },\n  tanh: (a) => int(Math.tanh(a[0]), Math.tanh(a[1])),\n  sech: (a) => interval.div([1, 1], interval.cosh(a)),\n  csch: (a) => interval.div([1, 1], interval.sinh(a)),\n  coth: (a) => interval.div([1, 1], interval.tanh(a)),\n  cosech: (a) => interval.csch(a)\n};\n"],
  "mappings": "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",
  "names": ["unique", "words", "token", "words", "fn", "unique"]
}
