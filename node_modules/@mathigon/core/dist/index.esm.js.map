{
  "version": 3,
  "sources": ["../src/utilities.ts", "../src/arrays.ts", "../src/strings.ts", "../src/events.ts", "../src/colors.ts", "../src/cache.ts", "../src/iterable.ts"],
  "sourcesContent": ["// =============================================================================\n// Core.ts | Utility Functions\n// (c) Mathigon\n// =============================================================================\n\n\n/** Object Map Interface. */\nexport type Obj<T> = {[key: string]: T};\n\n\n/** Creates a random UID string of a given length. */\nexport function uid(n = 10) {\n  return Math.random().toString(36).substr(2, n);\n}\n\n\n/** Executes a function or returns the default value. */\nexport function run<T, S>(val: T|((...args: S[]) => T), ...args: S[]) {\n  if (val instanceof Function) return val(...args);\n  return val;\n}\n\n\n/** Checks if x is strictly equal to any one of the following arguments. */\nexport function isOneOf<T>(x: T, ...values: T[]) {\n  return values.includes(x);\n}\n\n\nconst defaultMerge = ((a: unknown[], b: unknown[]) => a.concat(b));\n\n/** Deep extends obj1 with obj2, using a custom array merge function. */\nexport function deepExtend(obj1: Obj<unknown>, obj2: Obj<unknown>, arrayMergeFn = defaultMerge) {\n  for (const i of Object.keys(obj2)) {\n    if (i in obj1 && Array.isArray(obj1[i]) && Array.isArray(obj2[i])) {\n      obj1[i] = arrayMergeFn(obj1[i] as unknown[], obj2[i] as unknown[]);\n    } else if (i in obj1 && obj1[i] instanceof Object && obj2[i] instanceof Object) {\n      deepExtend(obj1[i] as Obj<unknown>, obj2[i] as Obj<unknown>);\n    } else {\n      obj1[i] = obj2[i];\n    }\n  }\n}\n\n\n/** Replacement for setTimeout() that is synchronous for time 0. */\nexport function delay(fn: () => void, t = 0) {\n  if (t) {\n    return +setTimeout(fn, t);\n  } else {\n    fn();\n    return 0;\n  }\n}\n\n\n/** Returns a promise that resolves after a fixed time. */\nexport function wait(t: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, t));\n}\n\n\n/** Creates a new promise together with functions to resolve or reject. */\nexport function defer<T = void>() {\n  let resolve: ((value: T | PromiseLike<T>) => void) = () => undefined;\n  let reject: ((reason?: unknown) => void) = () => undefined;\n\n  const promise = new Promise<T>((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n\n  // This prevents exceptions when promises without .catch are rejected:\n  promise.catch((error) => error);\n\n  return {promise, resolve, reject};\n}\n\n\nclass CacheError extends Error {\n  constructor(readonly data: unknown) {\n    super('[Cache Error]');\n  }\n}\n\n/**\n * Function wrapper that modifies a function to cache its return values. This\n * is useful for performance intensive functions which are called repeatedly\n * with the same arguments. However it can reduce performance for functions\n * which are always called with different arguments. Note that argument\n * comparison does not work with Objects or nested arrays.\n */\nexport function cache<T, Args extends unknown[]>(fn: (...args: Args) => T) {\n  const cached = new Map<string, T|CacheError>();\n  return function(...args: Args) {\n    const argString = args.join('--');\n    if (!cached.has(argString)) {\n      try {\n        cached.set(argString, fn(...args));\n      } catch (e) {\n        cached.set(argString, new CacheError(e));\n      }\n    }\n    const value = cached.get(argString)!;\n    if (value instanceof CacheError) throw value.data;\n    return value;\n  };\n}\n\n\n/**\n * Function wrapper that prevents a function from being executed more than once\n * every t ms. This is particularly useful for optimising callbacks for\n * continues events like scroll, resize or slider move. Setting `forceDelay`\n * to `true` means that even the first function call is after the minimum\n * timout, rather than instantly.\n */\nexport function throttle<Args extends unknown[]>(fn: (...args: Args) => void, t = 0, forceDelay = false) {\n  let delay = false;\n  let repeat = false;\n\n  return (...args: Args) => {\n    if (delay) {\n      repeat = true;\n    } else {\n      if (forceDelay) {\n        repeat = true;\n      } else {\n        fn(...args);\n      }\n      delay = true;\n      setTimeout(() => {\n        if (repeat) fn(...args);\n        delay = repeat = false;\n      }, t);\n    }\n  };\n}\n\n\nfunction reviver(allowed: string[]) {\n  // Filter only specific keys in a JSON object.\n  return function(this: unknown, key: string, value: unknown) {\n    // eslint-disable-next-line no-invalid-this\n    if (!key || Array.isArray(this) || allowed.includes(key)) return value;\n  };\n}\n\n/** Safe wrapper for JSON.parse. */\nexport function safeToJSON<T>(str?: string|null, fallback?: T, allowedKeys?: string[]): T|undefined {\n  if (!str) return fallback;\n  try {\n    return JSON.parse(str, allowedKeys ? reviver(allowedKeys) : undefined) || fallback;\n  } catch (e) {\n    return fallback;\n  }\n}\n", "// =============================================================================\n// Core.ts | Array Functions\n// (c) Mathigon\n// =============================================================================\n\n\n/** Creates an array of size `n`, containing `value` at every entry. */\nexport function repeat<T>(value: T, n: number): T[] {\n  return new Array(n).fill(value);\n}\n\n\n/** Creates a 2D array of size `x` by `y`, containing `value` at every entry. */\nexport function repeat2D<T>(value: T, x: number, y: number): T[][] {\n  const result: T[][] = [];\n  for (let i = 0; i < x; ++i) {\n    result.push(repeat<T>(value, y));\n  }\n  return result;\n}\n\n\n/** Creates an array of size `n`, with the result of `fn(i)` at position i. */\nexport function tabulate<T>(fn: (i: number) => T, n: number): T[] {\n  const result: T[] = [];\n  for (let i = 0; i < n; ++i) {\n    result.push(fn(i));\n  }\n  return result;\n}\n\n\n/**\n * Creates a 2D array of size `x` by `y`, with the result of `fn(i, j)` at\n * position (i, j).\n */\nexport function tabulate2D<T>(fn: (i: number, j: number) => T, x: number, y: number): T[][] {\n  const result: T[][] = [];\n  for (let i = 0; i < x; ++i) {\n    const row: T[] = [];\n    for (let j = 0; j < y; ++j) {\n      row.push(fn(i, j));\n    }\n    result.push(row);\n  }\n  return result;\n}\n\n\n/** Creates an array of numbers from 0 to a, or from a to b. */\nexport function list(a: number, b?: number, step = 1) {\n  const arr: number[] = [];\n\n  if (b === undefined && a >= 0) {\n    for (let i = 0; i < a; i += step) arr.push(i);\n  } else if (b === undefined) {\n    for (let i = 0; i > a; i -= step) arr.push(i);\n  } else if (a <= b) {\n    for (let i = a; i <= b; i += step) arr.push(i);\n  } else {\n    for (let i = a; i >= b; i -= step) arr.push(i);\n  }\n\n  return arr;\n}\n\n\n/** Returns the last item in an array, or the ith item from the end. */\nexport function last<T>(array: T[], i = 0): T {\n  return array[array.length - 1 - i];\n}\n\n\n/** Finds the sum of all elements in an numeric array. */\nexport function total(array: number[]) {\n  return array.reduce((t, v) => t + v, 0);\n}\n\n\n/** Sorts an array by the return value when evaluating a given function. */\nexport function sortBy<T, S>(array: T[], fn: (x: T) => S, reverse = false) {\n  return array.slice(0).sort((a, b) => {\n    const x = fn(a);\n    const y = fn(b);\n    return x < y ? (reverse ? 1 : -1) : x > y ? (reverse ? -1 : 1) : 0;\n  });\n}\n\n\n/**\n * Returns a function that can be called repeatedly, and returns items of the\n * array, continuously looping\n */\nexport function loop<T>(array: T[]): () => T {\n  let i = 0;\n  return () => array[(i++) % array.length];\n}\n\n\n/** Filters all duplicate elements from an array. */\nexport function unique<T>(array: T[]): T[] {\n  return array.filter((a, i) => array.indexOf(a) === i);\n}\n\n\ntype Nested<T> = Array<T|Nested<T>>;\n\n/** Flattens a nested array into a single list. */\nexport function flatten<T = unknown>(array: Nested<T>): T[] {\n  return array.reduce((a: T[], b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);\n}\n\n\n/** Creates a cumulative array by adding its elements. */\nexport function cumulative(array: number[]) {\n  let total = 0;\n  return array.map(a => (total += a));\n}\n\n\n/** Breaks an array into chunks of size at most n. */\nexport function chunk<T>(array: T[], n: number) {\n  const chunks: T[][] = [];\n  for (let i = 0; i < array.length; i += n) {\n    chunks.push(array.slice(i, i + n));\n  }\n  return chunks;\n}\n\n\n/** Rotates the elements of an array by offset. */\nexport function rotate<T>(array: T[], offset = 1): T[] {\n  const n = array.length;\n  offset = ((offset % n) + n) % n; // Offset could initially be negative...\n\n  const start = array.slice(0, offset);\n  const end = array.slice(offset);\n  return end.concat(start);\n}\n\n\n/** Returns all elements that are in both a1 and a2.  */\nexport function intersect<T = unknown>(a1: T[], a2: T[]): T[] {\n  return a1.filter(x => a2.includes(x));\n}\n\n\n/** Returns all elements that are only in one of a1 and a2. */\nexport function difference<T>(a1: T[], a2: T[]) {\n  const notIn1 = a2.filter(a => !a1.includes(a));\n  const notIn2 = a1.filter(a => !a2.includes(a));\n  return [...notIn1, ...notIn2];\n}\n\n\n/** Join multiple Arrays */\nexport function join<T = unknown>(...arrays: T[][]): T[] {\n  return arrays.reduce((a, x) => a.concat(x), []);\n}\n\n\n/** Converts a 2D array to CSV data. */\nexport function toCSV(data: unknown[][]) {\n  return data.map(row => row.map(x => {\n    let cell = x ? `${x}` : '';\n    if (cell.match(/[,\\n\"']/)) cell = `\"${cell.replace(/\"/g, '\"\"')}\"`;\n    return cell;\n  }).join(',')).join('\\n');\n}\n\n\ntype LinkedListItem<T> = {val: T, prev: LinkedListItem<T>, next: LinkedListItem<T>};\n\n/** Converts an array to a linked list data structure. */\nexport class LinkedList<T> {\n  root?: LinkedListItem<T>;\n\n  constructor(items: T[]) {\n    const n = items.length;\n    const mapped = items.map((val) => ({val} as Partial<LinkedListItem<T>>));\n    for (const [i, m] of mapped.entries()) {\n      m.next = mapped[(i + 1) % n] as LinkedListItem<T>;\n      m.prev = mapped[(i - 1 + n) % n] as LinkedListItem<T>;\n    }\n    this.root = mapped[0] as LinkedListItem<T>;\n  }\n\n  private* traverse() {\n    let current = this.root;\n    while (current) {\n      yield current;\n      current = current.next;\n      if (current === this.root) return;\n    }\n  }\n\n  get array() {\n    return Array.from(this.traverse());\n  }\n\n  delete(node: LinkedListItem<T>) {\n    if (node === this.root) {\n      if (node.next === node) return (this.root = undefined);\n      this.root = node.next;\n    }\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n  }\n}\n\nexport enum BinarySearchType {\n  first,\n  firstGreater\n}\n\nexport type BinarySearchArray<T> = Array<{item: T, val: number}>;\n\n/**\n * Performs binary search on `array`, finding elements with value `value` based\n * on the `type` criteria. The array is assumed to be sorted (small to large)\n * in oder of the value returned by the `getValue()` method.\n */\nexport function binarySearch<T>(array: BinarySearchArray<T>, value: number, type: BinarySearchType) {\n  let low = 0;\n  let high = array.length - 1;\n  let ans = -1;\n\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    const midVal = array[mid].val;\n    if (midVal < value) {\n      // If mid < zIndex, all elements in [low, mid] are also less, so we now\n      // search in [mid + 1, high]:\n      low = mid + 1;\n    } else if (midVal > value) {\n      // If mid > zIndex, all elements in [mid + 1, high] are also greater, so\n      // we now search in [low, mid - 1]:\n      if (type === BinarySearchType.firstGreater) ans = mid;\n      high = mid - 1;\n    } else {\n      if (type === BinarySearchType.first) {\n        // If mid is equal to zIndex, we note down the last found index and then\n        // search for more in left side of mid, so we now in [low, mid - 1]:\n        ans = mid;\n        high = mid - 1;\n      } else if (type === BinarySearchType.firstGreater) {\n        low = mid + 1;\n      }\n    }\n  }\n\n  return ans;\n}\n\nexport function binaryIndexOf<T>(array: BinarySearchArray<T>, item: T, value: number) {\n  let i = binarySearch(array, value, BinarySearchType.first);\n  if (i < 0) return -1;\n  while (array[i].val === value) {\n    if (array[i].item === item) return i;\n    i += 1;\n  }\n  return -1;\n}\n", "// =============================================================================\n// Core.ts | String Functions\n// (c) Mathigon\n// =============================================================================\n\n\nimport {repeat2D, sortBy} from './arrays';\n\n\n/** Splits a string into space separated words. */\nexport function words(str: string, divider = /\\s+/) {\n  if (!str) return [];\n  return str.trim().split(divider);\n}\n\n\n/** Converts a string to title case. */\nexport function toTitleCase(str: string) {\n  return str.replace(/\\S+/g, a => a.charAt(0).toUpperCase() + a.slice(1));\n}\n\n\n/** Converts a string to camel case. */\nexport function toCamelCase(str: string) {\n  return str.toLowerCase().replace(/^-/, '')\n    .replace(/-(.)/g, (_, g) => g.toUpperCase());\n}\n\n\n/** Checks if a string is a palindrome. */\nexport function isPalindrome(str: string) {\n  return str === str.split('').reverse().join('');\n}\n\n\n/**\n * Determines the Levenshtein distance between two strings. If ignoreTrailing\n * is true, we will ignore any additional, trailing characters in s2.\n */\nexport function stringDistance(s1: string, s2: string, ignoreTrailing = false) {\n  const arr = repeat2D(0, s1.length + 1, s2.length + 1);\n  for (let i = 0; i <= s1.length; i++) arr[i][0] = i;\n  for (let i = 0; i <= s2.length; i++) arr[0][i] = i;\n\n  for (let i = 1; i <= s1.length; i++) {\n    for (let j = 1; j <= s2.length; j++) {\n      arr[i][j] = Math.min(\n        arr[i - 1][j - 1] + (s1.charAt(i - 1) === s2.charAt(j - 1) ? 0 : 1),\n        arr[i - 1][j] + 1, arr[i][j - 1] + 1);\n    }\n  }\n\n  if (ignoreTrailing) return Math.min(...arr[s1.length]);\n  return arr[s1.length][s2.length];\n}\n\n\n/** Tries to auto-correct a word from a dictionary. */\nexport function autoCorrect(word: string, dict: string[]) {\n  const maxDistance = word.length / 2;\n  const distances = dict.map(w => ({w, d: stringDistance(word, w)}))\n    .filter(({d}) => d < maxDistance);\n  const bestMatch = sortBy(distances, d => d.d)[0];\n  return bestMatch ? bestMatch.w : undefined;\n}\n", "// =============================================================================\n// Core.ts | Event Target Class\n// (c) Mathigon\n// =============================================================================\n\n\nimport {words} from './strings';\n\n\n// TODO Better typing for events\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype EventCallback = (e: any) => void;\n\n\n/** Base class for event management. */\nexport class EventTarget {\n  private events = new Map<string, EventCallback[]>();\n\n  /** Adds an event listener for one or more events. */\n  on(events: string, fn: EventCallback) {\n    for (const e of words(events)) {\n      if (!this.events.has(e)) this.events.set(e, []);\n      this.events.get(e)!.push(fn);\n    }\n  }\n\n  /** Adds a one-time event listener to one or more events. */\n  one(events: string, fn: EventCallback) {\n    const callback = (e: unknown) => {\n      this.off(events, callback);\n      fn(e);\n    };\n    this.on(events, callback);\n  }\n\n  /** Removes an event listener from one or more events. */\n  off(events: string, fn: EventCallback) {\n    for (const e of words(events)) {\n      if (this.events.has(e)) {\n        this.events.set(e, this.events.get(e)!.filter(x => x !== fn));\n      }\n    }\n  }\n\n  /** Triggers one or more events, and executes all bound event listeners. */\n  trigger(events: string, arg?: unknown) {\n    for (const e of words(events)) {\n      if (this.events.has(e)) {\n        for (const callback of this.events.get(e)!) {\n          callback(arg);\n        }\n      }\n    }\n  }\n}\n", "// =============================================================================\n// Core.ts | Color Functions\n// (c) Mathigon\n// =============================================================================\n\n\nimport {last, tabulate, total} from './arrays';\n\n\nconst shortHexRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\nconst longHexRegex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})?$/i;\nconst rgbaRegex = /rgba?\\(([0-9.]+), ?([0-9.]+), ?([0-9.]+)(, ?([0-9.]+))?\\)/;\n\nconst rainbow = ['#22ab24', '#009ea6', '#0f82f2', '#6d3bbf',\n  '#cd0e66', '#eb4726', '#fd8c00'];\n\n\nfunction pad2(str: string) {\n  return str.length === 1 ? `0${str}` : str;\n}\n\n/** Gets the color of a multi-step gradient at a given percentage p */\nfunction getColorAt(gradient: Array<Color|string>, p: number) {\n  if (p <= 0) return Color.from(gradient[0]);\n  if (p >= 1) return Color.from(last(gradient));\n\n  const r = Math.floor(p * (gradient.length - 1));\n  const q = p * (gradient.length - 1) - r;\n  return Color.mix(gradient[r + 1], gradient[r], q);\n}\n\nfunction hue2rgb(p: number, q: number, t: number) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1/6) return p + (q - p) * 6 * t;\n  if (t < 1/2) return q;\n  if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n  return p;\n}\n\n\n/** Color generation and conversion class. */\nexport class Color {\n\n  constructor(public r: number, public g: number, public b: number,\n              public a = 1) {}\n\n  /** Converts this color to a hex string. */\n  get hex() {\n    const c = [this.r, this.g, this.b].map(x => pad2(Math.round(x).toString(16)));\n    const alpha = this.a >= 1 ? '' : pad2(Math.round(this.a * 255).toString(16));\n    return `#${c.join('')}${alpha}`;\n  }\n\n  /** Converts this color to an rgba string. */\n  get rgb() {\n    const c = [this.r, this.g, this.b].map(x => Math.round(x)).join(',');\n    return `rgba(${c},${this.a})`;\n  }\n\n  /** Get the brightness of this color. */\n  get brightness() {\n    return (this.r * 299 + this.g * 587 + this.g * 114) / 1000;\n  }\n\n  /** Converts this color to an HSL array. */\n  get hsl() {\n    const r = this.r / 255;\n    const g = this.g / 255;\n    const b = this.b / 255;\n\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = (min + max) / 2;\n    const delta = max - min;\n\n    if (max === min) return [0, 0, Math.round(l * 100)];  // achromatic\n\n    let h = (r === max) ? (g - b) / delta : (g === max) ? 2 + (b - r) / delta : 4 + (r - g) / delta;\n    h = Math.min(h * 60, 360);\n    if (h < 0) h += 360;\n\n    const s = (l <= 0.5) ? delta / (max + min) : delta / (2 - max - min);\n\n    return [Math.round(h), Math.round(s * 100), Math.round(l * 100)];\n  }\n\n  get chroma() {\n    return Math.max(this.r, this.g, this.b) - Math.min(this.r, this.g, this.b);\n  }\n\n  toString() {\n    return this.rgb;\n  }\n\n  /** Creates a copy of this color. */\n  copy() {\n    return new Color(this.r, this.g, this.b, this.a);\n  }\n\n  // ---------------------------------------------------------------------------\n\n  static from(color: Color|string) {\n    if (typeof color !== 'string') return color;\n    return color.startsWith('#') ? Color.fromHex(color) : Color.fromRgb(color);\n  }\n\n  static fromRgb(color: string) {\n    const match = color.match(rgbaRegex);\n    if (!match) return new Color(0, 0, 0);\n\n    const a = match[4] ? (+match[5] || 0) : 1;\n    return new Color(+match[1], +match[2], +match[3], a);\n  }\n\n  /** Creates a Color instance from a hex string. */\n  static fromHex(hex: string) {\n    hex = hex.replace(shortHexRegex, (_m, r, g, b) => r + r + g + g + b + b);\n\n    const rgbParts = longHexRegex.exec(hex);\n    if (!rgbParts) return new Color(0, 0, 0);\n\n    return new Color(\n      parseInt(rgbParts[1], 16),\n      parseInt(rgbParts[2], 16),\n      parseInt(rgbParts[3], 16),\n      rgbParts[4] ? parseInt(rgbParts[4], 16) / 255 : 1\n    );\n  }\n\n  static fromHsl(h: number, s: number, l: number) {\n    h /= 360;\n    s /= 100;\n    l /= 100;\n\n    if (s === 0) {\n      const l1 = Math.round(l * 255);\n      return new Color(l1, l1, l1);\n    }\n\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n\n    const r = hue2rgb(p, q, h + 1/3);\n    const g = hue2rgb(p, q, h);\n    const b = hue2rgb(p, q, h - 1/3);\n    return new Color(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255));\n  }\n\n  /** Generates a rainbow gradient with a given number of steps. */\n  static rainbow(steps: number) {\n    return tabulate(x => getColorAt(rainbow, x / (steps - 1)), steps);\n  }\n\n  /** Generates a rainbow gradient with a given number of steps. */\n  static gradient(colors: Array<Color|string>, steps: number) {\n    return tabulate(x => getColorAt(colors, x / (steps - 1)), steps);\n  }\n\n  static shades(color: Color|string, steps: number, range = 0.5) {\n    const light = Color.mix('#fff', color, range);\n    const dark = Color.mix('#000', color, range);\n    return Color.gradient([light, color, dark], steps);\n  }\n\n  /** Linearly interpolates two colors or hex strings. */\n  static mix(c1: Color|string, c2: Color|string, p = 0.5) {\n    c1 = Color.from(c1);\n    c2 = Color.from(c2);\n\n    return new Color(\n      p * c1.r + (1 - p) * c2.r,\n      p * c1.g + (1 - p) * c2.g,\n      p * c1.b + (1 - p) * c2.b,\n      p * c1.a + (1 - p) * c2.a\n    );\n  }\n\n  static mixMany(colors: Color[], weights?: number[]) {\n    if (!weights) weights = colors.map(() => 1);\n    const weight = total(weights);\n\n    const hsl = colors.map(c => c.hsl);\n\n    // Hue is a circle, so there are two directions in which we could merge.\n    const hue = hsl.map(c => c[0]);\n    const altHue = hue.map(h => h < 180 ? h + 360 : h);\n\n    // We also weight the hue by its color intensity (chroma)\n    const hueWeights = weights.map((w, i) => w * Math.sqrt(colors[i].chroma));\n    const hueWeight = total(hueWeights);\n\n    const h1 = total(hue.map((h, i) => h * hueWeights[i])) / hueWeight;\n    const h2 = total(altHue.map((h, i) => h * hueWeights[i])) / hueWeight;\n    const r1 = total(hue.map((h, i) => Math.abs(h - h1) * hueWeights[i]));\n    const r2 = total(altHue.map((h, i) => Math.abs(h - h2) * hueWeights[i]));\n    const h = (r1 <= r2) ? h1 : h2 % 360;\n\n    const s = total(hsl.map((c, i) => weights![i] * c[1])) / weight;\n    const l = total(hsl.map((c, i) => weights![i] * c[2])) / weight;\n    return Color.fromHsl(h, s, l);\n  }\n}\n", "// =============================================================================\n// Core.ts | Cache Functions\n// (c) Mathigon\n// =============================================================================\n\n\n/** A basic LRU cache implementation. */\nexport class Cache<T> {\n  private store = new Map<string, {val: T, i: number}>();\n  private list: string[] = [];\n\n  constructor(readonly maxSize: number) {}\n\n  has(a: string) {\n    return this.store.has(a);\n  }\n\n  get(a: string) {\n    const item = this.store.get(a);\n    if (item) this.touch(a, item);\n    return item ? item.val : undefined;\n  }\n\n  set(a: string, b: T) {\n    // Update an existing item, if it already exists.\n    const item = this.store.get(a);\n    if (item) {\n      item.val = b;\n      this.touch(a, item);\n      return;\n    }\n\n    // Add a new item.\n    this.list.push(a);\n    this.store.set(a, {val: b, i: this.list.length});\n\n    // Remove the last item if necessary.\n    if (this.list.length > this.maxSize) {\n      const a1 = this.list.shift();\n      this.store.delete(a1!);\n    }\n  }\n\n  getOrSet(a: string, callback: (a: string) => T) {\n    const cached = this.get(a);\n    if (cached) return cached;\n\n    const calculated = callback(a);\n    this.set(a, calculated);\n    return calculated;\n  }\n\n  private touch(a: string, item: {val: T, i: number}) {\n    this.list.splice(item.i, 1).push(a);\n    item.i = this.list.length;\n  }\n}\n", "// =============================================================================\n// Core.ts | Iterator Functions\n// (c) Mathigon\n// =============================================================================\n\n\nexport function first<T>(set: Iterable<T>): T|undefined {\n  return set[Symbol.iterator]().next().value;\n}\n\n/** Iterator version of Array.concat(). */\nexport function* concat<T>(...sets: Array<Iterable<T>>): Iterable<T> {\n  for (const set of sets) yield* set;\n}\n\nexport function every<T>(set: Iterable<T>, callback: (v: T) => unknown): boolean {\n  for (const s of set) {\n    if (!callback(s)) return false;\n  }\n  return true;\n}\n\nexport function some<T>(set: Iterable<T>, callback: (v: T) => unknown): boolean {\n  for (const s of set) {\n    if (callback(s)) return true;\n  }\n  return false;\n}\n\n/** Iterator version of Array.filter(). */\nexport function* filter<T>(set: Iterable<T>, test: (v: T, i: number) => unknown): Iterable<T> {\n  let i = 0;\n  for (const s of set) {\n    if (test(s, i)) yield s;\n    i += 1;\n  }\n}\n\n/** Iterator version of Array.map(). */\nexport function* map<T, S>(set: Iterable<T>, fn: (v: T, i: number) => S): Iterable<S> {\n  let i = 0;\n  for (const s of set) {\n    yield fn(s, i);\n    i += 1;\n  }\n}\n\nexport function* flatMap<S, T>(set: Iterable<T>, map: (x: T) => Iterable<S>) {\n  for (const s of set) {\n    for (const x of map(s)) {\n      yield x;\n    }\n  }\n}\n\nexport function* pairs<S, T>(a: Iterable<S>, b: Iterable<T>): Iterable<[S, T]> {\n  for (const i of a) {\n    for (const j of b) {\n      yield [i, j];\n    }\n  }\n}\n\nexport function* listPairs<T>(list: T[]): Iterable<[T, T]> {\n  const n = list.length;\n  for (let i = 0; i < n; ++i) {\n    for (let j = i + 1; j < n; ++j) {\n      yield [list[i], list[j]];\n    }\n  }\n}\n\n/** Find the item in an iterable for which value() returns the smallest value. */\nexport function findMin<T>(items: Iterable<T>, value: (item: T) => number, max = Infinity, min?: number) {\n  let best: T|undefined = undefined;\n  let v = max;\n\n  for (const item of items) {\n    const v1 = value(item);\n    if (v1 < v) {\n      best = item;\n      v = v1;\n      if (min !== undefined && v < min) return best;\n    }\n  }\n\n  return best;\n}\n"],
  "mappings": "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",
  "names": ["delay", "repeat", "total", "BinarySearchType", "h", "map", "list"]
}
