"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __knownSymbol = (name, symbol) => {
  return (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")];
  var isAwait = false;
  var method;
  var it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw")
          throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object))
            throw TypeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BinarySearchType: () => BinarySearchType,
  Cache: () => Cache,
  Color: () => Color,
  EventTarget: () => EventTarget,
  LinkedList: () => LinkedList,
  autoCorrect: () => autoCorrect,
  binaryIndexOf: () => binaryIndexOf,
  binarySearch: () => binarySearch,
  cache: () => cache,
  chunk: () => chunk,
  concat: () => concat,
  cumulative: () => cumulative,
  deepExtend: () => deepExtend,
  defer: () => defer,
  delay: () => delay,
  difference: () => difference,
  every: () => every,
  filter: () => filter,
  findMin: () => findMin,
  first: () => first,
  flatMap: () => flatMap,
  flatten: () => flatten,
  intersect: () => intersect,
  isOneOf: () => isOneOf,
  isPalindrome: () => isPalindrome,
  join: () => join,
  last: () => last,
  list: () => list,
  listPairs: () => listPairs,
  loop: () => loop,
  map: () => map,
  pairs: () => pairs,
  repeat: () => repeat,
  repeat2D: () => repeat2D,
  rotate: () => rotate,
  run: () => run,
  safeToJSON: () => safeToJSON,
  some: () => some,
  sortBy: () => sortBy,
  stringDistance: () => stringDistance,
  tabulate: () => tabulate,
  tabulate2D: () => tabulate2D,
  throttle: () => throttle,
  toCSV: () => toCSV,
  toCamelCase: () => toCamelCase,
  toTitleCase: () => toTitleCase,
  total: () => total,
  uid: () => uid,
  unique: () => unique,
  wait: () => wait,
  words: () => words
});
module.exports = __toCommonJS(src_exports);

// src/utilities.ts
function uid(n = 10) {
  return Math.random().toString(36).substr(2, n);
}
function run(val, ...args) {
  if (val instanceof Function)
    return val(...args);
  return val;
}
function isOneOf(x, ...values) {
  return values.includes(x);
}
var defaultMerge = (a, b) => a.concat(b);
function deepExtend(obj1, obj2, arrayMergeFn = defaultMerge) {
  for (const i of Object.keys(obj2)) {
    if (i in obj1 && Array.isArray(obj1[i]) && Array.isArray(obj2[i])) {
      obj1[i] = arrayMergeFn(obj1[i], obj2[i]);
    } else if (i in obj1 && obj1[i] instanceof Object && obj2[i] instanceof Object) {
      deepExtend(obj1[i], obj2[i]);
    } else {
      obj1[i] = obj2[i];
    }
  }
}
function delay(fn, t = 0) {
  if (t) {
    return +setTimeout(fn, t);
  } else {
    fn();
    return 0;
  }
}
function wait(t) {
  return new Promise((resolve) => setTimeout(resolve, t));
}
function defer() {
  let resolve = () => void 0;
  let reject = () => void 0;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  promise.catch((error) => error);
  return { promise, resolve, reject };
}
var CacheError = class extends Error {
  constructor(data) {
    super("[Cache Error]");
    this.data = data;
  }
};
function cache(fn) {
  const cached = /* @__PURE__ */ new Map();
  return function(...args) {
    const argString = args.join("--");
    if (!cached.has(argString)) {
      try {
        cached.set(argString, fn(...args));
      } catch (e) {
        cached.set(argString, new CacheError(e));
      }
    }
    const value = cached.get(argString);
    if (value instanceof CacheError)
      throw value.data;
    return value;
  };
}
function throttle(fn, t = 0, forceDelay = false) {
  let delay2 = false;
  let repeat2 = false;
  return (...args) => {
    if (delay2) {
      repeat2 = true;
    } else {
      if (forceDelay) {
        repeat2 = true;
      } else {
        fn(...args);
      }
      delay2 = true;
      setTimeout(() => {
        if (repeat2)
          fn(...args);
        delay2 = repeat2 = false;
      }, t);
    }
  };
}
function reviver(allowed) {
  return function(key, value) {
    if (!key || Array.isArray(this) || allowed.includes(key))
      return value;
  };
}
function safeToJSON(str, fallback, allowedKeys) {
  if (!str)
    return fallback;
  try {
    return JSON.parse(str, allowedKeys ? reviver(allowedKeys) : void 0) || fallback;
  } catch (e) {
    return fallback;
  }
}

// src/arrays.ts
function repeat(value, n) {
  return new Array(n).fill(value);
}
function repeat2D(value, x, y) {
  const result = [];
  for (let i = 0; i < x; ++i) {
    result.push(repeat(value, y));
  }
  return result;
}
function tabulate(fn, n) {
  const result = [];
  for (let i = 0; i < n; ++i) {
    result.push(fn(i));
  }
  return result;
}
function tabulate2D(fn, x, y) {
  const result = [];
  for (let i = 0; i < x; ++i) {
    const row = [];
    for (let j = 0; j < y; ++j) {
      row.push(fn(i, j));
    }
    result.push(row);
  }
  return result;
}
function list(a, b, step = 1) {
  const arr = [];
  if (b === void 0 && a >= 0) {
    for (let i = 0; i < a; i += step)
      arr.push(i);
  } else if (b === void 0) {
    for (let i = 0; i > a; i -= step)
      arr.push(i);
  } else if (a <= b) {
    for (let i = a; i <= b; i += step)
      arr.push(i);
  } else {
    for (let i = a; i >= b; i -= step)
      arr.push(i);
  }
  return arr;
}
function last(array, i = 0) {
  return array[array.length - 1 - i];
}
function total(array) {
  return array.reduce((t, v) => t + v, 0);
}
function sortBy(array, fn, reverse = false) {
  return array.slice(0).sort((a, b) => {
    const x = fn(a);
    const y = fn(b);
    return x < y ? reverse ? 1 : -1 : x > y ? reverse ? -1 : 1 : 0;
  });
}
function loop(array) {
  let i = 0;
  return () => array[i++ % array.length];
}
function unique(array) {
  return array.filter((a, i) => array.indexOf(a) === i);
}
function flatten(array) {
  return array.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);
}
function cumulative(array) {
  let total2 = 0;
  return array.map((a) => total2 += a);
}
function chunk(array, n) {
  const chunks = [];
  for (let i = 0; i < array.length; i += n) {
    chunks.push(array.slice(i, i + n));
  }
  return chunks;
}
function rotate(array, offset = 1) {
  const n = array.length;
  offset = (offset % n + n) % n;
  const start = array.slice(0, offset);
  const end = array.slice(offset);
  return end.concat(start);
}
function intersect(a1, a2) {
  return a1.filter((x) => a2.includes(x));
}
function difference(a1, a2) {
  const notIn1 = a2.filter((a) => !a1.includes(a));
  const notIn2 = a1.filter((a) => !a2.includes(a));
  return [...notIn1, ...notIn2];
}
function join(...arrays) {
  return arrays.reduce((a, x) => a.concat(x), []);
}
function toCSV(data) {
  return data.map((row) => row.map((x) => {
    let cell = x ? `${x}` : "";
    if (cell.match(/[,\n"']/))
      cell = `"${cell.replace(/"/g, '""')}"`;
    return cell;
  }).join(",")).join("\n");
}
var LinkedList = class {
  constructor(items) {
    const n = items.length;
    const mapped = items.map((val) => ({ val }));
    for (const [i, m] of mapped.entries()) {
      m.next = mapped[(i + 1) % n];
      m.prev = mapped[(i - 1 + n) % n];
    }
    this.root = mapped[0];
  }
  *traverse() {
    let current = this.root;
    while (current) {
      yield current;
      current = current.next;
      if (current === this.root)
        return;
    }
  }
  get array() {
    return Array.from(this.traverse());
  }
  delete(node) {
    if (node === this.root) {
      if (node.next === node)
        return this.root = void 0;
      this.root = node.next;
    }
    node.prev.next = node.next;
    node.next.prev = node.prev;
  }
};
var BinarySearchType = /* @__PURE__ */ ((BinarySearchType2) => {
  BinarySearchType2[BinarySearchType2["first"] = 0] = "first";
  BinarySearchType2[BinarySearchType2["firstGreater"] = 1] = "firstGreater";
  return BinarySearchType2;
})(BinarySearchType || {});
function binarySearch(array, value, type) {
  let low = 0;
  let high = array.length - 1;
  let ans = -1;
  while (low <= high) {
    const mid = Math.floor((low + high) / 2);
    const midVal = array[mid].val;
    if (midVal < value) {
      low = mid + 1;
    } else if (midVal > value) {
      if (type === 1 /* firstGreater */)
        ans = mid;
      high = mid - 1;
    } else {
      if (type === 0 /* first */) {
        ans = mid;
        high = mid - 1;
      } else if (type === 1 /* firstGreater */) {
        low = mid + 1;
      }
    }
  }
  return ans;
}
function binaryIndexOf(array, item, value) {
  let i = binarySearch(array, value, 0 /* first */);
  if (i < 0)
    return -1;
  while (array[i].val === value) {
    if (array[i].item === item)
      return i;
    i += 1;
  }
  return -1;
}

// src/strings.ts
function words(str, divider = /\s+/) {
  if (!str)
    return [];
  return str.trim().split(divider);
}
function toTitleCase(str) {
  return str.replace(/\S+/g, (a) => a.charAt(0).toUpperCase() + a.slice(1));
}
function toCamelCase(str) {
  return str.toLowerCase().replace(/^-/, "").replace(/-(.)/g, (_, g) => g.toUpperCase());
}
function isPalindrome(str) {
  return str === str.split("").reverse().join("");
}
function stringDistance(s1, s2, ignoreTrailing = false) {
  const arr = repeat2D(0, s1.length + 1, s2.length + 1);
  for (let i = 0; i <= s1.length; i++)
    arr[i][0] = i;
  for (let i = 0; i <= s2.length; i++)
    arr[0][i] = i;
  for (let i = 1; i <= s1.length; i++) {
    for (let j = 1; j <= s2.length; j++) {
      arr[i][j] = Math.min(
        arr[i - 1][j - 1] + (s1.charAt(i - 1) === s2.charAt(j - 1) ? 0 : 1),
        arr[i - 1][j] + 1,
        arr[i][j - 1] + 1
      );
    }
  }
  if (ignoreTrailing)
    return Math.min(...arr[s1.length]);
  return arr[s1.length][s2.length];
}
function autoCorrect(word, dict) {
  const maxDistance = word.length / 2;
  const distances = dict.map((w) => ({ w, d: stringDistance(word, w) })).filter(({ d }) => d < maxDistance);
  const bestMatch = sortBy(distances, (d) => d.d)[0];
  return bestMatch ? bestMatch.w : void 0;
}

// src/events.ts
var EventTarget = class {
  constructor() {
    this.events = /* @__PURE__ */ new Map();
  }
  /** Adds an event listener for one or more events. */
  on(events, fn) {
    for (const e of words(events)) {
      if (!this.events.has(e))
        this.events.set(e, []);
      this.events.get(e).push(fn);
    }
  }
  /** Adds a one-time event listener to one or more events. */
  one(events, fn) {
    const callback = (e) => {
      this.off(events, callback);
      fn(e);
    };
    this.on(events, callback);
  }
  /** Removes an event listener from one or more events. */
  off(events, fn) {
    for (const e of words(events)) {
      if (this.events.has(e)) {
        this.events.set(e, this.events.get(e).filter((x) => x !== fn));
      }
    }
  }
  /** Triggers one or more events, and executes all bound event listeners. */
  trigger(events, arg) {
    for (const e of words(events)) {
      if (this.events.has(e)) {
        for (const callback of this.events.get(e)) {
          callback(arg);
        }
      }
    }
  }
};

// src/colors.ts
var shortHexRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
var longHexRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
var rgbaRegex = /rgba?\(([0-9.]+), ?([0-9.]+), ?([0-9.]+)(, ?([0-9.]+))?\)/;
var rainbow = [
  "#22ab24",
  "#009ea6",
  "#0f82f2",
  "#6d3bbf",
  "#cd0e66",
  "#eb4726",
  "#fd8c00"
];
function pad2(str) {
  return str.length === 1 ? `0${str}` : str;
}
function getColorAt(gradient, p) {
  if (p <= 0)
    return Color.from(gradient[0]);
  if (p >= 1)
    return Color.from(last(gradient));
  const r = Math.floor(p * (gradient.length - 1));
  const q = p * (gradient.length - 1) - r;
  return Color.mix(gradient[r + 1], gradient[r], q);
}
function hue2rgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
var Color = class _Color {
  constructor(r, g, b, a = 1) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  /** Converts this color to a hex string. */
  get hex() {
    const c = [this.r, this.g, this.b].map((x) => pad2(Math.round(x).toString(16)));
    const alpha = this.a >= 1 ? "" : pad2(Math.round(this.a * 255).toString(16));
    return `#${c.join("")}${alpha}`;
  }
  /** Converts this color to an rgba string. */
  get rgb() {
    const c = [this.r, this.g, this.b].map((x) => Math.round(x)).join(",");
    return `rgba(${c},${this.a})`;
  }
  /** Get the brightness of this color. */
  get brightness() {
    return (this.r * 299 + this.g * 587 + this.g * 114) / 1e3;
  }
  /** Converts this color to an HSL array. */
  get hsl() {
    const r = this.r / 255;
    const g = this.g / 255;
    const b = this.b / 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (min + max) / 2;
    const delta = max - min;
    if (max === min)
      return [0, 0, Math.round(l * 100)];
    let h = r === max ? (g - b) / delta : g === max ? 2 + (b - r) / delta : 4 + (r - g) / delta;
    h = Math.min(h * 60, 360);
    if (h < 0)
      h += 360;
    const s = l <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
    return [Math.round(h), Math.round(s * 100), Math.round(l * 100)];
  }
  get chroma() {
    return Math.max(this.r, this.g, this.b) - Math.min(this.r, this.g, this.b);
  }
  toString() {
    return this.rgb;
  }
  /** Creates a copy of this color. */
  copy() {
    return new _Color(this.r, this.g, this.b, this.a);
  }
  // ---------------------------------------------------------------------------
  static from(color) {
    if (typeof color !== "string")
      return color;
    return color.startsWith("#") ? _Color.fromHex(color) : _Color.fromRgb(color);
  }
  static fromRgb(color) {
    const match = color.match(rgbaRegex);
    if (!match)
      return new _Color(0, 0, 0);
    const a = match[4] ? +match[5] || 0 : 1;
    return new _Color(+match[1], +match[2], +match[3], a);
  }
  /** Creates a Color instance from a hex string. */
  static fromHex(hex) {
    hex = hex.replace(shortHexRegex, (_m, r, g, b) => r + r + g + g + b + b);
    const rgbParts = longHexRegex.exec(hex);
    if (!rgbParts)
      return new _Color(0, 0, 0);
    return new _Color(
      parseInt(rgbParts[1], 16),
      parseInt(rgbParts[2], 16),
      parseInt(rgbParts[3], 16),
      rgbParts[4] ? parseInt(rgbParts[4], 16) / 255 : 1
    );
  }
  static fromHsl(h, s, l) {
    h /= 360;
    s /= 100;
    l /= 100;
    if (s === 0) {
      const l1 = Math.round(l * 255);
      return new _Color(l1, l1, l1);
    }
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    const r = hue2rgb(p, q, h + 1 / 3);
    const g = hue2rgb(p, q, h);
    const b = hue2rgb(p, q, h - 1 / 3);
    return new _Color(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255));
  }
  /** Generates a rainbow gradient with a given number of steps. */
  static rainbow(steps) {
    return tabulate((x) => getColorAt(rainbow, x / (steps - 1)), steps);
  }
  /** Generates a rainbow gradient with a given number of steps. */
  static gradient(colors, steps) {
    return tabulate((x) => getColorAt(colors, x / (steps - 1)), steps);
  }
  static shades(color, steps, range = 0.5) {
    const light = _Color.mix("#fff", color, range);
    const dark = _Color.mix("#000", color, range);
    return _Color.gradient([light, color, dark], steps);
  }
  /** Linearly interpolates two colors or hex strings. */
  static mix(c1, c2, p = 0.5) {
    c1 = _Color.from(c1);
    c2 = _Color.from(c2);
    return new _Color(
      p * c1.r + (1 - p) * c2.r,
      p * c1.g + (1 - p) * c2.g,
      p * c1.b + (1 - p) * c2.b,
      p * c1.a + (1 - p) * c2.a
    );
  }
  static mixMany(colors, weights) {
    if (!weights)
      weights = colors.map(() => 1);
    const weight = total(weights);
    const hsl = colors.map((c) => c.hsl);
    const hue = hsl.map((c) => c[0]);
    const altHue = hue.map((h3) => h3 < 180 ? h3 + 360 : h3);
    const hueWeights = weights.map((w, i) => w * Math.sqrt(colors[i].chroma));
    const hueWeight = total(hueWeights);
    const h1 = total(hue.map((h3, i) => h3 * hueWeights[i])) / hueWeight;
    const h2 = total(altHue.map((h3, i) => h3 * hueWeights[i])) / hueWeight;
    const r1 = total(hue.map((h3, i) => Math.abs(h3 - h1) * hueWeights[i]));
    const r2 = total(altHue.map((h3, i) => Math.abs(h3 - h2) * hueWeights[i]));
    const h = r1 <= r2 ? h1 : h2 % 360;
    const s = total(hsl.map((c, i) => weights[i] * c[1])) / weight;
    const l = total(hsl.map((c, i) => weights[i] * c[2])) / weight;
    return _Color.fromHsl(h, s, l);
  }
};

// src/cache.ts
var Cache = class {
  constructor(maxSize) {
    this.maxSize = maxSize;
    this.store = /* @__PURE__ */ new Map();
    this.list = [];
  }
  has(a) {
    return this.store.has(a);
  }
  get(a) {
    const item = this.store.get(a);
    if (item)
      this.touch(a, item);
    return item ? item.val : void 0;
  }
  set(a, b) {
    const item = this.store.get(a);
    if (item) {
      item.val = b;
      this.touch(a, item);
      return;
    }
    this.list.push(a);
    this.store.set(a, { val: b, i: this.list.length });
    if (this.list.length > this.maxSize) {
      const a1 = this.list.shift();
      this.store.delete(a1);
    }
  }
  getOrSet(a, callback) {
    const cached = this.get(a);
    if (cached)
      return cached;
    const calculated = callback(a);
    this.set(a, calculated);
    return calculated;
  }
  touch(a, item) {
    this.list.splice(item.i, 1).push(a);
    item.i = this.list.length;
  }
};

// src/iterable.ts
function first(set) {
  return set[Symbol.iterator]().next().value;
}
function* concat(...sets) {
  for (const set of sets)
    yield* __yieldStar(set);
}
function every(set, callback) {
  for (const s of set) {
    if (!callback(s))
      return false;
  }
  return true;
}
function some(set, callback) {
  for (const s of set) {
    if (callback(s))
      return true;
  }
  return false;
}
function* filter(set, test) {
  let i = 0;
  for (const s of set) {
    if (test(s, i))
      yield s;
    i += 1;
  }
}
function* map(set, fn) {
  let i = 0;
  for (const s of set) {
    yield fn(s, i);
    i += 1;
  }
}
function* flatMap(set, map2) {
  for (const s of set) {
    for (const x of map2(s)) {
      yield x;
    }
  }
}
function* pairs(a, b) {
  for (const i of a) {
    for (const j of b) {
      yield [i, j];
    }
  }
}
function* listPairs(list2) {
  const n = list2.length;
  for (let i = 0; i < n; ++i) {
    for (let j = i + 1; j < n; ++j) {
      yield [list2[i], list2[j]];
    }
  }
}
function findMin(items, value, max = Infinity, min) {
  let best = void 0;
  let v = max;
  for (const item of items) {
    const v1 = value(item);
    if (v1 < v) {
      best = item;
      v = v1;
      if (min !== void 0 && v < min)
        return best;
    }
  }
  return best;
}
//# sourceMappingURL=index.cjs.js.map
