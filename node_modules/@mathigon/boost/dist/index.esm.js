var __knownSymbol = (name, symbol) => {
  return (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")];
  var isAwait = false;
  var method;
  var it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw")
          throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object))
            throw TypeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};

// src/ajax.ts
import { cache, deepExtend, throttle as throttle2, unique } from "@mathigon/core";

// src/elements.ts
import { isOneOf, words as words2 } from "@mathigon/core";
import { clamp, isBetween, nearlyEquals, roundTo } from "@mathigon/fermat";
import { drawCanvas, drawSVG, Point as Point3, Rectangle } from "@mathigon/euclid";

// src/animate.ts
import { defer, delay, toCamelCase, total } from "@mathigon/core";

// src/browser.ts
import { safeToJSON, throttle } from "@mathigon/core";
var STORAGE_KEY = "_M";
var UA = window.navigator.userAgent.toLowerCase();
var MOBILE_REGEX = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i;
var IOS_REGEX = /iphone|ipad|ipod/i;
var SAFARI_REGEX = /^((?!chrome|android).)*safari/i;
var _a;
var BrowserInstance = class {
  constructor() {
    this.isMobile = MOBILE_REGEX.test(UA);
    this.isRetina = (window.devicePixelRatio || 1) > 1;
    this.isTouch = !!window.Touch || "ontouchstart" in window;
    this.isChrome = !!window.chrome;
    this.isFirefox = UA.indexOf("firefox") >= 0;
    this.isAndroid = UA.indexOf("android") >= 0;
    this.isIOS = IOS_REGEX.test(UA);
    this.isSafari = IOS_REGEX.test(UA) || SAFARI_REGEX.test(UA);
    // ---------------------------------------------------------------------------
    // Loading Events
    this.loadQueue = [];
    this.loaded = false;
    // ---------------------------------------------------------------------------
    // Resize Events
    this.width = window.innerWidth;
    this.height = window.innerHeight;
    this.resizeCallbacks = [];
    // ---------------------------------------------------------------------------
    // Theme
    this.theme = { name: "light", isDark: false };
    this.themeChangedCallbacks = [];
    this.themeOverride = "";
    this.darkQuery = (_a = window.matchMedia) == null ? void 0 : _a.call(window, "(prefers-color-scheme: dark)");
    var _a2, _b;
    window.onload = () => this.afterLoad();
    document.addEventListener("DOMContentLoaded", () => this.afterLoad());
    const applyResizeThrottled = throttle(() => this.applyResize());
    window.addEventListener("resize", applyResizeThrottled);
    try {
      (_a2 = this.darkQuery) == null ? void 0 : _a2.addEventListener("change", () => this.applyThemeChange());
    } catch (e) {
      (_b = this.darkQuery) == null ? void 0 : _b.addListener(() => this.applyThemeChange());
    }
    const initial = this.getCookie("theme");
    if (initial)
      this.setTheme(initial);
    try {
      this.localStorage = window.localStorage;
    } catch (e) {
      console.warn("Unable to access Local Storage in this context.");
    }
  }
  afterLoad() {
    if (this.loaded)
      return;
    this.loaded = true;
    for (const fn of this.loadQueue)
      fn();
    setTimeout(() => this.resize());
  }
  /** Binds an event listener that is triggered when the page is loaded. */
  ready(fn) {
    if (this.loaded) {
      fn();
    } else {
      this.loadQueue.push(fn);
    }
  }
  /** Forces a re-paint. This is useful when updating transition properties. */
  redraw() {
    document.body.offsetHeight;
  }
  applyResize() {
    const newWidth = window.innerWidth;
    const newHeight = window.innerHeight;
    if (this.width === newWidth && this.height === newHeight)
      return;
    this.width = newWidth;
    this.height = newHeight;
    for (const fn of this.resizeCallbacks)
      fn({ width: this.width, height: this.height });
    $body.trigger("scroll", { top: $body.scrollTop });
  }
  onResize(fn) {
    fn({ width: this.width, height: this.height });
    this.resizeCallbacks.push(fn);
  }
  offResize(fn) {
    const i = this.resizeCallbacks.indexOf(fn);
    if (i >= 0)
      this.resizeCallbacks.splice(i, 1);
  }
  resize() {
    this.applyResize();
  }
  applyThemeChange() {
    const name = this.theme.name;
    const isDark = name === "dark" || name === "auto" && this.darkQuery.matches;
    if (isDark === this.theme.isDark)
      return;
    this.theme.isDark = isDark;
    for (const c of this.themeChangedCallbacks)
      c(this.theme);
    setTimeout(() => $html.setAttr("theme", this.themeOverride || (isDark ? "dark" : "light")));
  }
  setTheme(name) {
    if (name === this.theme.name)
      return;
    this.theme.name = name;
    this.setCookie("theme", name);
    this.applyThemeChange();
  }
  onThemeChange(fn) {
    this.themeChangedCallbacks.push(fn);
  }
  // ---------------------------------------------------------------------------
  // Location
  /** Returns the hash string of the current window. */
  getHash() {
    return window.location.hash.slice(1);
  }
  /** Set the hash string of the current window. */
  setHash(h) {
    const scroll = document.body.scrollTop;
    window.location.hash = h;
    document.body.scrollTop = scroll;
  }
  /** Set the URL of the current window. */
  setURL(url, title = "") {
    window.history.replaceState({}, title, url);
    if (title)
      window.document.title = title;
  }
  // ---------------------------------------------------------------------------
  // Cookies
  /** Returns a JSON object of all cookies. */
  getCookies() {
    const pairs = document.cookie.split(";");
    const result = {};
    for (let i = 0, n = pairs.length; i < n; ++i) {
      const pair = pairs[i].split("=");
      result[decodeURIComponent(pair[0]).trim()] = decodeURIComponent(pair[1]);
    }
    return result;
  }
  getCookie(name) {
    const v = document.cookie.match(new RegExp(`(^|;) ?${name}=([^;]*)(;|$)`));
    return v ? v[2] : void 0;
  }
  setCookie(name, value, maxAge = 60 * 60 * 24 * 365) {
    const domain = window.location.hostname.replace(/^[a-z]{2}\./, "");
    document.cookie = `${name}=${value};path=/;max-age=${maxAge};domain=${domain}`;
  }
  deleteCookie(name) {
    this.setCookie(name, "", -1);
  }
  setStorage(key, value) {
    var _a2, _b;
    const keys = (key || "").split(".");
    const storage = safeToJSON(((_a2 = this.localStorage) == null ? void 0 : _a2.getItem(STORAGE_KEY)) || void 0, {});
    let path = storage;
    for (let i = 0; i < keys.length - 1; ++i) {
      if (path[keys[i]] === void 0)
        path[keys[i]] = {};
      path = path[keys[i]];
    }
    path[keys[keys.length - 1]] = value;
    (_b = this.localStorage) == null ? void 0 : _b.setItem(STORAGE_KEY, JSON.stringify(storage));
  }
  getStorage(key) {
    var _a2;
    let path = safeToJSON((_a2 = this.localStorage) == null ? void 0 : _a2.getItem(STORAGE_KEY), {});
    if (!key)
      return path;
    const keys = (key || "").split(".");
    const lastKey = keys.pop();
    for (const k of keys) {
      if (!(k in path))
        return;
      path = path[k];
    }
    return path[lastKey];
  }
  deleteStorage(key) {
    var _a2;
    if (key) {
      this.setStorage(key, void 0);
    } else {
      (_a2 = this.localStorage) == null ? void 0 : _a2.setItem(STORAGE_KEY, "");
    }
  }
  // ---------------------------------------------------------------------------
  // Keyboard Event Handling
  /** The current active element on the page (e.g. and `<input>`). */
  getActiveInput() {
    let active = document.activeElement;
    if (active == null ? void 0 : active.shadowRoot)
      active = active.shadowRoot.activeElement;
    return active === document.body ? void 0 : $(active);
  }
  get formIsActive() {
    var _a2;
    return !!((_a2 = this.getActiveInput()) == null ? void 0 : _a2.is("input, select, textarea, [contenteditable]"));
  }
};
var Browser = window.BoostBrowser || new BrowserInstance();
window.BoostBrowser = Browser;
var IEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/;
var webkitUA = /\bAppleWebKit\/(\d+)\b/;
var EdgeUA = /\bEdge\/12\.(\d+)\b/;
var polyfill = IEUA.test(navigator.userAgent) || +(navigator.userAgent.match(EdgeUA) || [])[1] < 10547 || +(navigator.userAgent.match(webkitUA) || [])[1] < 537;
var requests = {};
function replaceSvgImports() {
  if (!polyfill)
    return;
  const uses = Array.from(document.querySelectorAll("svg > use"));
  uses.forEach(function(use) {
    const src = use.getAttribute("xlink:href");
    const [url, id] = src.split("#");
    if (!url.length || !id)
      return;
    const svg = use.parentNode;
    svg.removeChild(use);
    if (!(url in requests))
      requests[url] = fetch(url).then((r) => r.text());
    const request = requests[url];
    request.then((response) => {
      const doc = document.implementation.createHTMLDocument("");
      doc.documentElement.innerHTML = response;
      const icon = doc.getElementById(id);
      const clone = icon.cloneNode(true);
      const fragment = document.createDocumentFragment();
      while (clone.childNodes.length)
        fragment.appendChild(clone.firstChild);
      svg.appendChild(fragment);
    });
  });
}
var KEY_FALLBACKS = new Map(Object.entries({
  " ": "Space",
  "Spacebar": "Space",
  "Del": "Delete",
  "Esc": "Escape",
  "Left": "ArrowLeft",
  "Right": "ArrowRight",
  "Down": "ArrowDown",
  "Up": "ArrowUp"
}));
function keyCode(e) {
  return KEY_FALLBACKS.get(e.key) || e.key;
}
function bindAccessibilityEvents(parent) {
  const KEYS = /* @__PURE__ */ new Set(["Enter", "Space"]);
  let isDown = false;
  document.addEventListener("keyup", (e) => {
    if (KEYS.has(keyCode(e)))
      isDown = false;
  });
  (parent || document).addEventListener("keydown", (e) => {
    if (!isDown && KEYS.has(keyCode(e))) {
      isDown = true;
      const $active = Browser.getActiveInput();
      if ($active && $active.hasAttr("tabindex") && $active.tagName !== "TEXTAREA") {
        e.preventDefault();
        $active.trigger("pointerdown", e);
        $active.trigger("pointerstop", e);
        $body.trigger("pointerstop", e);
        $active.trigger("click", e);
      }
    }
  });
}

// src/animate.ts
var isReady = false;
setTimeout(() => isReady = true);
var BOUNCE_IN = "cubic-bezier(0.175, 0.885, 0.32, 1.275)";
var BOUNCE_OUT = "cubic-bezier(0.68, -0.275, 0.825, 0.115)";
var ResolvedAnimation = { cancel: () => void 0, promise: Promise.resolve() };
function animate(callback, duration) {
  if (duration === 0) {
    callback(1, 0, () => void 0);
    return ResolvedAnimation;
  }
  const startTime = Date.now();
  const deferred = defer();
  let lastTime = 0;
  let running = true;
  const cancel = () => {
    running = false;
    deferred.reject();
  };
  function getFrame() {
    if (!running)
      return;
    if (!duration || lastTime <= duration) {
      window.requestAnimationFrame(getFrame);
    }
    const time = Date.now() - startTime;
    callback(duration ? Math.min(1, time / duration) : time, time - lastTime, cancel);
    if (duration && time >= duration)
      deferred.resolve();
    lastTime = time;
  }
  getFrame();
  return { cancel, promise: deferred.promise };
}
function easeIn(type, t = 0, s = 0) {
  switch (type) {
    case "quad":
      return t ** 2;
    case "cubic":
      return t ** 3;
    case "quart":
      return t ** 4;
    case "quint":
      return t ** 5;
    case "circ":
      return 1 - Math.sqrt(1 - t ** 2);
    case "sine":
      return 1 - Math.cos(t * Math.PI / 2);
    case "exp":
      return t <= 0 ? 0 : Math.pow(2, 10 * (t - 1));
    case "back":
      if (!s)
        s = 1.70158;
      return t * t * ((s + 1) * t - s);
    case "elastic":
      if (!s)
        s = 0.3;
      return -Math.pow(2, 10 * (t - 1)) * Math.sin(((t - 1) * 2 / s - 0.5) * Math.PI);
    case "swing":
      return 0.5 - Math.cos(t * Math.PI) / 2;
    case "spring":
      return 1 - Math.cos(t * 4.5 * Math.PI) * Math.exp(-t * 6);
    case "bounce":
      if (t < 1 / 11)
        return 1 / 64 - 7.5625 * (0.5 / 11 - t) * (0.5 / 11 - t);
      if (t < 3 / 11)
        return 1 / 16 - 7.5625 * (2 / 11 - t) * (2 / 11 - t);
      if (t < 7 / 11)
        return 1 / 4 - 7.5625 * (5 / 11 - t) * (5 / 11 - t);
      return 1 - 7.5625 * (1 - t) * (1 - t);
    default:
      return t;
  }
}
function ease(type, t = 0, s = 0) {
  if (t === 0)
    return 0;
  if (t === 1)
    return 1;
  const [name, direction] = type.split("-");
  if (direction === "in")
    return easeIn(name, t, s);
  if (direction === "out")
    return 1 - easeIn(name, 1 - t, s);
  if (t <= 0.5)
    return easeIn(name, 2 * t, s) / 2;
  return 1 - easeIn(name, 2 * (1 - t), s) / 2;
}
function transition($el, properties, duration = 400, _delay = 0, easing = "ease-in-out") {
  if (!isReady) {
    Object.keys(properties).forEach((k) => {
      const p = properties[k];
      $el.css(k, Array.isArray(p) ? p[1] : p);
    });
    return ResolvedAnimation;
  }
  if (easing === "bounce-in")
    easing = BOUNCE_IN;
  if (easing === "bounce-out")
    easing = BOUNCE_OUT;
  let oldTransition = "";
  if (Browser.isSafari) {
    oldTransition = $el._el.style.transition;
    $el.css("transition", "none");
    Browser.redraw();
  }
  const currentAnimation = $el._data.animation;
  if (currentAnimation)
    currentAnimation.cancel();
  const to = {};
  const from = {};
  const deferred = defer();
  const style2 = window.getComputedStyle($el._el);
  Object.keys(properties).forEach((k) => {
    const p = properties[k];
    const k1 = toCamelCase(k);
    from[k1] = Array.isArray(p) ? p[0] : style2.getPropertyValue(k);
    to[k1] = Array.isArray(p) ? p[1] : p;
    if (_delay)
      $el.css(k, from[k1]);
  });
  const oldHeight = to.height;
  if (to.height === "auto") {
    const children = $el.children.filter((c) => c.css("position") !== "absolute");
    to.height = `${total(children.map(($c) => $c.outerHeight))}px`;
  }
  let player;
  let cancelled = false;
  delay(() => {
    if (cancelled)
      return;
    player = $el._el.animate([from, to], { duration, easing, fill: "forwards" });
    player.onfinish = () => {
      if ($el._el) {
        Object.keys(properties).forEach((k) => $el.css(k, k === "height" ? oldHeight : to[k]));
      }
      if (Browser.isSafari)
        $el.css("transition", oldTransition);
      deferred.resolve();
      player.cancel();
      $el._data.animation = void 0;
    };
  }, _delay);
  const animation = {
    cancel() {
      if (cancelled)
        return;
      cancelled = true;
      if ($el._el)
        Object.keys(properties).forEach((k) => $el.css(k, $el.css(k)));
      if (player)
        player.cancel();
      $el._data.animation = void 0;
    },
    promise: deferred.promise
  };
  setTimeout(() => $el._data.animation = animation);
  return animation;
}
var CSS_MATRIX = /matrix\([0-9.\-\s]+,[0-9.\-\s]+,[0-9.\-\s]+,[0-9.\-\s]+,([0-9.\-\s]+),([0-9.\-\s]+)\)/;
function enter($el, effect = "fade", duration = 500, _delay = 0) {
  $el.show();
  if (!isReady)
    return ResolvedAnimation;
  const opacity = $el._data.animation ? 1 : +$el.css("opacity") || 1;
  if (effect === "fade") {
    return transition($el, { opacity: [0, opacity] }, duration, _delay);
  } else if (effect === "pop") {
    const transform = $el.transform.replace(/scale\([0-9.]*\)/, "").replace(CSS_MATRIX, "translate($1px,$2px)");
    transition($el, { opacity: [0, opacity] }, duration, _delay);
    return transition($el, {
      transform: [`${transform} scale(0.5)`, `${transform} scale(1)`]
    }, duration, _delay, "bounce-in");
  } else if (effect === "descend") {
    const rules = { opacity: [0, 1], transform: ["translateY(-50%)", "none"] };
    return transition($el, rules, duration, _delay);
  } else if (effect.startsWith("draw")) {
    const l = $el.strokeLength;
    $el.css("stroke-dasharray", `${l}px`);
    if (!$el.css("opacity"))
      $el.css("opacity", 1);
    const end = effect === "draw-reverse" ? `${2 * l}px` : 0;
    const rules = { "stroke-dashoffset": [`${l}px`, end] };
    const animation = transition($el, rules, duration, _delay, "linear");
    animation.promise.then(() => $el.css("stroke-dasharray", ""));
    return animation;
  } else if (effect.startsWith("slide")) {
    const rules = { opacity: [0, opacity], transform: ["translateY(50px)", "none"] };
    if (effect.includes("down"))
      rules.transform[0] = "translateY(-50px)";
    if (effect.includes("right"))
      rules.transform[0] = "translateX(-50px)";
    if (effect.includes("left"))
      rules.transform[0] = "translateX(50px)";
    return transition($el, rules, duration, _delay);
  } else if (effect.startsWith("reveal")) {
    const rules = { opacity: [0, opacity], height: [0, "auto"] };
    if (effect.includes("left"))
      rules.transform = ["translateX(-50%)", "none"];
    if (effect.includes("right"))
      rules.transform = ["translateX(50%)", "none"];
    return transition($el, rules, duration, _delay);
  }
  return ResolvedAnimation;
}
function exit($el, effect = "fade", duration = 400, delay3 = 0, remove = false) {
  if (!$el._el)
    return ResolvedAnimation;
  if (!isReady) {
    $el.hide();
    return ResolvedAnimation;
  }
  if ($el.css("display") === "none")
    return ResolvedAnimation;
  let animation;
  if (effect === "fade") {
    animation = transition($el, { opacity: [1, 0] }, duration, delay3);
  } else if (effect === "pop") {
    const transform = $el.transform.replace(/scale\([0-9.]*\)/, "");
    transition($el, { opacity: [1, 0] }, duration, delay3);
    animation = transition($el, {
      transform: [`${transform} scale(1)`, `${transform} scale(0.5)`]
    }, duration, delay3, "bounce-out");
  } else if (effect === "ascend") {
    const rules = { opacity: [1, 0], transform: ["none", "translateY(-50%)"] };
    animation = transition($el, rules, duration, delay3);
  } else if (effect.startsWith("draw")) {
    const l = $el.strokeLength;
    $el.css("stroke-dasharray", l);
    const start = effect === "draw-reverse" ? `${2 * l}px` : 0;
    const rules = { "stroke-dashoffset": [start, `${l}px`] };
    animation = transition($el, rules, duration, delay3, "linear");
  } else if (effect.startsWith("slide")) {
    const rules = { opacity: 0, transform: "translateY(50px)" };
    if (effect.includes("up"))
      rules.transform = "translateY(-50px)";
    animation = transition($el, rules, duration, delay3);
  } else if (effect.startsWith("reveal")) {
    const rules = { opacity: 0, height: 0 };
    if (effect.includes("left"))
      rules.transform = "translateX(-50%)";
    if (effect.includes("right"))
      rules.transform = "translateX(50%)";
    animation = transition($el, rules, duration, delay3);
  }
  animation.promise.then(() => remove ? $el.remove() : $el.hide());
  return animation;
}

// src/eval.ts
var BINARY_OPS = {
  // TODO Operator overloading (e.g. add vectors or complex numbers)
  "===": (a, b) => a === b,
  "!==": (a, b) => a !== b,
  "||": (a, b) => a || b,
  "&&": (a, b) => a && b,
  // eslint-disable-next-line eqeqeq
  "==": (a, b) => a == b,
  // eslint-disable-next-line eqeqeq
  "!=": (a, b) => a != b,
  "<=": (a, b) => a <= b,
  ">=": (a, b) => a >= b,
  "**": (a, b) => a ** b,
  "<": (a, b) => a < b,
  ">": (a, b) => a > b,
  "+": (a, b) => a + b,
  "-": (a, b) => a - b,
  "*": (a, b) => a * b,
  "/": (a, b) => a / b,
  "%": (a, b) => a % b
};
var UNARY_OPS = {
  "-": (a) => -a,
  "+": (a) => +a,
  "!": (a) => !a
};
var BINARY_PRECEDENCE = {
  "||": 1,
  "&&": 2,
  "==": 3,
  "!=": 3,
  "===": 3,
  "!==": 3,
  "<": 4,
  ">": 4,
  "<=": 4,
  ">=": 4,
  "+": 5,
  "-": 5,
  "*": 6,
  "/": 6,
  "%": 6,
  "**": 7
  // TODO Exponentiation should be right-to-left.
};
var LITERALS = {
  "true": true,
  "false": false,
  "undefined": void 0
};
var SPACE = /\s/;
var DIGIT = /[0-9]/;
var IDENTIFIER_START = /[a-zA-Zα-ωΑ-Ω$_]/;
var IDENTIFIER_PART = /[0-9a-zA-Zα-ωΑ-Ω$_]/;
function parseSyntaxTree(expr) {
  const length = expr.length;
  let index = 0;
  function throwError(message) {
    throw new Error(`${message} at character ${index} of "${expr}"`);
  }
  function gobbleSpaces() {
    while (SPACE.test(expr[index]))
      index += 1;
  }
  function gobbleNumericLiteral() {
    var _a2;
    const number = ((_a2 = expr.slice(index).match(/^\d*(\.\d+)?([eE][+-]?\d+)?/)) == null ? void 0 : _a2[0]) || "";
    index += number.length;
    const char = expr[index];
    if (char && (IDENTIFIER_START.test(char) || char === ".")) {
      throwError(`Unexpected character (${number + char})`);
    }
    return { type: 5 /* Literal */, value: parseFloat(number) };
  }
  function gobbleStringLiteral() {
    const quote = expr[index];
    index += 1;
    let closed = false;
    let string = "";
    while (index < length) {
      const char = expr[index++];
      if (char === quote) {
        closed = true;
        break;
      }
      string += char;
    }
    if (!closed)
      throwError(`Unclosed quote after "${string}"`);
    return { type: 5 /* Literal */, value: string };
  }
  function gobbleIdentifier() {
    let name = expr[index];
    if (!IDENTIFIER_START.test(expr[index]))
      throwError(`Unexpected ${name}`);
    index += 1;
    while (index < length) {
      if (IDENTIFIER_PART.test(expr[index])) {
        name += expr[index++];
      } else {
        break;
      }
    }
    if (name in LITERALS) {
      return { type: 5 /* Literal */, value: LITERALS[name] };
    } else {
      return { type: 4 /* Identifier */, name };
    }
  }
  function gobbleArguments(termination) {
    const args = [];
    let closed = false;
    let lastArg = void 0;
    while (index < length) {
      if (expr[index] === termination) {
        if (lastArg)
          args.push(lastArg);
        closed = true;
        index += 1;
        break;
      } else if (expr[index] === ",") {
        args.push(lastArg || { type: 5 /* Literal */, value: void 0 });
        index += 1;
      } else {
        lastArg = gobbleExpression();
      }
    }
    if (!closed)
      throwError(`Expected ${termination}`);
    return args;
  }
  function gobbleVariable() {
    let node2;
    if (expr[index] === "(") {
      index += 1;
      node2 = gobbleExpression();
      gobbleSpaces();
      if (expr[index] === ")") {
        index += 1;
        return node2;
      } else {
        throwError("Unclosed (");
      }
    } else {
      node2 = gobbleIdentifier();
    }
    gobbleSpaces();
    while (".[(".includes(expr[index])) {
      if (expr[index] === ".") {
        index++;
        gobbleSpaces();
        node2 = {
          type: 6 /* Member */,
          object: node2,
          computed: false,
          property: gobbleIdentifier()
        };
      } else if (expr[index] === "[") {
        index++;
        node2 = {
          type: 6 /* Member */,
          object: node2,
          computed: true,
          property: gobbleExpression()
        };
        gobbleSpaces();
        if (expr[index] !== "]")
          throwError("Unclosed [");
        index++;
      } else if (expr[index] === "(") {
        index++;
        node2 = {
          type: 2 /* Call */,
          args: gobbleArguments(")"),
          callee: node2
        };
      }
      gobbleSpaces();
    }
    return node2;
  }
  function gobbleBinaryOp() {
    gobbleSpaces();
    for (const length2 of [3, 2, 1]) {
      const substr = expr.substr(index, length2);
      if (substr in BINARY_OPS) {
        index += length2;
        return substr;
      }
    }
  }
  function gobbleToken() {
    gobbleSpaces();
    const operator = expr[index];
    if (DIGIT.test(operator) || operator === ".") {
      return gobbleNumericLiteral();
    } else if (operator === "'" || operator === '"') {
      return gobbleStringLiteral();
    } else if (operator === "[") {
      index += 1;
      return { type: 0 /* Array */, elements: gobbleArguments("]") };
    } else if (operator in UNARY_OPS) {
      index += 1;
      return { type: 7 /* UnaryOp */, operator, argument: gobbleToken() };
    } else if (IDENTIFIER_START.test(operator) || operator === "(") {
      return gobbleVariable();
    }
    throwError("Expression parsing error");
  }
  function gobbleBinaryExpression() {
    let left = gobbleToken();
    let biop = gobbleBinaryOp();
    if (!biop)
      return left;
    let right = gobbleToken();
    if (!right)
      throwError(`Expected expression after ${biop}`);
    let node2;
    const stack = [left, biop, right];
    while (biop = gobbleBinaryOp()) {
      const prec = BINARY_PRECEDENCE[biop];
      const curBiop = biop;
      while (stack.length > 2 && prec <= BINARY_PRECEDENCE[stack[stack.length - 2]]) {
        right = stack.pop();
        biop = stack.pop();
        left = stack.pop();
        node2 = { type: 1 /* BinaryOp */, operator: biop, left, right };
        stack.push(node2);
      }
      node2 = gobbleToken();
      if (!node2)
        throwError(`Expected expression after ${curBiop}`);
      stack.push(curBiop, node2);
    }
    let i = stack.length - 1;
    node2 = stack[i];
    while (i > 1) {
      node2 = {
        type: 1 /* BinaryOp */,
        operator: stack[i - 1],
        left: stack[i - 2],
        right: node2
      };
      i -= 2;
    }
    return node2;
  }
  function gobbleExpression() {
    const test = gobbleBinaryExpression();
    gobbleSpaces();
    if (test && expr[index] === "?") {
      index += 1;
      const consequent = gobbleExpression();
      if (!consequent)
        throwError("Expected expression");
      gobbleSpaces();
      if (expr[index] === ":") {
        index++;
        const alternate = gobbleExpression();
        if (!alternate)
          throwError("Expected expression");
        return { type: 3 /* Conditional */, test, consequent, alternate };
      } else {
        throwError("Expected :");
      }
    } else {
      return test;
    }
  }
  const node = gobbleExpression();
  if (index < expr.length)
    throwError(`Unexpected "${expr[index]}"`);
  return node;
}
var EMPTY = [void 0, void 0];
var FORBIDDEN_KEYS = ["__proto__", "constructor", "prototype"];
function evaluate(node, context, local) {
  switch (node.type) {
    case 0 /* Array */:
      const v1 = node.elements.map((n) => evaluate(n, context, local)[0]);
      if (v1.some((v) => v === void 0))
        return EMPTY;
      return [v1, void 0];
    case 1 /* BinaryOp */:
      const left = evaluate(node.left, context, local)[0];
      const right = evaluate(node.right, context, local)[0];
      if ("+-**/%".includes(node.operator) && (left === void 0 || right === void 0))
        return EMPTY;
      return [BINARY_OPS[node.operator](left, right), void 0];
    case 2 /* Call */:
      const [fn, self] = evaluate(node.callee, context, local);
      if (fn === Function || fn === eval)
        return EMPTY;
      const args = node.args.map((n) => evaluate(n, context, local)[0]);
      if (args.some((v) => v === void 0) || typeof fn !== "function")
        return EMPTY;
      return [fn.apply(self, args), void 0];
    case 3 /* Conditional */:
      const consequent = evaluate(node.consequent, context, local);
      const alternate = evaluate(node.alternate, context, local);
      return evaluate(node.test, context, local)[0] ? consequent : alternate;
    case 4 /* Identifier */:
      if (FORBIDDEN_KEYS.includes(node.name))
        return EMPTY;
      return [local[node.name] || context[node.name], void 0];
    case 5 /* Literal */:
      return [node.value, void 0];
    case 6 /* Member */:
      const object = evaluate(node.object, context, local)[0];
      const property = node.computed ? evaluate(node.property, context, local)[0] : node.property.name;
      if (FORBIDDEN_KEYS.includes(property))
        return EMPTY;
      return object ? [object[property], object] : [void 0, void 0];
    case 7 /* UnaryOp */:
      const arg = evaluate(node.argument, context, local)[0];
      if (arg === void 0 && node.operator !== "!")
        return EMPTY;
      return [UNARY_OPS[node.operator](arg), void 0];
  }
}
function compile(expr) {
  const node = parseSyntaxTree(expr);
  if (!node)
    return (_context = {}) => void 0;
  return (context = {}, local = {}) => evaluate(node, context, local)[0];
}
var TEMPLATE = /\${([^}]+)}/g;
function compileString(expr, isAttribute = false) {
  const parts = expr.split(TEMPLATE);
  const fns = parts.map((p, i) => i % 2 ? compile(p.replace(/×/g, "*")) : void 0);
  return (context) => {
    return parts.map((p, i) => {
      if (!(i % 2))
        return p;
      const value = fns[i](context);
      return !isAttribute && typeof value === "number" && value < 0 ? `\u2013${-value}` : value;
    }).join("");
  };
}

// src/events.ts
import { delay as delay2, words } from "@mathigon/core";
import { Point } from "@mathigon/euclid";
var touchSupport = "ontouchstart" in window;
var pointerSupport = "onpointerdown" in window;
function pointerPosition(e) {
  if (e.touches) {
    const touches = e.targetTouches.length ? e.targetTouches : e.changedTouches;
    return new Point(touches[0].clientX, touches[0].clientY);
  } else {
    return new Point(e.clientX || 0, e.clientY || 0);
  }
}
function getTouches(e) {
  return e.touches || [];
}
function svgPointerPosn(event, $svg) {
  const posn = pointerPosition(event);
  return posn.transform($svg.inverseTransformMatrix);
}
function canvasPointerPosition(event, $canvas) {
  const posn = pointerPosition(event);
  const bounds = $canvas.bounds;
  const x = (posn.x - bounds.left) * $canvas.canvasWidth / bounds.width;
  const y = (posn.y - bounds.top) * $canvas.canvasHeight / bounds.height;
  return new Point(x, y);
}
function getEventTarget(event) {
  if (event instanceof PointerEvent && event.pointerType === "mouse") {
    return $(event.target);
  }
  const posn = pointerPosition(event);
  return $(document.elementFromPoint(posn.x, posn.y) || void 0);
}
function makeTapEvent($el) {
  if ($el._data["tapEvent"])
    return;
  $el._data["tapEvent"] = true;
  let start = void 0;
  $el.on("pointerdown", (e) => start = pointerPosition(e));
  $el.on("pointerup", (e) => {
    if (!start)
      return;
    const end = pointerPosition(e);
    if (Point.distance(start, end) < 6)
      $el.trigger("tap", e);
    start = void 0;
  });
  $el.on("pointercancel", () => start = void 0);
}
function makeClickOutsideEvent($el) {
  if ($el._data["clickOutsideEvent"])
    return;
  $el._data["clickOutsideEvent"] = true;
  $body.on("pointerdown", (e) => {
    const target = e.composedPath()[0] || e.target;
    if (!target || $el._el === target || $el._el.contains(target))
      return;
    $el.trigger("clickOutside", e);
  });
}
function slide($el, fns) {
  const $box = fns.$box || $el;
  let posn = pointerPosition;
  if ($box.type === "svg") {
    posn = (e) => svgPointerPosn(e, $box.$ownerSVG);
  } else if ($box.type === "canvas") {
    posn = (e) => canvasPointerPosition(e, $box);
  }
  const $parent = fns.justInside ? $el : $body;
  let startPosn = void 0;
  let lastPosn = void 0;
  let hasMoved = false;
  let pointerId = 0;
  if ($el.css("touch-action") === "auto")
    $el.css("touch-action", "none");
  $el.addClass("noselect");
  function start(e) {
    if (e.handled || getTouches(e).length > 1)
      return;
    e.preventDefault();
    hasMoved = false;
    pointerId = e.pointerId || 0;
    $parent.on("pointermove", move);
    $parent.on("pointerstop", end);
    startPosn = lastPosn = posn(e);
    if (fns.down)
      fns.down(startPosn);
  }
  function move(e) {
    if (!startPosn)
      return;
    if (pointerId && e.pointerId !== pointerId)
      return;
    e.preventDefault();
    const p = posn(e);
    if (Point.distance(p, lastPosn) < 0.5)
      return;
    if (!hasMoved && fns.start)
      fns.start(startPosn);
    if (fns.move)
      fns.move(p, startPosn, lastPosn);
    lastPosn = p;
    hasMoved = true;
  }
  function end(e, preventClick = false) {
    if (!startPosn)
      return;
    if (pointerId && e.pointerId !== pointerId)
      return;
    e.preventDefault();
    $parent.off("pointermove", move);
    $parent.off("pointerstop", end);
    if (fns.up)
      fns.up(lastPosn, startPosn);
    if (hasMoved && fns.end)
      fns.end(lastPosn, startPosn);
    if (!hasMoved && fns.click && !preventClick)
      fns.click(startPosn);
    startPosn = void 0;
  }
  $body.onKey("Escape", () => {
    if (!startPosn)
      return;
    if (hasMoved && fns.move)
      fns.move(startPosn, startPosn, lastPosn);
    lastPosn = startPosn;
    const event = document.createEvent("MouseEvent");
    event.pointerId = pointerId;
    end(event, true);
  });
  $el.on("pointerdown", start);
  if (fns.justInside)
    $el.on("mouseleave", end);
  if (fns.accessible) {
    $el.setAttr("tabindex", "0");
    document.addEventListener("keydown", (e) => {
      if (![37, 38, 39, 40].includes(e.keyCode))
        return;
      if ($el !== Browser.getActiveInput())
        return;
      const center = $el.boxCenter;
      const start2 = posn({ clientX: center.x, clientY: center.y });
      const dx = e.keyCode === 37 ? -25 : e.keyCode === 39 ? 25 : 0;
      const dy = e.keyCode === 38 ? -25 : e.keyCode === 40 ? 25 : 0;
      const end2 = start2.shift(dx, dy);
      if (fns.down)
        fns.down(start2);
      if (fns.start)
        fns.start(start2);
      if (fns.move)
        fns.move(end2, start2, start2);
      if (fns.end)
        fns.end(end2, start2);
    });
  }
}
function pointerOver($el, fns) {
  let posn = pointerPosition;
  if ($el.type === "svg") {
    posn = (e) => svgPointerPosn(e, $el.$ownerSVG);
  } else if ($el.type === "canvas") {
    posn = (e) => canvasPointerPosition(e, $el);
  }
  let over = false;
  $el.on("touchstart mouseenter", (e) => {
    if (!over && fns.enter)
      fns.enter();
    if (fns.move)
      fns.move(posn(e));
    over = true;
  }, { passive: true });
  $el.on("pointermove", (e) => {
    if (over && fns.move)
      fns.move(posn(e));
  });
  $el.on("touchend mouseleave", () => {
    if (over && fns.exit)
      fns.exit();
    over = false;
  }, { passive: true });
}
function makeScrollEvents($el) {
  if ($el._data["scrollEvents"])
    return;
  $el._data["scrollEvents"] = true;
  let ticking = false;
  let top = void 0;
  function tick() {
    const newTop = $el.scrollTop;
    if (newTop === top) {
      ticking = false;
      return;
    }
    top = newTop;
    $el.trigger("scroll", { top });
    window.requestAnimationFrame(tick);
  }
  function scroll() {
    if (!ticking)
      window.requestAnimationFrame(tick);
    ticking = true;
  }
  const target = $el.type === "window" ? window : $el._el;
  target.addEventListener("scroll", scroll);
  function touchStart() {
    window.addEventListener("touchmove", scroll);
    window.addEventListener("touchend", touchEnd);
  }
  function touchEnd() {
    window.removeEventListener("touchmove", scroll);
    window.removeEventListener("touchend", touchEnd);
  }
  $el._el.addEventListener("touchstart", function(e) {
    if (!e.handled)
      touchStart();
  });
}
function hover($el, options) {
  const $clickTarget = options.$clickTarget || $el;
  let timeout = 0;
  let active = false;
  let wasTriggeredByMouse = false;
  let wasTriggeredByFocus = false;
  function enter2() {
    if (active)
      return;
    if (options.enter)
      options.enter();
    active = true;
  }
  function exit2() {
    if (!active)
      return;
    clearTimeout(timeout);
    if (options.exit)
      options.exit();
    active = false;
  }
  $el.on("mouseover", () => {
    if (options.preventMouseover && options.preventMouseover())
      return;
    clearTimeout(timeout);
    timeout = delay2(() => {
      enter2();
      wasTriggeredByMouse = true;
    }, options.delay);
  });
  $el.on("mouseout", () => {
    if (!wasTriggeredByMouse)
      return;
    clearTimeout(timeout);
    timeout = delay2(exit2, options.exitDelay || options.delay);
  });
  $clickTarget.on("focus", () => {
    if (active || options.preventMouseover && options.preventMouseover())
      return;
    clearTimeout(timeout);
    enter2();
    wasTriggeredByFocus = true;
  });
  const onBlur = () => {
    if (!wasTriggeredByFocus)
      return;
    if (options.canFocusWithin) {
      setTimeout(() => {
        const $newActive = Browser.getActiveInput();
        if ($newActive && $newActive.hasParent($el)) {
          $newActive.one("blur", onBlur);
        } else {
          exit2();
        }
      });
    } else {
      exit2();
    }
  };
  $clickTarget.on("blur", onBlur);
  $clickTarget.on("click", () => {
    if (active && !wasTriggeredByMouse) {
      exit2();
    } else if (!active) {
      enter2();
      wasTriggeredByMouse = false;
    }
  });
  $el.on("clickOutside", exit2);
}
var observer;
function intersectionCallback(entries) {
  for (const e of entries) {
    const event = e.isIntersecting ? "enterViewport" : "exitViewport";
    setTimeout(() => $(e.target).trigger(event));
  }
}
function makeIntersectionEvents($el) {
  if ($el._data["intersectionEvents"])
    return;
  $el._data["intersectionEvents"] = true;
  if (!window.IntersectionObserver) {
    let wasVisible = false;
    $body.on("scroll", () => {
      const isVisible = $el.isInViewport;
      if (wasVisible && !isVisible) {
        $el.trigger("exitViewport");
        wasVisible = false;
      } else if (isVisible && !wasVisible) {
        $el.trigger("enterViewport");
        wasVisible = true;
      }
    });
    return;
  }
  if (!observer)
    observer = new IntersectionObserver(intersectionCallback);
  observer.observe($el._el);
}
function makeResizeEvents($el, remove = false) {
  if (remove) {
    if ($el._data["resizeObserver"])
      $el._data["resizeObserver"].disconnect();
    $el._data["resizeObserver"] = void 0;
  }
  if ($el._data["resizeObserver"])
    return;
  if (window.ResizeObserver) {
    const observer2 = new window.ResizeObserver(() => $el.trigger("resize"));
    observer2.observe($el._el);
    $el._data["resizeObserver"] = observer2;
  } else if (window.MutationObserver) {
    const observer2 = new MutationObserver(() => $el.trigger("resize"));
    observer2.observe($el._el, { attributes: true, childList: true, characterData: true, subtree: true });
    $el._data["resizeObserver"] = observer2;
  }
}
function makePointerPositionEvents($el) {
  if ($el._data["pointerPositionEvents"])
    return;
  $el._data["pointerPositionEvents"] = true;
  const parent = $el.parent;
  let isInside;
  parent.on("pointerend", () => isInside = void 0);
  parent.on("pointermove", (e) => {
    const wasInside = isInside;
    const target = getEventTarget(e);
    isInside = target.equals($el) || target.hasParent($el);
    if (wasInside !== void 0 && isInside && !wasInside)
      $el.trigger("pointerenter", e);
    if (!isInside && wasInside)
      $el.trigger("pointerleave", e);
  });
}
function makeMouseEvent(eventName, $el) {
  if ($el._data[`_${eventName}`])
    return;
  $el._data[`_${eventName}`] = true;
  if (pointerSupport) {
    $el.on(eventName.replace("mouse", "pointer"), (e) => {
      if (e.pointerType === "mouse")
        $el.trigger(eventName, e);
    });
  } else if (!touchSupport) {
    $el._el.addEventListener(eventName, (e) => $el.trigger(eventName, e));
  }
}
function makeKeyEvent($el) {
  $el.on("keydown", (e) => {
    if (e.metaKey || e.ctrlKey)
      return;
    if (Browser.isAndroid && e.keyCode === 229)
      return;
    const key = e.key || String.fromCharCode(e.which);
    const shift = !!e.shiftKey;
    $el.trigger("key", { code: e.keyCode, key, char: key, shift });
  });
  if (Browser.isAndroid && $el.type === "input") {
    $el.on("input", (e) => {
      const key = e.key || e.data[e.data.length - 1];
      $el.trigger("key", { code: void 0, key, char: key });
      $el.value = "";
    });
  }
}
var aliases = {
  scrollwheel: "DOMMouseScroll mousewheel",
  pointerdown: pointerSupport ? "pointerdown" : touchSupport ? "touchstart" : "mousedown",
  pointermove: pointerSupport ? "pointermove" : touchSupport ? "touchmove" : "mousemove",
  pointerup: pointerSupport ? "pointerup" : touchSupport ? "touchend" : "mouseup",
  pointercancel: pointerSupport ? "pointercancel" : "touchcancel",
  pointerstop: pointerSupport ? "pointerup pointercancel" : touchSupport ? "touchend touchcancel" : "mouseup"
};
var customEvents = {
  scroll: makeScrollEvents,
  tap: makeTapEvent,
  clickOutside: makeClickOutsideEvent,
  key: makeKeyEvent,
  mousedown: makeMouseEvent.bind(void 0, "mousedown"),
  mousemove: makeMouseEvent.bind(void 0, "mousemove"),
  mouseup: makeMouseEvent.bind(void 0, "mouseup"),
  pointerenter: makePointerPositionEvents,
  pointerleave: makePointerPositionEvents,
  enterViewport: makeIntersectionEvents,
  exitViewport: makeIntersectionEvents,
  resize: makeResizeEvents
};
function bindEvent($el, event, fn, options) {
  if (event in customEvents) {
    customEvents[event]($el, false);
  } else if (event in aliases) {
    const events = words(aliases[event]);
    for (const e of events)
      $el._el.addEventListener(e, fn, options);
  } else {
    $el._el.addEventListener(event, fn, options);
  }
}
function unbindEvent($el, event, fn) {
  if (event in customEvents) {
    if (!$el._events[event] || !$el._events[event].length) {
      customEvents[event]($el, true);
    }
  } else if (fn && event in aliases) {
    const events = words(aliases[event]);
    for (const e of events)
      $el._el.removeEventListener(e, fn);
  } else if (fn) {
    $el._el.removeEventListener(event, fn);
  }
}

// src/observable.ts
var batchDepth = 0;
var batchedCallbacks = /* @__PURE__ */ new Map();
function enqueueCallback(callback, state) {
  batchedCallbacks.set(callback, state);
}
function batch(callback) {
  batchDepth++;
  callback();
  batchDepth--;
  if (batchDepth === 0) {
    for (const [callback2, state] of batchedCallbacks.entries())
      callback2(state);
    batchedCallbacks.clear();
  }
}
function observe(state, parentModel) {
  const callbackMap = /* @__PURE__ */ new Map();
  const computedKeys = /* @__PURE__ */ new Map();
  const watchAllCallbacks = /* @__PURE__ */ new Set();
  let pendingCallback = void 0;
  let lastKey = 0;
  function watch(callback) {
    pendingCallback = callback;
    const result = callback(proxy, true);
    pendingCallback = void 0;
    return result;
  }
  function unwatch(callback) {
    for (const callbacks of callbackMap.values()) {
      if (callbacks.has(callback))
        callbacks.delete(callback);
    }
    watchAllCallbacks.delete(callback);
  }
  function watchAll(callback, dontRun) {
    watchAllCallbacks.add(callback);
    return dontRun ? void 0 : callback(proxy, true);
  }
  function setComputed(key, expr) {
    if (computedKeys.has(key))
      unwatch(computedKeys.get(key));
    const callback = () => {
      state[key] = expr(proxy);
      if (pendingCallback === callback)
        pendingCallback = void 0;
      triggerCallbacks(key);
    };
    computedKeys.set(key, callback);
    watch(callback);
  }
  function triggerCallbacks(key) {
    if (batchDepth > 0) {
      for (const callback of callbackMap.get(key) || [])
        enqueueCallback(callback, state);
      for (const callback of watchAllCallbacks)
        enqueueCallback(callback, state);
    } else {
      for (const callback of callbackMap.get(key) || [])
        callback(state);
      for (const callback of watchAllCallbacks)
        callback(state);
    }
  }
  function forceUpdate() {
    for (const callbacks of callbackMap.values()) {
      for (const callback of callbacks)
        callback(state);
    }
    for (const callback of watchAllCallbacks)
      callback(state);
  }
  function assign(changes, clear2) {
    if (clear2)
      state = {};
    batch(() => {
      for (const [key, value] of Object.entries(changes)) {
        if (!(key in previous))
          previous[key] = state[key];
        proxy[key] = value;
      }
    });
  }
  function getKey() {
    lastKey += 1;
    while (`_x${lastKey}` in state)
      lastKey += 1;
    return `_x${lastKey}`;
  }
  function clear() {
    state = {};
    callbackMap.clear();
    computedKeys.clear();
    lastKey = 0;
  }
  function copy() {
    return Object.assign({}, state);
  }
  let previous = {};
  function getChanges() {
    const changes = [{}, {}];
    for (const k of Object.keys(previous)) {
      if (previous[k] === state[k])
        continue;
      changes[0][k] = previous[k];
      changes[1][k] = state[k];
    }
    previous = {};
    return changes;
  }
  function inherit(key) {
    if (!parentModel)
      return;
    parentModel.watch(() => proxy[key] = parentModel[key]);
  }
  const proxy = new Proxy(state, {
    get(_, key) {
      if (key === "watch")
        return watch;
      if (key === "unwatch")
        return unwatch;
      if (key === "watchAll")
        return watchAll;
      if (key === "setComputed")
        return setComputed;
      if (key === "forceUpdate")
        return forceUpdate;
      if (key === "getChanges")
        return getChanges;
      if (key === "assign")
        return assign;
      if (key === "getKey")
        return getKey;
      if (key === "clear")
        return clear;
      if (key === "copy")
        return copy;
      if (key === "_internal")
        return [state, callbackMap];
      if (pendingCallback) {
        if (!callbackMap.has(key))
          callbackMap.set(key, /* @__PURE__ */ new Set());
        callbackMap.get(key).add(pendingCallback);
      }
      if (!(key in state))
        inherit(key);
      return state[key];
    },
    set(_, key, value) {
      if (state[key] === value)
        return true;
      if (!(key in previous))
        previous[key] = state[key];
      state[key] = value;
      if (computedKeys.has(key)) {
        unwatch(computedKeys.get(key));
        computedKeys.delete(key);
      }
      triggerCallbacks(key);
      return true;
    },
    deleteProperty(_, p) {
      delete state[p];
      callbackMap.delete(p);
      computedKeys.delete(p);
      return true;
    }
  });
  return proxy;
}

// src/svg.ts
import { chunk, last } from "@mathigon/core";
import { Point as Point2 } from "@mathigon/euclid";
var pathLength = { A: 7, C: 6, H: 1, L: 2, M: 2, Q: 4, S: 4, T: 2, V: 1, Z: 0 };
var pathSegment = /[astvzqmhlc]([^astvzqmhlc]*)/ig;
var pathPoint = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
function pathCommands(path) {
  const commands = [];
  let lastPoint = void 0;
  for (const match of path.match(pathSegment) || []) {
    const uType = match[0].toUpperCase();
    if (uType === "Z") {
      commands.push({ type: "Z", points: [] });
      continue;
    }
    const args = (match.slice(1).match(pathPoint) || []).map((p) => +p);
    const isAbsolute = uType === match[0];
    for (const [i, p] of chunk(args, pathLength[uType]).entries()) {
      let points = [];
      let type = uType === "M" && i > 0 ? "L" : uType;
      let options = void 0;
      if (uType === "H") {
        type = "L";
        points = [new Point2(p[0], isAbsolute ? (lastPoint == null ? void 0 : lastPoint.y) || 0 : 0)];
      } else if (uType === "V") {
        type = "L";
        points = [new Point2(isAbsolute ? (lastPoint == null ? void 0 : lastPoint.x) || 0 : 0, p[0])];
      } else if (uType === "A") {
        type = "A";
        points = [new Point2(p[5], p[6])];
        options = p.slice(0, 5);
      } else if ("MLCSQT".includes(uType)) {
        points = chunk(p, 2).map((q) => new Point2(q[0], q[1]));
      }
      if (!isAbsolute && lastPoint)
        points = points.map((p2) => p2.translate(lastPoint));
      lastPoint = last(points);
      commands.push({ type, points, options });
    }
  }
  return commands;
}
function parsePath(d) {
  if (!d)
    return [];
  const commands = pathCommands(d);
  return commands.map((c) => last(c.points)).filter((p) => !!p);
}
var COMMON_STYLES = [
  "font-family",
  "font-size",
  "font-style",
  "font-weight",
  "letter-spacing",
  "text-decoration",
  "color",
  "display",
  "visibility",
  "alignment-baseline",
  "baseline-shift",
  "opacity",
  "text-anchor",
  "clip",
  "clip-path",
  "clip-rule",
  "mask",
  "filter",
  "transform",
  "transform-origin",
  "white-space",
  "line-height"
];
var SVG_STYLES = [
  "fill",
  "fill-rule",
  "marker",
  "marker-start",
  "marker-mid",
  "marker-end",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-width",
  "text-rendering",
  "dominant-baseline",
  "transform-box",
  "paint-order"
];
var HTML_STYLES = [
  "padding",
  "min-width",
  "max-width",
  "height",
  "border-width",
  "border-style",
  "border-color",
  "box-sizing",
  "background",
  "width",
  "grid-template-columns",
  "text-align"
];
var REMOVE_ATTRIBUTES = ["class", "tabindex", "contenteditable"];
var DONT_INHERIT = /* @__PURE__ */ new Set(["opacity", "transform-box", "transform-origin", "border-width", "border-style", "border-color"]);
var STYLE_DEFAULTS = {
  "font-style": "normal",
  "font-weight": "400",
  "letter-spacing": "normal",
  "text-decoration": "none",
  "display": "block",
  "visibility": "visible",
  "alignment-baseline": "auto",
  "baseline-shift": "0px",
  "text-anchor": "start",
  "clip": "auto",
  "clip-path": "none",
  "clip-rule": "nonzero",
  "mask": "none",
  "opacity": "1",
  "filter": "none",
  "fill": "rgb(0, 0, 0)",
  "fill-rule": "nonzero",
  "marker": "none",
  "stroke": "none",
  "stroke-dasharray": "none",
  "stroke-dashoffset": "0px",
  "stroke-linecap": "butt",
  "stroke-linejoin": "miter",
  "stroke-width": "1px",
  "text-rendering": "auto",
  "transform": "none",
  "dominant-baseline": "auto",
  "transform-origin": "0px 0px",
  "transform-box": "view-box",
  "paint-order": "normal"
};
function cleanSVG(node) {
  var _a2, _b;
  if (node.getAttribute("hidden") || node.style.opacity === "0" || node.style.display === "none") {
    (_a2 = node.parentNode) == null ? void 0 : _a2.removeChild(node);
  } else {
    for (const child of Array.from(node.children))
      cleanSVG(child);
    if (node.tagName === "g" && node.childElementCount === 0) {
      (_b = node.parentNode) == null ? void 0 : _b.removeChild(node);
    } else {
      for (const a of REMOVE_ATTRIBUTES) {
        if (node.hasAttribute(a))
          node.removeAttribute(a);
      }
    }
  }
}
function inheritedStyle(node, prop) {
  let n = node.parentElement;
  while (n) {
    const value = n.style.getPropertyValue(prop);
    if (value)
      return value;
    n = n.parentElement;
  }
}
function copySVGStyles(source, copy, isHTML = false) {
  const style2 = window.getComputedStyle(source);
  copy.removeAttribute("style");
  const html = isHTML || source.tagName === "foreignObject";
  const properties = [...COMMON_STYLES, ...html ? HTML_STYLES : SVG_STYLES];
  for (const p of properties) {
    const value = style2.getPropertyValue(p);
    const inherited = inheritedStyle(copy, p);
    if (value === STYLE_DEFAULTS[p] && !inherited)
      continue;
    if (!DONT_INHERIT.has(p) && value === inherited)
      continue;
    copy.style.setProperty(p, value);
  }
  const sourceChildren = source.children;
  const copyChildren = copy.children;
  for (let i = 0; i < copyChildren.length; ++i) {
    copySVGStyles(sourceChildren[i], copyChildren[i], html);
  }
}

// src/elements.ts
var BaseView = class {
  constructor(_el) {
    this._el = _el;
    this._data = {};
    this._events = {};
    this.type = "default";
    _el._view = this;
  }
  get id() {
    return this._el.id;
  }
  get data() {
    return this._el.dataset;
  }
  get tagName() {
    return this._el.tagName.toUpperCase();
  }
  equals(el) {
    return this._el === el._el;
  }
  /** Adds one or more space-separated classes to this element. */
  addClass(className) {
    for (const c of words2(className))
      this._el.classList.add(c);
  }
  removeClass(className) {
    for (const c of words2(className))
      this._el.classList.remove(c);
  }
  hasClass(className) {
    return this._el.classList.contains(className);
  }
  toggleClass(className) {
    return this._el.classList.toggle(className);
  }
  /** Toggles multiple space-separated class names based on a condition. */
  setClass(className, condition) {
    if (condition) {
      this.addClass(className);
    } else {
      this.removeClass(className);
    }
  }
  attr(attr) {
    return this._el.getAttribute(attr) || "";
  }
  hasAttr(attr) {
    return this._el.hasAttribute(attr);
  }
  setAttr(attr, value) {
    if (value === void 0) {
      this.removeAttr(attr);
    } else {
      this._el.setAttribute(attr, `${value}`);
    }
  }
  removeAttr(attr) {
    this._el.removeAttribute(attr);
  }
  get attributes() {
    return Array.from(this._el.attributes || []);
  }
  get html() {
    return this._el.innerHTML || "";
  }
  set html(h) {
    this._el.innerHTML = h;
  }
  get text() {
    return this._el.textContent || "";
  }
  set text(t) {
    this._el.textContent = t;
  }
  // Required because TS doesn't allow getters and setters with different types.
  set textStr(t) {
    this._el.textContent = `${t}`;
  }
  /** Blurs this DOM element. */
  blur() {
    this._el.blur();
  }
  /** Focuses this DOM element. */
  focus() {
    this._el.focus();
  }
  // ---------------------------------------------------------------------------
  // Templates and Model Binding
  getParentModel() {
    const parent = this.parent;
    return parent ? parent.model || parent.getParentModel() : void 0;
  }
  bindModel(model, recursive = true) {
    var _a2;
    if (this.model)
      return;
    this.model = model;
    if (this.hasAttr(":for"))
      return this.makeDynamicList(model);
    for (const { name, value } of this.attributes) {
      this.makeDynamicAttribute(name, value, model);
    }
    for (const $c of this.childNodes) {
      if ($c instanceof Text) {
        if ((_a2 = $c.textContent) == null ? void 0 : _a2.includes("${")) {
          const expr = compileString($c.textContent);
          model.watch(() => $c.textContent = expr(model) || "");
        }
      } else if (recursive) {
        $c.bindModel(model);
      }
    }
  }
  bindVariable(_model, _name) {
  }
  /** Conditionally hide this element from the DOM (using placeholder comments). */
  toggleDOM(show = true) {
    if (show === !!this._el.parentNode)
      return;
    if (!this.$placeholder) {
      this.$placeholder = $(document.createComment(""));
      this.insertBefore(this.$placeholder);
    }
    if (show) {
      this.$placeholder.insertBefore(this);
    } else {
      this.detach();
    }
  }
  makeDynamicAttribute(name, value, model) {
    if (name.startsWith("@")) {
      const event = name.slice(1);
      const expr = compile(value);
      this.on(event, (e) => expr(model, { $event: e }));
    } else if (name === ":show") {
      const expr = compile(value);
      model.watch(() => this.toggle(!!expr(model)));
    } else if (name === ":if") {
      const expr = compile(value);
      model.watch(() => this.toggleDOM(!!expr(model)));
    } else if (name === ":html") {
      const expr = compile(value);
      model.watch(() => this.html = expr(model) || "");
    } else if (name === ":draw") {
      const expr = compile(value);
      model.watch(() => this.draw(expr(model)));
    } else if (name === ":class") {
      const expr = compile(value);
      const initialClass = `${this.attr("class")} `;
      model.watch(() => this.setAttr("class", initialClass + expr(model)));
    } else if (name === ":bind") {
      this.bindVariable(model, value);
    } else if (name.startsWith(":")) {
      const expr = compile(value);
      const attr = name.slice(1);
      model.watch(() => this.setAttr(attr, expr(model)));
    } else if (value.includes("${")) {
      const expr = compileString(value, true);
      model.watch(() => this.setAttr(name, expr(model) || ""));
    }
    if (name.startsWith("@") || name.startsWith(":"))
      this.removeAttr(name);
  }
  makeDynamicList(model) {
    const [name, value] = this.attr(":for").split(" in ");
    this.removeAttr(":for");
    const expr = compile(value);
    const $placeholder = $(document.createComment(""));
    this.insertBefore($placeholder);
    this.detach();
    const $cached = [];
    let visible = 0;
    model.watch(() => {
      let array = expr(model);
      if (!Array.isArray(array))
        array = [];
      for (let i = array.length; i < visible; ++i)
        $cached[i].detach();
      for (let i = visible; i < $cached.length; ++i)
        $placeholder.insertBefore($cached[i]);
      for (let i = $cached.length; i < array.length; ++i) {
        const $el = this.copy(true);
        $el.bindModel(observe({ [name]: void 0 }, model));
        $placeholder.insertBefore($el);
        $cached.push($el);
      }
      visible = array.length;
      for (let i = 0; i < visible; ++i)
        $cached[i].model[name] = array[i];
    });
  }
  // -------------------------------------------------------------------------
  // Scrolling and Dimensions
  get bounds() {
    return this._el.getBoundingClientRect();
  }
  get boundsRect() {
    const bounds = this.bounds;
    return new Rectangle(new Point3(bounds.x, bounds.y), bounds.width, bounds.height);
  }
  contains(point) {
    return this.boundsRect.contains(point);
  }
  /** Checks if this element is currently visible in the viewport. */
  get isInViewport() {
    if (this.height === 0)
      return false;
    const bounds = this.bounds;
    return isBetween(bounds.top, -bounds.height, Browser.height);
  }
  get topLeftPosition() {
    const bounds = this.bounds;
    return new Point3(bounds.left, bounds.top);
  }
  get boxCenter() {
    const box = this.bounds;
    return new Point3(box.left + box.width / 2, box.top + box.height / 2);
  }
  get scrollWidth() {
    return this._el.scrollWidth;
  }
  get scrollHeight() {
    return this._el.scrollHeight;
  }
  get scrollTop() {
    return this._el.scrollTop;
  }
  set scrollTop(y) {
    this._el.scrollTop = y;
    this.trigger("scroll", { top: y, left: this.scrollLeft });
  }
  get scrollLeft() {
    return this._el.scrollLeft;
  }
  set scrollLeft(x) {
    this._el.scrollLeft = x;
    this.trigger("scroll", { top: this.scrollTop, left: x });
  }
  /** Scrolls the element to a specific position. */
  scrollTo(pos, time = 1e3, easing = "cubic") {
    if (pos < 0)
      pos = 0;
    const startPosition = this.scrollTop;
    const distance = pos - startPosition;
    if (this._data.scrollAnimation)
      this._data.scrollAnimation.cancel();
    this._data.scrollAnimation = animate((t) => {
      const y = startPosition + distance * ease(easing, t);
      this.scrollTop = y;
      this.trigger("scroll", { top: y });
    }, time);
  }
  /** Scrolls the element by a given distance. */
  scrollBy(distance, time = 1e3, easing = "cubic") {
    if (!distance)
      return;
    this.scrollTo(this.scrollTop + distance, time, easing);
  }
  // -------------------------------------------------------------------------
  // Styles
  /**
   * Retrieves or sets CSS properties on this element. Examples:
   *   * $el.css('color');  // returns 'red'
   *   * $el.css('color', 'blue');
   *   * $el.css({color: 'blue'});
   */
  css(props, value) {
    if (value === void 0) {
      if (typeof props === "string") {
        return window.getComputedStyle(this._el).getPropertyValue(props);
      } else {
        const keys = Object.keys(props);
        for (const p of keys)
          this._el.style.setProperty(p, `${props[p]}`);
      }
    } else if (typeof props === "string") {
      this._el.style.setProperty(props, `${value}`);
    }
  }
  /** Shortcut for getting the CSS transform style of an element. */
  get transform() {
    return this.css("transform").replace("none", "");
  }
  get transformMatrix() {
    const transform = this.transform;
    if (!transform)
      return [[1, 0, 0], [0, 1, 0]];
    const coords = transform.match(/matrix\(([0-9,.\s-]*)\)/);
    if (!coords || !coords[1])
      return [[1, 0, 0], [0, 1, 0]];
    const matrix = coords[1].split(",");
    return [
      [+matrix[0], +matrix[2], +matrix[4]],
      [+matrix[1], +matrix[3], +matrix[5]]
    ];
  }
  /** Finds the x and y scale of this element. */
  get scale() {
    const matrix = this.transformMatrix;
    return [matrix[0][0], matrix[1][1]];
  }
  /** Sets the CSS transform on this element. */
  setTransform(posn, angle = 0, scale = 1) {
    let t = "";
    if (posn)
      t += `translate(${roundTo(posn.x, 0.1)}px,${roundTo(posn.y, 0.1)}px)`;
    if (angle)
      t += ` rotate(${angle}rad)`;
    if (scale)
      t += ` scale(${scale})`;
    this._el.style.transform = t;
  }
  /** Sets the CSS transform of this element to an x/y translation. */
  translate(x, y) {
    this.setTransform(new Point3(x, y));
  }
  /**
   * Makes the element visible. Use the `data-display` attribute to determine
   * how this is done. Possible options are `visibility`, to use CSS visibility,
   * or CSS display values. The default is `display: block`.
   */
  show() {
    if (this.hasAttr("hidden"))
      this.removeAttr("hidden");
    if (this.data["display"] === "visibility") {
      this._el.style.visibility = "visible";
    } else {
      this._el.style.display = this.data.display || "block";
    }
  }
  /**
   * Makes the element invisible, using CSS visibility (if
   * `data-display="visibility"`), or `display: none`.
   */
  hide() {
    if (this.data["display"] === "visibility") {
      this._el.style.visibility = "hidden";
    } else {
      this._el.style.display = "none";
    }
  }
  /** Hides or shows the element based on a boolean value. */
  toggle(show) {
    if (show) {
      this.show();
    } else {
      this.hide();
    }
  }
  // -------------------------------------------------------------------------
  // DOM Manipulation
  /** Checks if an element matches a given CSS selector. */
  is(selector) {
    if (this._el.matches)
      return this._el.matches(selector);
    return Array.from(document.querySelectorAll(selector)).includes(this._el);
  }
  /** Finds the index of an elements, in the list of its siblings. */
  index() {
    let i = 0;
    let child = this._el;
    while ((child = child.previousSibling || void 0) !== void 0)
      ++i;
    return i;
  }
  /** Adds a new child element at the beginning of this one. */
  prepend(newChild) {
    const children = this._el.childNodes;
    if (children.length) {
      this._el.insertBefore(newChild._el, children[0]);
    } else {
      this._el.appendChild(newChild._el);
    }
  }
  /** Adds a new child element at the end of this one. */
  append(newChild) {
    this._el.appendChild(newChild instanceof Text ? newChild : newChild._el);
  }
  /** Adds a new element immediately before this one, as a sibling. */
  insertBefore(newChild) {
    this.parent._el.insertBefore(newChild._el, this._el);
  }
  /** Adds a new element immediately after this one, as a sibling. */
  insertAfter(newChild) {
    const next = this._el.nextSibling;
    if (next) {
      this.parent._el.insertBefore(newChild._el, next);
    } else {
      this.parent._el.appendChild(newChild._el);
    }
  }
  /** Returns this element's next sibling, or undefined. */
  get next() {
    return $(this._el.nextSibling);
  }
  /** Returns this element's previous sibling, or undefined. */
  get prev() {
    return $(this._el.previousSibling);
  }
  /** The first child element matching a given selector. */
  $(selector) {
    return $(selector, this);
  }
  /** All child elements matching a given selector. */
  $$(selector) {
    return $$(selector, this);
  }
  /** Returns this element's parent, or undefined. */
  get parent() {
    return $(this._el.parentElement || void 0);
  }
  /** Finds all parent elements that match a specific selector. */
  parents(selector) {
    const result = [];
    let parent = this.parent;
    while (parent) {
      if (!selector || parent.is(selector))
        result.push(parent);
      parent = parent.parent;
    }
    return result;
  }
  /** Checks if this element has one of the given elements as parent. */
  hasParent(...$p) {
    const tests = $p.map((p) => p._el);
    let parent = this._el.parentNode;
    while (parent) {
      if (isOneOf(parent, ...tests))
        return true;
      parent = parent.parentNode;
    }
    return false;
  }
  /** Returns an array of all children of this element. */
  get children() {
    return Array.from(this._el.children || [], (n) => $(n));
  }
  /** Returns an array of all child nodes, including text nodes. */
  get childNodes() {
    return Array.from(this._el.childNodes, (node) => {
      if (node instanceof Comment)
        return void 0;
      if (node instanceof Text)
        return node;
      return $(node);
    }).filter((x) => x);
  }
  /** Detach and re-insert to restart CSS animations. */
  restartAnimation() {
    const n = this.next;
    const p = this.parent;
    this.detach();
    n ? n.insertBefore(this) : p.append(this);
  }
  /** Detaches an element from the DOM. */
  detach() {
    if (this._el && this._el.parentNode) {
      this._el.parentNode.removeChild(this._el);
    }
  }
  /** Removes this element. */
  remove() {
    this.detach();
  }
  /** Removes all children of this element. */
  removeChildren() {
    while (this._el.firstChild)
      this._el.removeChild(this._el.firstChild);
  }
  /** Creates a copy of this element, and optionally its children. */
  copy(recursive = true) {
    return $(this._el.cloneNode(recursive));
  }
  // -------------------------------------------------------------------------
  // Events
  /** Binds one ore more space-separated event listeners on this element. */
  on(events, callback, options) {
    for (const e of words2(events)) {
      if (e in this._events) {
        if (!this._events[e].includes(callback))
          this._events[e].push(callback);
      } else {
        this._events[e] = [callback];
      }
      bindEvent(this, e, callback, options);
    }
  }
  /** Binds a one-time event listener on this element. */
  one(events, callback, options) {
    const callbackWrap = (e) => {
      this.off(events, callbackWrap);
      callback(e);
    };
    this.on(events, callbackWrap, options);
  }
  /**
   * Removes an event listener on this element. If callback is undefined, it
   * removes all event listeners for this event.
   */
  off(events, callback) {
    for (const e of words2(events)) {
      if (e in this._events) {
        this._events[e] = callback ? this._events[e].filter((fn) => fn !== callback) : [];
      }
      unbindEvent(this, e, callback);
    }
  }
  /** Triggers a specific event on this element. */
  trigger(events, args = {}) {
    for (const e of words2(events)) {
      if (!this._events[e])
        return;
      for (const fn of this._events[e])
        fn.call(this, args);
    }
  }
  /**
   * Binds an event listener for a specific key that is pressed while this
   * element is in focus.
   */
  onKey(keys, callback, options) {
    keys = keys.replace("AllArrows", "ArrowUp ArrowDown ArrowLeft ArrowRight");
    const keyNames = new Set(words2(keys));
    const event = (options == null ? void 0 : options.up) ? "keyup" : "keydown";
    const target = this._el === document.body ? document : this._el;
    target.addEventListener(event, (e) => {
      var _a2, _b;
      const key = keyCode(e);
      if ((options == null ? void 0 : options.meta) ? !e.ctrlKey && !e.metaKey : e.ctrlKey || e.metaKey)
        return;
      if (!key || !keyNames.has(key))
        return;
      if (document.activeElement !== this._el && ((_b = (_a2 = document.activeElement) == null ? void 0 : _a2.shadowRoot) == null ? void 0 : _b.activeElement) !== this._el && Browser.formIsActive)
        return;
      callback(e, key);
    });
  }
  onAttr(name, callback) {
    const observer2 = new MutationObserver((mutations) => {
      for (const m of mutations) {
        if (m.type === "attributes" && m.attributeName === name) {
          callback(this.attr(name));
        }
      }
    });
    observer2.observe(this._el, { attributes: true });
    callback(this.attr(name), true);
  }
  /** Returns a promise that is resolved when an event is triggered. */
  onPromise(event, resolveImmediately = false) {
    if (resolveImmediately)
      return Promise.resolve();
    return new Promise((resolve) => this.one(event, () => resolve()));
  }
  // -------------------------------------------------------------------------
  // Animations
  /**
   * Animates multiple CSS properties of this element, with a given duration,
   * delay and ease function.
   */
  animate(rules, duration = 400, delay3 = 0, easing = "ease-in-out") {
    return transition(this, rules, duration, delay3, easing);
  }
  /**
   * Runs an enter animation on this element. Valid effect names are
   *   * 'fade', 'pop' and 'descend'
   *   * 'draw' and 'draw-reverse'
   *   * 'slide' and 'slide-down'
   *   * 'reveal', 'reveal-left' and 'reveal-right'
   */
  enter(effect = "fade", duration = 500, delay3 = 0) {
    return enter(this, effect, duration, delay3);
  }
  /**
   * Runs an exit animation on this element. See `.enter()` for options.
   */
  exit(effect = "fade", duration = 500, delay3 = 0, remove = false) {
    return exit(this, effect, duration, delay3, remove);
  }
  /**
   * Triggers a CSS animation in an element by adding a class and removing it
   * after the `animationEnd` event.
   */
  effect(className) {
    this.one("animationend", () => this.removeClass(`effects-${className}`));
    this.addClass(`effects-${className}`);
  }
};
var HTMLBaseView = class extends BaseView {
  get offsetTop() {
    return this._el.offsetTop;
  }
  get offsetLeft() {
    return this._el.offsetLeft;
  }
  get offsetParent() {
    return $(this._el.offsetParent || void 0);
  }
  /** Returns this element's width, including border and padding. */
  get width() {
    return this._el.offsetWidth;
  }
  /** Returns this element's height, including border and padding. */
  get height() {
    return this._el.offsetHeight;
  }
  /** Returns this element's width, excluding border and padding. */
  get innerWidth() {
    const left = parseFloat(this.css("padding-left"));
    const right = parseFloat(this.css("padding-right"));
    return this._el.clientWidth - left - right;
  }
  /** Returns this element's height, excluding border and padding. */
  get innerHeight() {
    const bottom = parseFloat(this.css("padding-bottom"));
    const top = parseFloat(this.css("padding-top"));
    return this._el.clientHeight - bottom - top;
  }
  /** Returns this element's width, including margins. */
  get outerWidth() {
    const left = parseFloat(this.css("margin-left"));
    const right = parseFloat(this.css("margin-right"));
    return this.width + left + right || 0;
  }
  /** Returns this element's height, including margins. */
  get outerHeight() {
    const bottom = parseFloat(this.css("margin-bottom"));
    const top = parseFloat(this.css("margin-top"));
    return this.height + bottom + top || 0;
  }
  /** @returns {number} */
  get positionTop() {
    let el = this._el;
    let offset = 0;
    while (el) {
      offset += el.offsetTop;
      el = el.offsetParent;
    }
    return offset;
  }
  /** @returns {number} */
  get positionLeft() {
    let el = this._el;
    let offset = 0;
    while (el) {
      offset += el.offsetLeft;
      el = el.offsetParent;
    }
    return offset;
  }
  /** Calculates the element offset relative to any other parent element. */
  offset(parent) {
    if (parent._el === this._el.offsetParent) {
      const top = this.offsetTop + parent._el.clientTop;
      const left = this.offsetLeft + parent._el.clientLeft;
      const bottom = top + this.height;
      const right = left + this.width;
      return { top, left, bottom, right };
    } else {
      const parentBox = parent._el.getBoundingClientRect();
      const box = this._el.getBoundingClientRect();
      return {
        top: box.top - parentBox.top,
        left: box.left - parentBox.left,
        bottom: box.bottom - parentBox.top,
        right: box.right - parentBox.left
      };
    }
  }
};
var SVGBaseView = class extends BaseView {
  constructor() {
    super(...arguments);
    this.type = "svg";
  }
  /** Returns the owner `<svg>` which this element is a child of. */
  get $ownerSVG() {
    return $(this._el.ownerSVGElement || void 0);
  }
  // See https://www.chromestatus.com/features/5724912467574784
  get width() {
    return this.bounds.width;
  }
  get height() {
    return this.bounds.height;
  }
  // SVG Elements don't have offset properties. We instead use the position of
  // the first non-SVG parent, plus the margin of the SVG owner, plus the SVG
  // position of the individual element. This doesn't work for absolutely
  // positioned SVG elements, and some other edge cases.
  get positionLeft() {
    const svgLeft = this._el.getBBox().x + this._el.getCTM().e;
    return this.$ownerSVG.positionLeft + svgLeft;
  }
  get positionTop() {
    const svgTop = this._el.getBBox().y + this._el.getCTM().f;
    return this.$ownerSVG.positionTop + svgTop;
  }
  get inverseTransformMatrix() {
    const m = this._el.getScreenCTM().inverse();
    const matrix = [[m.a, m.c, m.e], [m.b, m.d, m.f]];
    if (Browser.isFirefox) {
      const transform = this.transformMatrix;
      matrix[0][2] -= transform[0][2];
      matrix[1][2] -= transform[1][2];
    }
    return matrix;
  }
  setTransform(posn, angle = 0, scale = 1) {
    const t1 = posn ? `translate(${roundTo(posn.x, 0.1)} ${roundTo(posn.y, 0.1)})` : "";
    const t2 = nearlyEquals(angle, 0) ? "" : `rotate(${angle * 180 / Math.PI})`;
    const t3 = nearlyEquals(scale, 1) ? "" : `scale(${scale})`;
    this.setAttr("transform", [t1, t2, t3].join(" "));
  }
  /**
   * Finds the total stroke length of this element. Similar to the SVG
   * `getTotalLength()` function, but works for a wider variety of elements.
   */
  get strokeLength() {
    if (this._el instanceof SVGGeometryElement) {
      return this._el.getTotalLength();
    } else {
      const dim = this.bounds;
      return 2 * dim.height + 2 * dim.width;
    }
  }
  /**
   * Gets the coordinates of the point at a distance `d` along the length of the
   * stroke of this `<path>` element.
   */
  getPointAtLength(d) {
    if (this._el instanceof SVGGeometryElement) {
      const point = this._el.getPointAtLength(d);
      return new Point3(point.x, point.y);
    } else {
      return new Point3(0, 0);
    }
  }
  /**
   * Gets the coordinates of the point at a position `p` along the length of the
   * stroke of this `<path>` element, where `0 ≤ p ≤ 1`.
   */
  getPointAt(p) {
    return this.getPointAtLength(p * this.strokeLength);
  }
  /** Returns a list of all points along an SVG `<path>` element. */
  get points() {
    return parsePath(this.attr("d"));
  }
  /** Sets the list of points for an SVG `<path>` element.c*/
  set points(p) {
    const d = p.length ? `M${p.map((x) => `${x.x},${x.y}`).join("L")}` : "";
    this.setAttr("d", d);
  }
  /** Appends a new point to an SVG `<path>` element. */
  addPoint(p) {
    const d = `${this.attr("d")} L ${p.x},${p.y}`;
    this.setAttr("d", d);
  }
  /** Finds the center of an SVG `<circle>` element. */
  get center() {
    const x = +this.attr(this.tagName === "TEXT" ? "x" : "cx") || 0;
    const y = +this.attr(this.tagName === "TEXT" ? "y" : "cy") || 0;
    return new Point3(x, y);
  }
  /** Sets the center of an SVG `<circle>` or `<text>` element. */
  setCenter(c) {
    this.setAttr(this.tagName === "TEXT" ? "x" : "cx", c.x);
    this.setAttr(this.tagName === "TEXT" ? "y" : "cy", c.y);
  }
  /** Sets the end points of an SVG `<line>` element. */
  setLine(p, q) {
    this.setAttr("x1", p.x);
    this.setAttr("y1", p.y);
    this.setAttr("x2", q.x);
    this.setAttr("y2", q.y);
  }
  /** Sets the bounds of an SVG `<rectangle>` element. */
  setRect(rect) {
    this.setAttr("x", rect.p.x);
    this.setAttr("y", rect.p.y);
    this.setAttr("width", rect.w);
    this.setAttr("height", rect.h);
  }
  /** Draws a generic geometry object onto an SVG `<path>` element. */
  draw(obj, options = {}) {
    if (!obj)
      return this.setAttr("d", "");
    const attributes = {};
    for (const p of ["mark", "arrows", "round"]) {
      if (this.hasAttr(p))
        attributes[p] = this.attr(p);
    }
    if (this.hasClass("fill"))
      attributes.fill = "fill";
    if (this.hasAttr("size"))
      attributes.size = +this.attr("size") || void 0;
    this.setAttr("d", drawSVG(obj, Object.assign(options, attributes)));
  }
};
var SVGParentView2 = class extends SVGBaseView {
  /** Returns the viewport coordinates of this `<svg>` element. */
  get viewBox() {
    return this._el.viewBox.baseVal || { width: 0, height: 0 };
  }
  get $ownerSVG() {
    return this;
  }
  get positionLeft() {
    return parseInt(this.css("margin-left")) + this.parent.positionLeft;
  }
  get positionTop() {
    return parseInt(this.css("margin-top")) + this.parent.positionTop;
  }
  /** Returns the intrinsic width of this `<svg>` element. */
  get svgWidth() {
    return this.viewBox.width || this.width;
  }
  /** Returns the intrinsic height of this `<svg>` element. */
  get svgHeight() {
    return this.viewBox.height || this.height;
  }
  /** Create a new `<path>` element child and draw a geometry object onto it. */
  drawPath(obj, attributes = {}, options = {}) {
    const $el = $N("path", attributes, this);
    $el.draw(obj, options);
    return $el;
  }
  /** Converts an SVG element into a PNG, JPG or SVG data URI. */
  image(type, width, height, viewBox) {
    return __async(this, null, function* () {
      const $copy = this.copy(true);
      copySVGStyles(this._el, $copy._el);
      if (type === "svg")
        cleanSVG($copy._el);
      if (!height)
        height = width || this.svgHeight;
      if (!width)
        width = this.svgWidth;
      $copy.setAttr("width", width);
      $copy.setAttr("height", height);
      $copy.setAttr("viewBox", viewBox || this.attr("viewBox") || `0 0 ${this.svgWidth} ${this.svgHeight}`);
      $copy.setAttr("xmlns", "http://www.w3.org/2000/svg");
      const $images = $copy.$$("image");
      if (type === "svg") {
        for (const $i of $images)
          $i.setAttr("href", new URL($i.attr("href"), location.href));
      } else {
        yield Promise.all($images.map(($i) => __async(this, null, function* () {
          $i.setAttr("href", yield loadImageDataURI($i.attr("href")));
        })));
      }
      const serialised = new XMLSerializer().serializeToString($copy._el);
      const url = `data:image/svg+xml;utf8,${encodeURIComponent(serialised)}`;
      if (type === "svg")
        return url;
      const $canvas = $N("canvas", { width, height });
      if (type === "jpg") {
        $canvas.ctx.fillStyle = "white";
        $canvas.ctx.fillRect(0, 0, width, height);
      }
      const image = yield loadImage(url);
      $canvas.ctx.drawImage(image, 0, 0, width, height);
      return $canvas.image(type);
    });
  }
  downloadImage(fileName, width, height, viewBox) {
    const windowRef = Browser.isIOS ? window.open("", "_blank") : void 0;
    const isDarkTheme = Browser.theme.isDark;
    if (isDarkTheme)
      Browser.setTheme("light");
    const type = fileName.endsWith(".jpg") ? "jpg" : fileName.endsWith(".svg") ? "svg" : "png";
    const dataUri = this.image(type, width, height, viewBox);
    if (isDarkTheme)
      Browser.setTheme("dark");
    dataUri.then((href) => {
      if (windowRef)
        return windowRef.location.href = href;
      const $a = $N("a", { download: fileName, href, target: "_blank" });
      $a._el.dispatchEvent(new MouseEvent(
        "click",
        { view: window, bubbles: false, cancelable: true }
      ));
    });
  }
};
var WindowView = class extends HTMLBaseView {
  constructor() {
    super(...arguments);
    this.type = "window";
  }
  get width() {
    return window.innerWidth;
  }
  get height() {
    return window.innerHeight;
  }
  get innerWidth() {
    return window.innerWidth;
  }
  get innerHeight() {
    return window.innerHeight;
  }
  get outerWidth() {
    return window.outerWidth;
  }
  get outerHeight() {
    return window.outerHeight;
  }
  get scrollWidth() {
    return document.body.scrollWidth;
  }
  get scrollHeight() {
    return document.body.scrollHeight;
  }
  get scrollTop() {
    return window.pageYOffset;
  }
  set scrollTop(y) {
    document.body.scrollTop = document.documentElement.scrollTop = y;
    this.trigger("scroll", { top: y, left: this.scrollLeft });
  }
  get scrollLeft() {
    return window.pageXOffset;
  }
  set scrollLeft(x) {
    document.body.scrollLeft = document.documentElement.scrollLeft = x;
    this.trigger("scroll", { top: this.scrollTop, left: x });
  }
};
var FormView = class extends HTMLBaseView {
  constructor() {
    super(...arguments);
    this.type = "form";
  }
  get action() {
    return this._el.action;
  }
  /** Summarises the data for an HTML <form> element in an JSON Object. */
  get formData() {
    const data = {};
    for (const el of Array.from(this._el.elements)) {
      const id = el.name || el.id;
      if (id)
        data[id] = el.value;
    }
    return data;
  }
  get isValid() {
    return this._el.checkValidity();
  }
};
var InputView2 = class extends HTMLBaseView {
  constructor() {
    super(...arguments);
    this.type = "input";
  }
  get checked() {
    return this._el.checked || false;
  }
  set checked(value) {
    this._el.checked = value;
  }
  get value() {
    return this._el.value;
  }
  set value(v) {
    this._el.value = v;
  }
  bindVariable(model, name) {
    if (this._el.type === "checkbox") {
      const invert = name.startsWith("!");
      const inv = (t) => invert ? !t : t;
      if (invert)
        name = name.slice(1);
      if (model[name] !== void 0) {
        this.checked = inv(model[name]);
      } else if (this.hasAttr("checked")) {
        model[name] = inv(this.checked);
      }
      this.on("change", () => model[name] = inv(this.checked));
      model.watch(() => this.checked = inv(model[name]));
      return;
    }
    if (this._el.type === "number") {
      const min = this.hasAttr("min") ? +this.attr("min") : -Infinity;
      const max = this.hasAttr("max") ? +this.attr("max") : Infinity;
      this.change((v) => {
        if (v)
          model[name] = clamp(+v, min, max);
      });
    } else {
      this.change((v) => model[name] = v);
    }
    if (model[name] !== void 0) {
      this.value = model[name];
    } else if (this.value) {
      model[name] = this.value;
    }
    this.on("blur", () => this.value = model[name]);
    model.watch(() => {
      if (document.activeElement !== this._el)
        this.value = model[name];
    });
  }
  /** Polyfill for type and inputmode attributes. */
  setInputPattern(value) {
    if (isNaN(+value))
      return;
    const digitsOnly = value.match(/^[0-9]+$/);
    this.setAttr("inputmode", digitsOnly ? "numeric" : "decimal");
    if (digitsOnly)
      this.setAttr("pattern", "[0-9]*");
  }
  /** Binds a change event listener. */
  change(callback) {
    let value = this.value || "";
    this.on("focus", () => value = this.value);
    this.on("change keyup input paste", () => {
      if (this.value === value)
        return;
      value = this.value;
      callback(value);
    });
  }
  validate(callback) {
    this.change((value) => this.setValidity(callback(value)));
  }
  setValidity(str) {
    this._el.setCustomValidity(str);
  }
  get isValid() {
    return this._el.checkValidity();
  }
};
var CanvasView2 = class extends HTMLBaseView {
  constructor() {
    super(...arguments);
    this.type = "canvas";
  }
  /** Returns the drawing context for a `<canvas>` element. */
  getContext(c = "2d", options = {}) {
    return this._el.getContext(c, options);
  }
  /** Converts a Canvas element into a PNG or JPEG data URI. */
  image(type = "png") {
    return this._el.toDataURL(type === "png" ? "image/png" : "image/jpeg");
  }
  /** Returns the intrinsic pixel width of this `<canvas>` element. */
  get canvasWidth() {
    return this._el.width;
  }
  /** Returns the intrinsic pixel height of this `<canvas>` element. */
  get canvasHeight() {
    return this._el.height;
  }
  /** Cached reference to the 2D context for this `<canvas>` element. */
  get ctx() {
    if (!this._ctx)
      this._ctx = this.getContext();
    return this._ctx;
  }
  /** Draws a generic geometry object ont a `<canvas>` element. */
  draw(obj, options = {}) {
    this.ctx.save();
    drawCanvas(this.ctx, obj, options);
    this.ctx.restore();
  }
  /** Clears this canvas. */
  clear() {
    this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
  }
  /** Clears this canvas. */
  fill(color) {
    this.ctx.save();
    this.ctx.fillStyle = color;
    this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
    this.ctx.restore();
  }
  /** Erase a specific circle of the canvas. */
  clearCircle(center, radius) {
    this.ctx.save();
    this.ctx.globalCompositeOperation = "destination-out";
    this.ctx.beginPath();
    this.ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI, false);
    this.ctx.fill();
    this.ctx.restore();
  }
  downloadImage(fileName) {
    const href = this.image(fileName.endsWith(".jpg") ? "jpg" : "png");
    const $a = $N("a", { download: fileName, href, target: "_blank" });
    $a._el.dispatchEvent(new MouseEvent(
      "click",
      { view: window, bubbles: false, cancelable: true }
    ));
  }
};
var MediaView = class extends HTMLBaseView {
  /** Starts playback on a media element. */
  play() {
    return this._el.play() || Promise.resolve();
  }
  /** Pauses playback on a media element. */
  pause() {
    return this._el.pause();
  }
};
var SVG_TAGS = [
  "path",
  "rect",
  "circle",
  "ellipse",
  "polygon",
  "polyline",
  "g",
  "defs",
  "marker",
  "line",
  "text",
  "tspan",
  "pattern",
  "mask",
  "svg",
  "foreignObject",
  "image",
  "use",
  "clipPath",
  "linearGradient",
  "radialGradient"
];
function $(query, context) {
  if (!query)
    return void 0;
  const c = context ? context._el : document.documentElement;
  const el = typeof query === "string" ? c.querySelector(query) : query;
  if (!el)
    return void 0;
  if (el._view)
    return el._view;
  const tagName = (el.tagName || "").toLowerCase();
  if (tagName === "svg") {
    return new SVGParentView2(el);
  } else if (tagName === "canvas") {
    return new CanvasView2(el);
  } else if (tagName === "form") {
    return new FormView(el);
  } else if (tagName === "input" || tagName === "select" || tagName === "textarea") {
    return new InputView2(el);
  } else if (tagName === "video" || tagName === "audio") {
    return new MediaView(el);
  } else if (SVG_TAGS.includes(tagName)) {
    return new SVGBaseView(el);
  } else {
    return new HTMLBaseView(el);
  }
}
function $$(selector, context) {
  const c = context ? context._el : document.documentElement;
  const els = selector ? c.querySelectorAll(selector) : [];
  return Array.from(els, (el) => $(el));
}
function $N(tag, attributes = {}, parent) {
  const el = !SVG_TAGS.includes(tag) ? document.createElement(tag) : document.createElementNS("http://www.w3.org/2000/svg", tag);
  for (const [key, value] of Object.entries(attributes)) {
    if (value === void 0)
      continue;
    if (key === "id") {
      el.id = value;
    } else if (key === "html") {
      el.innerHTML = value;
    } else if (key === "text") {
      el.textContent = value;
    } else if (key === "path") {
      el.setAttribute("d", drawSVG(value));
    } else {
      el.setAttribute(key, value);
    }
  }
  const $el = $(el);
  if (parent)
    parent.append($el);
  return $el;
}
var $body = new WindowView(document.body);
var $html = new WindowView(document.documentElement);

// src/ajax.ts
function toQueryString(data) {
  const pairs = [];
  for (let key of Object.keys(data)) {
    let value = data[key];
    key = encodeURIComponent(key);
    if (value == void 0) {
      pairs.push(key);
      continue;
    }
    value = Array.isArray(value) ? value.join(",") : `${value}`;
    value = value.replace(/(\r)?\n/g, "\r\n");
    value = encodeURIComponent(value);
    value = value.replace(/%20/g, "+");
    pairs.push(`${key}=${value}`);
  }
  return pairs.join("&");
}
function fromQueryString(str) {
  str = str.replace(/^[?,&]/, "");
  const pairs = decodeURIComponent(str).split("&");
  const result = {};
  pairs.forEach((pair) => {
    const x = pair.split("=");
    result[x[0]] = x[1];
  });
  return result;
}
function post(url, data) {
  return __async(this, null, function* () {
    const isForm = data instanceof FormData;
    const options = {
      method: "POST",
      body: isForm ? data : data ? toQueryString(data) : void 0,
      headers: { "X-CSRF-Token": window.csrfToken || "" }
    };
    if (!isForm)
      options.headers["Content-Type"] = "application/x-www-form-urlencoded";
    const ext = url.includes("?") ? "&xhr=1" : "?xhr=1";
    const response = yield fetch(url + ext, options);
    if (!response.ok)
      throw new Error(`Fetch error ${response.status}: ${url}`);
    return response.text();
  });
}
function loadScript(src) {
  return new Promise((resolve, reject) => {
    const el = document.createElement("script");
    el.src = src;
    el.onerror = reject;
    el.onload = resolve;
    document.head.appendChild(el);
  });
}
function loadImage(url, credentials = false) {
  return new Promise((resolve) => {
    const img = new Image();
    if (!credentials)
      img.crossOrigin = "Anonymous";
    img.onload = () => resolve(img);
    img.src = url;
  });
}
var loadImageDataURI = cache((url) => __async(void 0, null, function* () {
  const img = yield loadImage(url);
  const $canvas = $N("canvas", { width: img.width, height: img.height });
  $canvas.ctx.drawImage(img, 0, 0, img.width, img.height);
  return $canvas.image("png");
}));
var POST_DATA = /* @__PURE__ */ new Map();
function savePostData(url, data) {
  if (POST_DATA.has(url)) {
    deepExtend(POST_DATA.get(url), data, (a, b) => unique(a.concat(b)));
  } else {
    POST_DATA.set(url, data);
  }
}
function sendPostData() {
  if (!window.navigator.onLine)
    return;
  for (const [url, data] of POST_DATA) {
    POST_DATA.delete(url);
    post(url, { data: JSON.stringify(data) }).catch((error) => {
      console.error("Failed to send POST request:", error);
      savePostData(url, data);
    });
  }
}
var doDeferredPost = throttle2(sendPostData, 5e3);
window.addEventListener("online", doDeferredPost);
window.onbeforeunload = sendPostData;
function deferredPost(url, data) {
  savePostData(url, data);
  doDeferredPost();
}

// src/audio.ts
var AudioPlayer = class {
  constructor(src, defaultVolume = 1, preload = true) {
    this.src = src;
    this.defaultVolume = defaultVolume;
    this.player = new Audio();
    this.player.src = src;
    if (preload)
      this.player.preload = "auto";
  }
  play(volume) {
    this.player.currentTime = 0;
    this.player.volume = volume || this.defaultVolume;
    this.player.play();
  }
};

// src/confetti.ts
import { loop, tabulate } from "@mathigon/core";
import { Random } from "@mathigon/fermat";
var colours = loop(["#cd0e66", "#0f82f2", "#22ab24", "#fd8c00"]);
var Particle = class {
  constructor(index) {
    this.index = index;
    this.color = colours();
    this.tilt = Math.floor(Math.random() * 10) - 10;
    this.tiltAngleIncrement = Math.random() * 0.07 + 0.05;
    this.tiltAngle = 0;
    this.x = Math.random() * Browser.width;
    this.y = (Math.random() - 1) * Browser.height;
    this.r = Random.uniform(10, 30);
  }
  draw(ctx) {
    ctx.beginPath();
    ctx.lineWidth = this.r / 2;
    ctx.strokeStyle = this.color;
    ctx.moveTo(this.x + this.tilt + this.r / 4, this.y);
    ctx.lineTo(this.x + this.tilt, this.y + this.tilt + this.r / 4);
    ctx.stroke();
  }
  update(t, loop2) {
    this.tiltAngle += this.tiltAngleIncrement;
    this.y += (Math.cos(t) + 3 + this.r / 2) / 2;
    this.x += Math.sin(t);
    this.tilt = Math.sin(this.tiltAngle - this.index / 3) * 15;
    if (this.x < -20) {
      this.x = -20;
      this.y = Math.random() * Browser.height;
      this.tilt = Math.floor(Math.random() * 10) - 20;
    } else if (this.x > Browser.width + 20) {
      this.x = Browser.width + 20;
      this.y = Math.random() * Browser.height;
      this.tilt = Math.floor(Math.random() * 10) - 20;
    } else if (loop2 && this.y > Browser.height) {
      this.x = Math.random() * Browser.width;
      this.y = -10;
      this.tilt = Math.floor(Math.random() * 10) - 20;
    }
  }
};
var style = "position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999";
var $confetti = void 0;
function confetti(duration = 2e3, maxParticles = 150) {
  if (!$confetti)
    $confetti = $N("canvas", { style }, $body);
  $confetti.setAttr("width", Browser.width);
  $confetti.setAttr("height", Browser.height);
  $confetti.show();
  const context = $confetti.ctx;
  const particles = tabulate((i) => new Particle(i), maxParticles);
  const animation = animate((t) => {
    context.clearRect(0, 0, Browser.width, Browser.height);
    const loop2 = t < duration;
    let visible = 0;
    for (const p of particles) {
      p.draw(context);
      p.update(t, loop2);
      if (p.y < Browser.height)
        visible += 1;
    }
    if (!visible) {
      animation.cancel();
      $confetti.hide();
    }
  });
}

// src/draggable.ts
import { EventTarget } from "@mathigon/core";
import { Bounds, Point as Point4 } from "@mathigon/euclid";
var Draggable = class extends EventTarget {
  constructor($el, options = {}) {
    super();
    this.$el = $el;
    this.startPos = new Point4(0, 0);
    this.position = new Point4(0, 0);
    this.disabled = false;
    this.options = Object.assign({ moveX: true, moveY: true, withinBounds: true }, options);
    Browser.onResize(() => this.updateBounds());
    slide($el, {
      start: () => {
        if (this.disabled)
          return;
        this.startPos = this.position;
        this.trigger("start");
        $html.addClass("grabbing");
      },
      move: (posn, start) => {
        if (this.disabled)
          return;
        this.setPosition(this.startPos.x + posn.x - start.x, this.startPos.y + posn.y - start.y);
        this.trigger("drag", { posn: this.position, pointerPosn: posn });
        this.checkTarget(posn);
      },
      end: (last2, start) => {
        if (this.disabled)
          return;
        this.trigger(last2.equals(start) ? "click" : "end", { $target: this.$over });
        if (this.options.$targets && !this.$over && this.options.resetOnMiss)
          this.resetPosition();
        this.$over = void 0;
        $html.removeClass("grabbing");
      },
      click: () => this.trigger("click"),
      accessible: true
    });
  }
  // ---------------------------------------------------------------------------
  // Target drag-n-drop
  addTarget($target) {
    var _a2;
    if (!this.options.$targets)
      this.options.$targets = [];
    (_a2 = this.options.$targets) == null ? void 0 : _a2.push($target);
  }
  removeTarget($target) {
    var _a2, _b;
    this.options.$targets = (_a2 = this.options.$targets) == null ? void 0 : _a2.filter(($el) => $el !== $target);
    if (!((_b = this.options.$targets) == null ? void 0 : _b.length))
      this.options.$targets = void 0;
  }
  checkTarget(posn) {
    if (!this.options.$targets)
      return;
    const $target = this.options.$targets.find(($t) => $t.boundsRect.contains(posn));
    if ($target === this.$over)
      return;
    if (this.$over)
      this.trigger("exit-target", { $target: this.$over });
    if ($target)
      this.trigger("enter-target", { $target });
    this.$over = $target;
  }
  // ---------------------------------------------------------------------------
  // Resizing and positioning
  updateBounds() {
    if (!this.options.withinBounds)
      return this.bounds = void 0;
    if (this.options.bounds)
      return this.bounds = this.options.bounds;
    const oldBounds = this.bounds;
    const $parent = this.options.$parent || this.$el.parent;
    const width = $parent.type === "svg" ? $parent.svgWidth : $parent.width;
    const height = $parent.type === "svg" ? $parent.svgHeight : $parent.height;
    this.bounds = new Bounds(0, width, 0, height);
    if (!width && !height)
      setTimeout(() => this.updateBounds());
    if (oldBounds) {
      this.setPosition(
        this.position.x * this.bounds.dx / oldBounds.dx || 0,
        this.position.y * this.bounds.dy / oldBounds.dy || 0
      );
    }
  }
  /** Sets the position of the element. */
  setPosition(x, y) {
    var _a2;
    let p = new Point4(this.options.moveX ? x : 0, this.options.moveY ? y : 0);
    if (this.bounds)
      p = p.clamp(this.bounds, (_a2 = this.options.margin) != null ? _a2 : 0);
    p = p.round(this.options.snap || 1);
    if (this.options.round)
      p = this.options.round(p);
    if (p.equals(this.position))
      return;
    this.position = p;
    if (this.options.useTransform) {
      this.$el.translate(p.x, p.y);
    } else {
      if (this.options.moveX)
        this.$el.css("left", `${p.x}px`);
      if (this.options.moveY)
        this.$el.css("top", `${p.y}px`);
    }
    this.trigger("move", { posn: p });
  }
  resetPosition(duration = 250) {
    return __async(this, null, function* () {
      const initial = this.position;
      this.$el.css({ "pointer-events": "none" });
      yield animate((p) => {
        const currentPos = Point4.interpolate(initial, this.startPos, p);
        this.setPosition(currentPos.x, currentPos.y);
      }, duration).promise;
      this.$el.css({ "pointer-events": "initial" });
    });
  }
};

// src/router.ts
import { EventTarget as EventTarget2 } from "@mathigon/core";
var LOADING_STYLE = "position: fixed; top: 0; left: 0; width: 100%; height: 4px; background: #0f82f2; pointer-events: none; z-index: 9999; will-change: transform;";
function getViewParams(url, view) {
  const match = view.regex.exec(url);
  if (match) {
    match.shift();
    const params = {};
    for (const [i, p] of view.params.entries())
      params[p] = match[i];
    return params;
  } else {
    return void 0;
  }
}
function getTemplate(view, params, url) {
  return __async(this, null, function* () {
    if (view.template) {
      if (typeof view.template === "string")
        return view.template;
      return view.template(params);
    }
    const str = yield fetch(url + (url.indexOf("?") >= 0 ? "&xhr=1" : "?xhr=1"));
    return str.text();
  });
}
var isReady2 = document.readyState === "complete";
window.addEventListener("load", () => setTimeout(() => isReady2 = true));
if ("scrollRestoration" in window.history) {
  window.history.scrollRestoration = "manual";
}
var Router = class extends EventTarget2 {
  constructor() {
    super(...arguments);
    this.$viewport = $body;
    this.views = [];
    this.active = { path: "", hash: "" };
    this.preloaded = false;
    this.transition = false;
    this.noLoad = false;
    this.initialise = () => void 0;
  }
  setup(options = {}) {
    if (options.$viewport)
      this.$viewport = options.$viewport;
    if (options.initialise)
      this.initialise = options.initialise;
    if (options.preloaded)
      this.preloaded = options.preloaded;
    if (options.transition)
      this.transition = options.transition;
    if (options.noLoad)
      this.noLoad = options.noLoad;
    if (options.click) {
      $body.on("click", (e) => this.onLinkClick(e));
    }
    if (options.history) {
      window.addEventListener("popstate", (e) => __async(this, null, function* () {
        var _a2;
        if (!isReady2 || !((_a2 = e.state) == null ? void 0 : _a2.path))
          return;
        const success = yield this.load(e.state.path, e.state.hash);
        if (!success)
          window.history.pushState(this.active, "", this.active.path + this.active.hash);
      }));
    }
  }
  view(url, { enter: enter2, exit: exit2, template } = {}) {
    const params = (url.match(/:\w+/g) || []).map((x) => x.substr(1));
    const regexStr = `${url.replace(/:\w+/g, "([\\w-]+)").replace("/", "\\/")}\\/?`;
    const searchStr = url.includes("?") ? "" : "(\\?.*)?";
    const regex = new RegExp(`^${regexStr}${searchStr}$`, "i");
    const thisView = { regex, params, enter: enter2, exit: exit2, template };
    this.views.push(thisView);
    const current = window.location.pathname + window.location.search;
    const viewParams = getViewParams(current, thisView);
    if (!viewParams)
      return;
    this.active = { path: current, hash: window.location.hash };
    window.history.replaceState(this.active, "", this.active.path + this.active.hash);
    Browser.ready(() => {
      setTimeout(() => {
        if (this.preloaded) {
          this.initialise(this.$viewport, viewParams);
          if (thisView.enter)
            thisView.enter(this.$viewport, viewParams);
        } else {
          this.loadView(thisView, viewParams);
        }
      });
    });
  }
  paths(...urls) {
    for (const url of urls)
      this.view(url);
  }
  getView(path) {
    for (const view of this.views) {
      const params = getViewParams(path, view);
      if (params)
        return { view, params };
    }
  }
  // ---------------------------------------------------------------------------
  // Loading and Rendering
  load(path, hash) {
    return __async(this, null, function* () {
      if (path === this.active.path && hash !== this.active.hash) {
        this.trigger("hashChange", hash.slice(1));
        this.trigger("change", path + hash);
        this.active = { path, hash };
        return true;
      }
      const go = this.getView(path);
      if (!go)
        return false;
      if (this.beforeChange && !(yield this.beforeChange()))
        return false;
      this.active = { path, hash };
      this.trigger("change", path + hash);
      if (window.ga)
        window.ga("send", "pageview", path + hash);
      if (this.noLoad) {
        if (go.view.enter)
          go.view.enter(this.$viewport, go.params);
      } else {
        this.loadView(go.view, go.params);
      }
      return true;
    });
  }
  loadView(_0) {
    return __async(this, arguments, function* (view, params = {}) {
      this.showLoadingBar();
      const path = this.active.path;
      const template = yield getTemplate(view, params, path);
      if (this.active.path !== path)
        return;
      yield this.$viewport.animate({ opacity: 0 }, 200).promise;
      this.$viewport.removeChildren();
      $body.scrollTop = 0;
      this.$viewport.html = template;
      Browser.resize();
      replaceSvgImports();
      this.$viewport.animate({ "opacity": 1 }, 200);
      this.hideLoadingBar();
      const $title = this.$viewport.$("title");
      if ($title)
        document.title = $title.text;
      this.initialise(this.$viewport, params);
      if (view.enter)
        view.enter(this.$viewport, params);
      this.trigger("afterChange", { $viewport: this.$viewport });
    });
  }
  // ---------------------------------------------------------------------------
  // Navigation Functions
  onLinkClick(e) {
    if (e.metaKey || e.ctrlKey || e.shiftKey)
      return;
    if (e.defaultPrevented)
      return;
    let el = e.target;
    while (el && el.nodeName !== "A")
      el = el.parentNode;
    if (!el || el.nodeName !== "A")
      return;
    const anchor = el;
    if (anchor.target)
      return;
    if (anchor.origin !== window.location.origin)
      return;
    if (anchor.hasAttribute("download") || anchor.getAttribute("rel") === "external")
      return;
    const link = anchor.getAttribute("href");
    if (link && link.indexOf("mailto:") > -1)
      return;
    if (this.getView(anchor.pathname + anchor.search)) {
      e.preventDefault();
      this.goTo(anchor.pathname + anchor.search, anchor.hash);
    }
  }
  goTo(path, hash = "") {
    return __async(this, null, function* () {
      const current = this.active.path + this.active.hash;
      const success = yield this.load(path, hash);
      if (success && current !== this.active.path + this.active.hash) {
        window.history.pushState(this.active, "", path + hash);
      }
    });
  }
  replace(path, hash = "") {
    this.active = { path, hash };
    window.history.replaceState(this.active, "", path + hash);
  }
  back() {
    window.history.back();
  }
  forward() {
    window.history.forward();
  }
  showLoadingBar() {
    if (!this.$loadingBar)
      this.$loadingBar = $N("div", { style: LOADING_STYLE }, $body);
    this.$loadingBar.css({ transform: "translateX(-100%)", opacity: 1 });
    this.$loadingBar.show();
    this.animation = animate((p) => {
      this.$loadingBar.css("transform", `translateX(-${10 + 90 * Math.exp(-4 * p)}%)`);
    }, 3e3);
  }
  hideLoadingBar() {
    return __async(this, null, function* () {
      var _a2, _b, _c;
      (_a2 = this.animation) == null ? void 0 : _a2.cancel();
      yield (_b = this.$loadingBar) == null ? void 0 : _b.animate({ transform: "none", opacity: 0 }).promise;
      (_c = this.$loadingBar) == null ? void 0 : _c.hide();
    });
  }
};
var RouterInstance = new Router();

// src/thread.ts
import { defer as defer2 } from "@mathigon/core";
function functionToWorker(fn) {
  const content = `onmessage = e => postMessage((${fn.toString()})(e.data))`;
  const blob = new Blob([content], { type: "application/javascript" });
  return URL.createObjectURL(blob);
}
function thread(url, data, timeout = 5e3) {
  const deferred = defer2();
  const worker = new Worker(url);
  const t = setTimeout(() => {
    worker.terminate();
    console.error("WebWorker timeout!");
    deferred.reject();
  }, timeout);
  worker.onmessage = (e) => {
    clearTimeout(t);
    worker.terminate();
    console.log(e);
    deferred.resolve(e.data);
  };
  worker.onerror = (e) => {
    clearTimeout(t);
    console.error("WebWorker error!", e);
    worker.terminate();
    deferred.reject(e);
  };
  worker.postMessage(data);
  return deferred.promise;
}

// src/webcomponents.ts
function applyTemplate(el, template) {
  const children = Array.from(el.childNodes);
  el.innerHTML = template;
  const slots = {};
  for (const s of Array.from(el.querySelectorAll("slot"))) {
    slots[s.getAttribute("name") || ""] = s;
  }
  for (const child of children) {
    const name = child.getAttribute ? child.getAttribute("slot") || "" : "";
    const slot = slots[name] || slots[""];
    if (slot)
      slot.parentNode.insertBefore(child, slot);
  }
  for (const slot of Object.values(slots))
    slot.parentNode.removeChild(slot);
}
function* customElementChildren(el) {
  for (const c of Array.from(el.children)) {
    if (c.tagName.includes("-")) {
      yield c;
    } else {
      yield* __yieldStar(customElementChildren(c));
    }
  }
}
var customElementOptions = /* @__PURE__ */ new Map();
var CustomHTMLElement = class extends HTMLElement {
  constructor() {
    super(...arguments);
    this.wasConnected = false;
    this.isReady = false;
  }
  connectedCallback() {
    return __async(this, null, function* () {
      if (this.wasConnected) {
        this._view.trigger("connected");
        return;
      }
      this.wasConnected = true;
      this.isReady = false;
      this._view.created();
      const options = customElementOptions.get(this._view.tagName) || {};
      if (options.template)
        applyTemplate(this, options.template);
      const promises = [...customElementChildren(this)].filter((c) => !c.isReady).map((c) => new Promise((res) => c.addEventListener("ready", res)));
      setTimeout(() => {
        if (!this.isReady)
          console.error(`Children of custom element ${this.tagName} not ready after 1s.`);
      }, 1e3);
      yield Promise.all(promises);
      this._view.ready();
      this.dispatchEvent(new CustomEvent("ready"));
      this.isReady = true;
    });
  }
  disconnectedCallback() {
    this._view.trigger("disconnected");
  }
};
var CustomElementView = class extends HTMLBaseView {
  created() {
  }
  ready() {
  }
};
var CUSTOM_ELEMENTS = /* @__PURE__ */ new Map();
function register(tagName, options = {}) {
  return function(ElementClass) {
    if (window.customElements.get(tagName)) {
      console.warn(`Trying to declare the custom element ${tagName} twice!`);
      return;
    }
    class Constructor extends CustomHTMLElement {
      constructor() {
        super();
        this._view = new ElementClass(this);
      }
    }
    CUSTOM_ELEMENTS.set(tagName, ElementClass);
    customElementOptions.set(tagName.toUpperCase(), options);
    window.customElements.define(tagName, Constructor);
  };
}
export {
  $,
  $$,
  $N,
  $body,
  $html,
  AudioPlayer,
  BaseView,
  Browser,
  CUSTOM_ELEMENTS,
  CanvasView2 as CanvasView,
  CustomElementView,
  Draggable,
  FormView,
  HTMLBaseView,
  InputView2 as InputView,
  MediaView,
  ResolvedAnimation,
  RouterInstance as Router,
  SVGBaseView,
  SVGParentView2 as SVGParentView,
  WindowView,
  animate,
  batch,
  bindAccessibilityEvents,
  bindEvent,
  canvasPointerPosition,
  cleanSVG,
  compile,
  compileString,
  confetti,
  copySVGStyles,
  deferredPost,
  ease,
  enter,
  exit,
  fromQueryString,
  functionToWorker,
  getEventTarget,
  hover,
  keyCode,
  loadImage,
  loadImageDataURI,
  loadScript,
  observe,
  parsePath,
  pathCommands,
  pointerOver,
  pointerPosition,
  post,
  register,
  replaceSvgImports,
  slide,
  svgPointerPosn,
  thread,
  toQueryString,
  transition,
  unbindEvent
};
//# sourceMappingURL=index.esm.js.map
